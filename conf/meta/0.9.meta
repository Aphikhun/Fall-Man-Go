#################################################################
############################## BASE #############################
#################################################################

# 多语言串
struct Text {
	[UUID: "true", COPY_LANG: "true"]
	string value;
};

struct Time {
	number value;
};

struct Uuid {
	[UUID: "true"]
	string value;
};

struct Tags {
	string module;
	string tags[];
};

#百分比类型，数值在0-1之间
struct Percentage{
	number value;
};

#################################################################
# color

struct Color {
	number r = 255;
	number g = 255;
	number b = 255;
	number a = 255;
};

#################################################################
# math
struct Vector2 {
	number x;
	number y;
};

#取值范围
struct ValueRange {
	
	attrs_updater(function(self)
		if attr(self, nil, "Integer") == "true" then
			set_attr(self, "min", "Integer", "true")
			set_attr(self, "max", "Integer", "true")
		end
		local min = attr(self, nil, "Min")
		if min then
			set_attr(self, "min", "Min", min)
		end
		local max = attr(self, nil, "Max")
		if min then
			set_attr(self, "max", "Max", max)
		end
		set_attr(self, "max", "Min", tostring(self.min));
		set_attr(self, "min", "Max", tostring(self.max));
	end);

	number min;
	number max;
	
	monitor("min", function(self, path, val)
		set_attr(self, "max", "Min", tostring(self.min));
	end);
	monitor("max", function(self, path, val)
		set_attr(self, "min", "Max", tostring(self.max));
	end);
};

struct Vector3 {
	number x;
	number y;
	number z;
};

struct Vector3i {
	[Integer: "true"]
	number x;

	[Integer: "true"]
	number y;

	[Integer: "true"]
	number z;
};

struct Vector2i {
	[Integer: "true"]
	number x;

	[Integer: "true"]
	number y;
};

struct UDim{
	[Update: "true", Step: "0.01"]
	number Scale;
	[Update: "true"]
	number Offect;
};

struct UVector2 {
	UDim UDim_X;
	UDim UDim_Y;
};

struct Rect {
	[Integer: "true"]
	number left;

	[Integer: "true"]
	number top;

	[Integer: "true"]
	number width;

	[Integer: "true"]
	number height;
};

struct Box {
	attrs_updater(function(self)
		set_attr(self.min, "x", "Min", "0")
		set_attr(self.min, "y", "Min", "0")
		set_attr(self.min, "z", "Min", "0")
		
		set_attr(self.max, "x", "Min", "0")
		set_attr(self.max, "y", "Min", "0")
		set_attr(self.max, "z", "Min", "0")
		
		set_attr(self.min, "x", "Max", "1")
		set_attr(self.min, "y", "Max", "1")
		set_attr(self.min, "z", "Max", "1")
		
		set_attr(self.max, "x", "Max", "1")
		set_attr(self.max, "y", "Max", "1")
		set_attr(self.max, "z", "Max", "1")
	end);
	
	Vector3 min = Vector3(x = 0, y = 0, z = 0);
	Vector3 max = Vector3(x = 1, y = 1, z = 1);
};



struct Margin {
	Vector2 top = Vector2(x = 0, y = 0);
	Vector2 left = Vector2(x = 0, y = 0);
	Vector2 bottom = Vector2(x = 0, y = 0);
	Vector2 right = Vector2(x = 0, y = 0);
};
#################################################################

struct ScenePos {
	MapEntry map;
	Vector3i pos;
};

struct Region {
	Vector3i min;
	Vector3i max;
};

struct SceneRegion {
	MapEntry map;
	Region region;
};
#################################################################
## resource

struct Resource_BlockTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_EntityTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_CEGUITexture{
	string selector;
	string asset;
	string name;
	string type = "image";

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
		local strs = Lib.splitString(self.selector, "/")
		self.name = strs[#strs] or ""
		return true
	end);
};

struct Resource_SkillTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_ItemTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};


enum Resource_ShopTexture_Selector{
	list(function()
		local Res = require "we.gamedata.res"
		return Res.list("texture/shop", "png")
	end);
};

struct Resource_ShopTexture {
	Resource_ShopTexture_Selector selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_Sound {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_Actor {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_Effect {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_Mesh {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

struct Resource_Skin {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

#动作 动画资源
struct Resource_Anim {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};


struct CastSound {
	bool selfOnly;
	bool loop;
	Percentage volume;
	Resource_Sound sound;
};

struct DeadSound : CastSound {
	Time delayTime;
};


struct EntityEffect{
	Resource_Effect effect;
	bool selfOnly;
	bool once = true;
	Vector3 pos;
	number yaw;
};

#################################################################
########################### BLOCK ###############################
#################################################################


# 包围盒纹理
struct Block_CubeTexture {
	Resource_BlockTexture up;
	Resource_BlockTexture down;
	Resource_BlockTexture front;
	Resource_BlockTexture back;
	Resource_BlockTexture left;
	Resource_BlockTexture right;
};

struct Block_DropSelf {
	bool canDropSelf = true;
	[Integer: "true", Min: "1"]
	number dropCount = 1;
};

struct Block_DropItem {
	ItemEntry item;
	[Integer: "true",Min: "1"]
	number count = 1;
};

struct BlockCfg {

	attrs_updater(function(self)
		local isQuad = self.isQuad and "false" or "true"
		set_attr(self, "textures", "Visible", isQuad)
		set_attr(self, "isOpaqueFullCube", "Visible", isQuad)
	end);

#################################################################
## 基础属性 BASE

	# 名字
	[TAB: "Block_Facade", GROUP: "BLOCK.GROUP.BASE", EditorData: "true"]
	Text name;

	# 分类标签
	[EditorData: "true"]
	hide Tags tags = Tags(module = "block");

	# 碰撞体积
	[TAB: "Physics", RELOAD: "true"]
	Box collisionBoxes[] = {
		Box()
	};

	# 贴图
	[TAB: "Block_Facade", RELOAD: "true"]
	Block_CubeTexture textures;

	# 不透明度
	[TAB: "Block_Facade", RELOAD: "true"]
	bool isOpaqueFullCube = true;
	
	# 死亡后掉落
	[TAB: "Block_Facade", RELOAD: "true"]
	bool candrop;
	
	# 弹性
	[TAB: "Physics", Min: "0", Max: "20"]
	number spring;

	# 自动下落
	[TAB: "Physics"]
	bool fall = false;

	# 自动下降速度
	[TAB: "Physics", Min: "0"]
	number maxFallSpeed = 1.5;


#################################################################
# 交互相关

	# 可被点击
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.CLICK"]
	bool canClick = false;
	
	#点击切换别的方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.CLICK"]
	BlockEntry clickChangeBlock;

	# 可被破坏
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	bool canBreak = true;

	# 硬度
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Time breakTime = Time(value = 20);
	
	# 掉落自身
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Block_DropSelf dropSelf;

	# 掉落道具
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Block_DropItem dropItems[];
	
	# 破坏后重生
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	bool recycle = false;
	
	# 破坏后重生时间
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Time recycleTime = Time(value = 20);
	
	# 踩上方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry onBuff;

	# 进入方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry inBuff;
	
	# 跳跃buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry jumpBuff[];
	
	# 跑动buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry runBuff[];
	
	# 疾跑buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry sprintBuff[];

#################################################################
# 音效相关 SOUND

	# 放置音效
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.SOUND"]
	CastSound placeBlockSound;

	# 敲碎音效
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.SOUND"]
	CastSound breakBlockSound;

#################################################################
# 攀爬相关 CLIMB

	# 攀爬速度
	[TAB: "Special", Min: "0"]
	number climbSpeed = 0;

#################################################################
## 其它 OTHER

	# 可游泳
	[TAB: "Special", GROUP: "BLOCK.GROUP.OTHER"]
	bool canSwim = false;

	# 最大移动速度
	[TAB: "Special", GROUP: "BLOCK.GROUP.OTHER", Min: "0"]
	number maxSpeed = 10000;

	[TAB: "Trigger", TRIGGER: "BlockTriggers"]
	TriggerSet triggers;
	
	hide bool isQuad;
};

enum BlockEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("block")
		
		for key , item in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key,
--				attrs = {name = item:val().name.value}
			})
		end

		collectgarbage("collect")
		return ret
	end);
};

struct BlockArray {
	BlockEntry blockArray[];
};

struct BlockObj{
	attrs_updater(function(self)
		set_attr(self.pos, "x", "Enabled", "false")
		set_attr(self.pos, "y", "Enabled", "false")
		set_attr(self.pos, "z", "Enabled", "false")
	end);
	[Module: "block"]
	Entrance block;
	Vector3i pos;
};

#################################################################
########################### Entity ##############################
#################################################################

enum BdVolumeType{
	"Box"
};

struct BoundingVolume{
	hide BdVolumeType type = "Box";
	Vector3 params;
};

[integer: "true"]
enum EquipSlot{
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9"
};

struct AI_Skill {
	[Min : "0"]
	number attackDis = 4;
	[Min : "0"]
	number priority;
	SkillEntry fullName;
};

#当AI走出领地
[Nonempty : "true"]
enum AI_OutOfHome {
	"birthplace",	#回到出生地
	"random"		#回到领地内随机位置
};

#AI领地相关
struct AI_Home {
	
	attrs_updater(function(self)
		set_attr(self, "homeSize", "Visible", self.enable and "true" or "false")
		set_attr(self, "outOfHome", "Visible", self.enable and "true" or "false")
	end);
	
	bool enable = true;
	[Min : "0"]
	number homeSize = 10;
	AI_OutOfHome outOfHome = "birthplace";
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "homeSize", "Visible", self.enable and "true" or "false")
		set_attr(self, "outOfHome", "Visible", self.enable and "true" or "false")
	end);

};

#AI攻击模式
[Nonempty : "true"]
enum AI_AttackMode {
	"hitBack",
	"autoAttack"
};

#AI攻击目标
[Nonempty : "true"]
enum AI_TargetType {
	"player",
	"any"
};

struct AI_Attack {
		
	attrs_updater(function(self)
		set_attr(self, "attackMode", "Visible", self.enable and "true" or "false")
		set_attr(self, "targetType", "Visible", self.enable and "true" or "false")
		set_attr(self, "chaseDistance", "Visible", self.enable and "true" or "false")
		set_attr(self, "maxVisualAngle", "Visible", self.enable and "true" or "false")
		set_attr(self, "skillList", "Visible", self.enable and "true" or "false")
	end);

	bool enable;
	AI_AttackMode attackMode = "hitBack";
	AI_TargetType targetType = "player";
	[Min : "0"]
	number chaseDistance = 10;
	[Min : "0", Max : "360", Integer : "true"]
	number maxVisualAngle = 360;
	AI_Skill skillList[];
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "attackMode", "Visible", self.enable and "true" or "false")
		set_attr(self, "targetType", "Visible", self.enable and "true" or "false")
		set_attr(self, "chaseDistance", "Visible", self.enable and "true" or "false")
		set_attr(self, "maxVisualAngle", "Visible", self.enable and "true" or "false")
		set_attr(self, "skillList", "Visible", self.enable and "true" or "false")
	end);
};

#AI巡逻方式
[Nonempty : "true"]
enum AI_PatrolMode {
	"no",
	"randomPath"
};

struct TimeRange {
	Time min;
	Time max;
};

#AI闲置
struct AI_Idle {
	Percentage prob;
	TimeRange idleTime = TimeRange(min = Time(value = 10), max = Time(value = 30));
};


#AI巡逻相关
struct AI_Patrol {
	attrs_updater(function(self)
		set_attr(self, "patrolDistance", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
		set_attr(self, "idle", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
	end);

	#巡逻方式
	AI_PatrolMode patrolMode = "no";
	#巡逻半径
	[Min : "0"]
	number patrolDistance = 5;
	AI_Idle idle;
	
	monitor("patrolMode", function(self, path, oval)
		set_attr(self, "patrolDistance", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
		set_attr(self, "idle", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
	end);
};

#AI遇到悬崖
struct AI_FaceCliff {
	attrs_updater(function(self)
		set_attr(self, "height", "Visible", self.avoidCliff and "true" or "false")
	end);

	bool avoidCliff = true;
	#悬崖的高度
	[Min : "1"]
	number height = 5;
	
	monitor("avoidCliff", function(self, path, oval)
		set_attr(self, "height", "Visible", self.avoidCliff and "true" or "false")
	end);
};

#AI移动规则
struct AI_WalkingRules {
	AI_FaceCliff faceCliff;
};

struct ScriptItem {
	string path;
};

[Preview: "actorName"]
struct EntityCfg {
#################################################################
## 基础属性 BASE

	attrs_updater(function(self)
		set_attr(self, "AI_home", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_attack", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_patrol", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_walkRules", "Visible", self.enableAI and "true" or "false")
	end);

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	#头像
	[TAB: "Base"]
	Resource_EntityTexture headPic;

	# 分类标签
	hide Tags tags = Tags(module = "entity");
	
	#模型
	[TAB: "Base", RELOAD: "true"]
	Resource_Actor actorName = Resource_Actor(
		asset = "asset/Actor/character_boy.actor",
		selector = "./conf/asset/actor/character_boy.actor");

	#最大生命值
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY", Min: "1", Max: "10000000"]
	number maxHp = 20;
		
	#是否复活
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY"]
	bool canRevive;
	
	#复活时间
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY"]
	Time reviveTime;

	#可被点击
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK"]
	bool canClick;

	#被点选距离
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK", Min: "1"]
	number clickDistance = 4;
	
	#可点击距离
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK", Min: "0", Max: "1000"]
	number reachDistance = 6.5;

	#不可被攻击
	[TAB: "Battle"]
	bool unAssailable;
	
	#免疫攻击时间
	[TAB: "Battle"]
	Time hurtResistantTime = Time(value = 20);

	#不可被伤害
	[TAB: "Battle"]
	bool unDamageable;
	
	#死亡销毁延迟
	[TAB: "Base", GROUP: "ENTITY.GROUP.BASE"]
	Time destroyTime;

#################################################################
# 音效相关 SOUND
	
	#死亡音效
	[TAB: "Base", GROUP: "ENTITY.GROUP.SOUND"]
	DeadSound deadSound;

#################################################################
# 攻击 ATTACK

	#攻击力
	[TAB: "Battle", GROUP: "ENTITY.GROUP.ATTACK", Min: "0"]
	number damage = 0;

#################################################################
# 移动 MOVE
	
	#可移动
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE"]
	bool canMove = true;

	#加速度
	hide number moveAcc = 0.2;

	#移动速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE", Min: "0"]
	number moveSpeed = 0.2;
	
	#抬脚高度
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE", Min: "0"]
	number stepHeight = 0.6;

	#移动速度倍率
	hide number moveFactor = 1;

# 跳跃 JUMP

	#可跳跃
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP"]
	bool canJump = true;

	#离地速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP", Min: "0"]
	number jumpSpeed = 0.5;

	#重力
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP", Min: "0"]
	number gravity = 0.08;

	#跳起高度
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP", Min: "0"]
	number jumpHeight = 0.6;


#################################################################
# 扣血 SUBHP

	#掉落阈值 掉落速度大于该值会有掉落伤害
	[TAB: "Move", GROUP: "ENTITY.GROUP.SUBHP"]
	number dropDamageStart = 50;
	
	# 落地扣血速率
	[TAB: "Move", GROUP: "ENTITY.GROUP.SUBHP", Min: "0"]
	number dropDamageRatio = 0;

# 漂浮 FLOAT

	#可漂浮
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT"]
	bool canBoat;

	#吃水线
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT", Min: "0"]
	number waterLine;
	
	#游泳速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT", Min: "0"]
	number swimSpeed = 0.2;

#宠物跟随
	
	#有目标时跟随距离
	[TAB: "Move", GROUP: "ENTITY.GROUP.PET", Min: "1"]
	number followEntityDistanceWhenHasTarget = 10;
	
	#无目标时跟随距离
	[TAB: "Move", GROUP: "ENTITY.GROUP.PET", Min: "1"]
	number followEntityDistanceWhenNotTarget = 5;

#################################################################
# 血条 LIFEBAR

	#隐藏血条
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",RELOAD: "true"]
	bool hideHp = true;

	#血条颜色
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",RELOAD: "true"]
	Color hpBarColor = Color(r = 255, g = 0, b = 0);

	#血条高度
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR", Min: "0",RELOAD: "true"]
	number hpBarHeight = 0.2;

	#血条宽度
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR", Min: "0",RELOAD: "true"]
	number hpBarWidth = 1;
	
	#隐藏名字
	[TAB: "Base", RELOAD: "true"]
	bool hideName;
	
	[TAB: "Base", Min: "0",RELOAD: "true"]
	number textHeight = 2.3;

#################################################################
# 技能 SKILL

	#技能
	[TAB: "Battle", GROUP: "ENTITY.GROUP.SKILL"]
	SkillEntry skill[];

	#眼睛高度
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY", Min: "1", Max: "2"]
	number eyeHeight = 1.62;

#################################################################
# 物理 Physics

	#有碰撞体积
	[TAB: "Physics", GROUP: "ENTITY.GROUP.COLLISION", RELOAD: "true"]
	bool collision;

	#碰撞体积
	[TAB: "Physics", GROUP: "ENTITY.GROUP.COLLISION", RELOAD: "true"]
	BoundingVolume boundingVolume = BoundingVolume(
		params = Vector3(x = 0.6, y = 1.8,z = 0.6)
	);
	
	[TAB: "Physics"]
	bool autoMove;
	
#################################################################
# 装备 EQUIP

	#装备槽
	[TAB: "Battle", GROUP: "ENTITY.GROUP.EQUIP"]
	EquipSlot equip[];

#################################################################
# AI

	#开启AI
	[TAB: "AI", GROUP: "ENTITY.GROUP.AI"]
	bool enableAI;

	#领地
	[TAB: "AI", GROUP: "ENTITY.GROUP.AI"]
	AI_Home AI_home;

	#战斗
	[TAB: "AI", GROUP: "ENTITY.GROUP.AI"]
	AI_Attack AI_attack;

	#巡逻
	[TAB: "AI", GROUP: "ENTITY.GROUP.AI"]
	AI_Patrol AI_patrol;

	#移动
	[TAB: "AI", GROUP: "ENTITY.GROUP.AI"]
	AI_WalkingRules AI_walkRules;
	
	#脚本
	[TAB: "Trigger", GROUP: "ENTITY.GROUP.CODE"]
	ScriptItem _clientScript[];
	monitor("_clientScript", function(self, path, oval, op)
		if op == "INSERT" then
			self._clientScript[path[#path]].path="client/client_script"--..#self._clientScript
		end
	end);

	[TAB: "Trigger", GROUP: "ENTITY.GROUP.CODE"]
	ScriptItem _serverScript[] ;
		monitor("_serverScript", function(self, path, oval, op)
			if op == "INSERT" then
				self._serverScript[path[#path]].path="server/server_script"--..#self._serverScript
			end
	end);
	
	monitor("enableAI", function(self, path, oval)
		set_attr(self, "AI_home", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_attack", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_patrol", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_walkRules", "Visible", self.enableAI and "true" or "false")
	end);


#################################################################
# 其他 OTHER
	[TAB: "Trigger", GROUP: "ENTITY.GROUP.OTHER", TRIGGER: "EntityTriggers"]
	TriggerSet triggers;
};

enum EntityEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("entity")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};


#################################################################
########################### MISSILE #############################
#################################################################

#子弹碰撞方块
enum MissileCollideBlock {
	"0",	#无碰撞
	"1",	#碰撞消失
	"2",	#碰撞反弹
	"3",	#碰撞阻挡
	"4",	#命中方块
};

#子弹碰撞单位
enum MissileCollideEntity {
	"0",	#无碰撞
	"1",	#任何单位
	"2",	#仅目标单位
};

[Nonempty: "true"]
enum MissileModelType {
	"empty",
	"mesh",
	"block",
};

struct MissileModel {
	attrs_updater(function(self)
		set_attr(self, "modelMesh", "Visible", self.type == "mesh" and "true" or "false")
		set_attr(self, "modelBlock", "Visible", self.type == "block" and "true" or "false")
	end);

	MissileModelType type = "empty";
	Resource_Mesh modelMesh;
	BlockEntry modelBlock;
	
	monitor("type", function(self, path, oval)
		set_attr(self, "modelMesh", "Visible", self.type == "mesh" and "true" or "false")
		set_attr(self, "modelBlock", "Visible", self.type == "block" and "true" or "false")
	end);
};

struct MissileEffect {
	Resource_Effect effect;
	bool once;
	bool timeLimit;
	Time time;
	Vector3 pos;
	number yaw;
};

struct MissileHitCount {
	#开启碰撞
	bool isValid;

	#最大碰撞次数
	[Min: "0", Integer : "true"]
	number hitCount;
	
	#最大碰撞单位次数
	[Min: "0", Integer : "true"]
	number hitEntityCount;
	
	#最大碰撞方块次数
	[Min: "0", Integer : "true"]
	number hitBlockCount;
};

struct MissileCfg {
#################################################################
## 名称&模型 NAME&MODEL

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	
	#子弹外形
	[TAB: "Base"]
	MissileModel missileModel;
	
	#包围盒
	[TAB: "Base"]
	BoundingVolume boundingVolume = BoundingVolume(
		params = Vector3(x = 0.2, y = 0.2,z = 0.2)
	);
	
#################################################################
## 飞行状态 FLY
	
	#移动速度/最大速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number moveSpeed = 2;
	
	#加速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number moveAcc;
		
	#重力
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number gravity;
	
	#旋转速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number rotateSpeed;
	
#################################################################
## 追踪目标 FOLLOW
	
	#追踪目标
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	bool followTarget;
	
#################################################################
## 生命周期 LIFECYCLE
	
	#存在时间
	[TAB: "Lifecycle"]
	Time lifeTime = Time(value = 100);
	
	#消亡时间
	[TAB: "Lifecycle"]
	Time vanishTime = Time(value = 10);
	
	#消亡显示
	[TAB: "Lifecycle"]
	bool vanishShow;
	
#################################################################
## 发射 SHOOT
		
	#发射时音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.SHOOT"]
	CastSound startSound;
	
	#发射时特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.SHOOT"]
	MissileEffect startEffect;
	
#################################################################
## 命中 HIT

	#碰撞次数
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT"]
	MissileHitCount hitCount;
	
	#子弹碰到单位
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.ENTITY"]
	MissileCollideEntity collideEntity = "1";
	
	#命中单位间隔
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.ENTITY"]
	Time hitInterval = Time(value = 10);
	
	#命中单位后技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.ENTITY"]
	SkillEntry hitEntitySkill;
	
	#命中单位音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.ENTITY"]
	CastSound hitEntitySound;
	
	#命中单位特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.ENTITY"]
	MissileEffect hitEntityEffect;
		
	#子弹碰到方块
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.BLOCK"]
	MissileCollideBlock collideBlock = "1";
	
	#命中方块后技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.BLOCK"]
	SkillEntry hitBlockSkill;
	
	#命中方块音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.BLOCK"]
	CastSound hitBlockSound;
	
	#命中方块特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.BLOCK"]
	MissileEffect hitBlockEffect;
	
	#反弹音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.BLOCK"]
	hide CastSound reboundBlockSound;
	

	
#################################################################
## 消失 VANISH

	#消失时技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	SkillEntry vanishSkill;
	
	#消失时特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	MissileEffect vanishEffect;
	
	#消失音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	CastSound vanishSound;

#################################################################
## 其他 OTHER
	
	[TAB: "Trigger", TRIGGER: "MissileTriggers"]
	TriggerSet triggers;

};

#################################################################
########################### Map #################################
#################################################################

#交互上使用，跳转到模板
struct Entrance{
	string cfg;
};

struct EntityObj{
	attrs_updater(function(self)
		set_attr(self.pos, "y", "Min", "0")
	end);

	[UUID: "true"]
	hide string id;
	hide string cfg;
	[Module: "entity"]
	Entrance entity;
	Vector3 pos;
	number ry;
};

struct RegionObj{
	[UUID: "true"]
	string id;
	Text name;
	RegionEntry cfg;
	Vector3i min;
	Vector3i max;
};

#地图迷雾
struct MapFog{
	bool hideFog = true;
	#可见范围
	[Min: "0"]
	number start = 10;
	#迷雾厚度
	[Min: "0"]
	number range = 5;
	#迷雾强度
	Percentage density = Percentage(value = 0.45);
	#迷雾颜色
	Color color = Color(r = 67, g = 207, b = 238);
};

struct MapCfg {

	#名字
	[EditorData: "true"]
	Text name;

	bool canAttack = true;

	bool canBreak = true;
	
	#地图迷雾
	[RELOAD: "true"]
	MapFog fog;

	hide EntityObj entitys[];
	hide RegionObj regions[];
};

enum MapEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("map")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = key
			})
		end

		return ret
	end);
};

#actor editor 编辑器

#高光
struct HightLight{
	#高光颜色
	Color light_color ;
	#高光系数 0~1
	[Min: "0.01"]
	Percentage light_ratio = Percentage(value = 0.15); 
	#高光强度 0~100 todo
	hide Percentage brightness = Percentage(value = 1.0);
};


#反射
struct ReflexLight{
	
	attrs_updater(function(self)
		set_attr(self, "light_ratio", "Visible", self.enable and "true" or "false")
	end);
	
	#是否启用
	bool enable = false;
	
	#系数
	number light_ratio;
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "light_ratio", "Visible", self.enable and "true" or "false")
	end);
};

#边缘光
struct EdgeLight{
	attrs_updater(function(self)
		set_attr(self, "light_color", "Visible", self.enable and "true" or "false")
	end);
	#是否启用
	bool enable = false;
	#系数
	Color light_color = Color(r = 255, g = 0, b = 0);
	monitor("enable", function(self, path, oval)
		set_attr(self, "light_color", "Visible", self.enable and "true" or "false")
	end);
};


#是否启用 循环播放 次数  动作 及 动作的特效 都用到 
struct LoopPlaySet{
	attrs_updater(function(self)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
	end);
	#是否启用
	bool enable = false;
	#次数只能是 大于零的整数
	[Min: "0"]
	number play_times = 1;
	monitor("enable", function(self, path, oval)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
		if self.enable then
			self.play_times = -1
		else
			self.play_times = 1
		end
	end);
};


#动作作用通道模式 全身 上半身 下半身
[Nonempty : "true"]
enum ChannelMode {
	"all",
	"upper",
	"lower"
};

#是否启用 自定义时长 动作配置 特效
struct CustomTimeSet{
	attrs_updater(function(self)
		set_attr(self, "play_times", "Visible", self.enable and "true" or "false")
	end);
	#是否启用
	bool enable = false;
	#系数
	[Min: "0"]
	number play_times = 1;
	monitor("enable", function(self, path, oval)
		set_attr(self, "play_times", "Visible", self.enable and "true" or "false")
		if self.enable then
			self.play_times = 1
		else
			self.play_times = -1
		end
	end);
};

#覆盖颜色模式
[Nonempty : "true"]
enum OverlayColorMode {
	"no",
	"overlay",
	"replace"
};

#材质 
struct Material{
	attrs_updater(function(self)
		set_attr(self, "overlayColor", "Visible", self.overlayMode ~= "no" and "true" or "false")
	end);

	#透明度 0~1
	Percentage alpha= Percentage(value = 1);
	#透明遮罩 0~1
	Percentage discard_alpha= Percentage(value = 0);
	#亮度 0~100 todo
	Percentage brightness = Percentage(value = 1.0);  
	#辉光 TODO 演示版本 屏蔽
	hide bool glow_enable = false;
	#光照
	hide bool linght_enable = false;
	
	#覆盖颜色模式
	OverlayColorMode overlayMode;
	#覆盖颜色
	Color overlayColor;
	
	monitor("overlayMode", function(self, path, oval)
		set_attr(self, "overlayColor", "Visible", self.overlayMode ~= "no" and "true" or "false")
	end);
	
	#高光 TODO 演示版本 临时隐藏 因为旧版也没找到作用回头查 
	HightLight hight_light;
	#反射
	#ReflexLight reflex_light;
	#边缘光
	EdgeLight edge_light;
};

#变换 
struct ActorEditorTransform{
	attrs_updater(function(self)
		set_attr(self.pos, "x", "Step", "0.01")
		set_attr(self.pos, "y", "Step", "0.01")
		set_attr(self.pos, "z", "Step", "0.01")
		
		set_attr(self.pos, "x", "Update", "true")
		set_attr(self.pos, "y", "Update", "true")
		set_attr(self.pos, "z", "Update", "true")
		
		set_attr(self.rotate, "x", "Update", "true")
		set_attr(self.rotate, "y", "Update", "true")
		set_attr(self.rotate, "z", "Update", "true")
	end);

	Vector3 pos = Vector3(x = 0, y = 0, z = 0);
	Vector3 rotate = Vector3(x = 0, y = 0, z = 0);
	#比例
	[Min: "0"]
	number scale = 1;
};

#ActorEditor ID
struct WithID {
	#ID
	[UndoStack: "barrier"]
	hide number id = 0;
};

#ActorEditor skin
struct ActorEditorSkin : WithID {
	#名字
	string name= "skin_name";
	
	#类型
	[Enabled: "false"]
	string type= "skin";
	
	#资源文件	
	#Resource_EntityTexture headPic1;
	Resource_Skin res_file;
	#string res_file= "skin_res_name";
	
	#材质
	Material material;
};

[Nonempty : "true", EnumText : "Value"]
enum ActorBindPart {
	list(function()
		local actor_main = require "we.sub_editors.actor_main"
		local cjson = require "cjson"
		local str = actor_main:getActor():GetBoneList()
		local tb = cjson.decode(str).bones
		local ret = {}
		for _, v in ipairs(tb) do
			table.insert(ret, {
				value = v
			})
		end
		return ret
	end);
};

#ActorEditor mesh
struct ActorEditorMesh : WithID {
	#名字
	string name = "mesh_name";
	
	#类型
	[Enabled: "false"]
	string type= "mesh";
	
	#变换 
	ActorEditorTransform transform;
	
	#资源文件	
	#Resource_EntityTexture headPic1;
	Resource_Mesh res_file;

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	
	#材质
	Material material;
};

#ActorEditor Effect 外观特效
struct ActorEditorEffect : WithID {
	#名字
	string name ="effect_name";
	
	#类型
	[Enabled: "false"]
	string type= "effect";
	
	#变换 
	ActorEditorTransform transform;
	
	#资源文件	
	#Resource_EntityTexture headPic1;
	Resource_Effect res_file;

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	
	#透明度 0~100 TODO ctor 的特效部件，透明度属性没有效果（先屏蔽掉这个属性）。
	hide Percentage alpha= Percentage(value = 1);
	
	#播放速度
	#[Min: "0"] TODO
	number play_speed = 1;
};

enum BodyPartMasterName{
	"body",
	"feet",
	"hand",
	"face",
	"clothes",
	"hair",
	"weapon",
	"shoulder"
};

#部件
struct ActorEditorBodyPart : WithID {
	[Actor_Facade_Name: "true", RegExp: "[A-Z0-9a-z_.]*"]
	string slave_name ="slave_name";
	[Editable : "true", EnumText : "Value"]
	BodyPartMasterName master_name = "mutex_name";
	
	hide bool default_use_enable = true;
	
	#对应原文件的索引
	hide number index = -1;
	
	#Skin 属性
	hide ActorEditorSkin skin[];
	
	#mesh 属性
	hide ActorEditorMesh mesh[];
	
	#effect 属性
	hide ActorEditorEffect effect[];
};

#外观
[UndoStack: "fork"]
struct ActorFace {
	ActorEditorBodyPart body_parts[];
};

#Skill 技能

struct ActorEditorSkill{
	#名字
	[Actor_Action_Name: "true", RegExp: "[A-Z0-9a-z_.]*"]
	string name ="skill_name";
	#类型 只读
	[Enabled: "false"]
	string type = "action";
	
	##动作编辑 动画属性
	hide ActionEditorAnimation action_editor_animation;
	
		##动作编辑 特效属性
	hide ActionEditorEffect action_editor_effect[];
	
	##动作编辑 音效属性 ToDo 引擎目前不支持
	#[TAB: "TAB.PROP", GROUP: "ACTORACTION.GROUP.SOUND"]
	#ActionEditorSound action_editor_sound[];
};

#动作编辑 动画属性
struct ActionEditorAnimation{
	#名字
	hide string name = "action_ani_name";
	#类型 只读
	[Enabled: "false"]
	string type = "animation"; 
	
	#资源文件
	[NotClearable: "true"]
	Resource_Anim res_file;
	
	#开始时间 
	[Min: "0", Enabled: "false"]
	number start_time;
	
	#持续时间
	#类型 只读
	[Enabled: "false"]
	number length = 1;
	
	#作用通道
	ChannelMode channel_mode;
	
	#播放设置
	#循环播放
	#bool enable = false;
	#播放次数
	#number play_times;
	#循环播放  播放次数
	#[TAB: "TAB.PROP", GROUP: "SKILL.GROUP.PLAYSET"] 说不定那天产品又要回来设置 播放循环
	 LoopPlaySet  loop_play_set;
	
	#播放速度
	[Min: "0"] #TODO 最小值限制
	number play_speed = 1;
	
	#过渡时间 0~100
	[Min: "0"] 	#TODO 最小值限制
	number transition_time = 0.25;
};

#动作编辑 特效属性
struct ActionEditorEffect{
	#名字 暂时没用了
	hide string name = "action_effect_name";
	#类型 只读
	[Enabled: "false"]
	string type = "action_effect";
	
	#资源文件	
	Resource_Effect res_file;
	
	#变换 
	ActorEditorTransform transform;
	

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	
	#跟随绑定位置  原“是否跟随Actor”
	bool follow_bind_part = true;
	
	#透明度
	hide Percentage alpha = Percentage(value = 1);
	
	
	#播放设置
	#循环播放
	#bool enable = false;
	#播放次数
	#number play_times;
	#循环播放  播放次数
	LoopPlaySet  loop_play_set; 
	
	#开始时间
	[Min: "0", Enabled: "true"]
	number start_time = 0.0;
	
	[Enabled: "false",Infty :"true"]
	 number length = 1;
	
	#播放速度
	[Min: "0"]
	number play_speed = 1;
	
	#自定义播放时长
	CustomTimeSet custom_time_set;
};

#动作编辑 音效属性
struct ActionEditorSound{
	#效果类型
	string name ="sound_name";
	#音效资源
	string res_name = "sound_res_sound";
	
	#播放设置
	#音量
	Percentage volume = Percentage(value = 1);
	#开始时间
	[Min: "0"]
	number start_time = 0.0;
	#持续时间
	[Min: "0"]
	number doing_time = 0.14;
	#循环播放
	bool loop_enable = false;
	#播放概率
	[Min: "0"]
	number play_probability;
	#是否广播
	bool broadcast_enable = false;

    #广播音量
	Percentage broadcast_volume = Percentage(value = 1);
};


#动作
[UndoStack: "fork"]
struct ActorAction{
	#Skill 属性
	ActorEditorSkill skill[];
	
	#动画资源列表 ToDo 没相关控件
	string ani_list[];
};

#actor 编辑器
struct ActorEditorCfg{

	#actor名字(显示用)
	[Enabled: "false"]
	string name;
	
	#骨架文件
	[Enabled: "false"]
	string res_skeleton = "boy.skel"; 
	
	#坐标
	Vector3 position;
	
	#旋转
	Vector3 rotation;
	
	#缩放
	Vector3 scale = Vector3(x = 1, y = 1, z = 1);
	
	#透明度
	Percentage alpha = Percentage(value = 1);

		#外观配置
	hide ActorFace actor_face;
	
	#动作配置
	hide ActorAction actor_action;
};

#################################################################
########################### Item ################################
#################################################################

# 道具类型
enum ItemType{
	"Equip",
	"InHand",
	"Use"
};

[Nonempty : "true", EnumText : "Value", Editable: "true"]
enum BoyBindPart {
	"bip01",
	"b_pelvis",
	"b_spine",
	"b_l_thigh",
	"b_l_calf",
	"b_l_foot",
	"b_r_thigh",
	"b_r_calf",
	"b_r_foot",
	"b_neck",
	"b_l_clavicle",
	"b_l_upperarm",
	"b_l_forearm",
	"b_r_clavicle",
	"b_r_upperarm",
	"b_r_forearm",
	"b_head",
	"b_l_wingbone01",
	"b_l_wingbone02",
	"b_l_wingbone03",
	"b_cloakbone01",
	"b_cloakbone02",
	"b_cloakbone03",
	"b_r_wingbone01",
	"b_r_wingbone02",
	"b_r_wingbone03",
	"b_tailbone01",
	"b_tailbone02",
	"b_tailbone03",
	"s_foot_l",
	"s_foot_r",
	"s_hand_l",
	"s_hand_r",
	"s_head",
	"s_back"
};

struct ItemBase{

};

# 装备道具
struct ItemEquip : ItemBase{
	EquipSlot tray;
	string itemGuise;
	string itemPosition;
	SkillEntry equip_skill[];
	BuffEntry equip_buff;
};

# 手持道具
struct ItemInHand : ItemBase{
	bool isCoin;
	BoyBindPart handItemBoneName = "s_hand_r";
	SkillEntry skill[];
	BuffEntry handBuff;
};

# 消耗道具
struct ItemUse : ItemBase{
	BuffEntry useBuff;
	Time time;
};

struct Item{
	ItemType type = "Equip";
	ItemBase base = ItemEquip();

	monitor("type",function(self,path,oval)
		if self.type == "Equip" then
			self.base = ctor("ItemEquip")
		elseif self.type == "InHand" then
			self.base = ctor("ItemInHand")
		elseif self.type == "Use" then
			self.base = ctor("ItemUse")
		end
	end);
};

#道具消耗类型
enum ConsumeType {
	"Block",
	"Item"
};

# 消耗道具种类
struct ConsumeItemType{
	ConsumeType type = "Item";
	BlockEntry block;
	ItemEntry item;
};

# 消耗道具
struct ConsumeItem{
	ConsumeItemType itemType;
	[Integer : "true", Min : "0"]
	number count = 1;
};

# 弹夹Item
struct ItemContainer {
	bool isValid = false;
	[Min: "0", Integer : "true"]
	number initCapacity;
	[Min: "0", Integer : "true"]
	number maxCapacity;
	ConsumeItemType itemType;
};

struct ItemCfg{
#################################################################
## 基础属性 BASE

	# 名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	# 模型
	[TAB: "Base"]
	Resource_Mesh mesh;

	# 图标
	[TAB: "Base"]
	Resource_ItemTexture icon;
	
	# 描述
	[TAB: "Base"]
	Text itemintroduction;
	
#################################################################
## 道具类型 TYPE

	[TAB: "ItemType", EditorData: "true"]
	Item item;


	# 背包每个格子可放数量
	[TAB: "ItemType", Min: "0", Integer : "true"]
	number stack_count_max = 1;

	#可被摧毁
	[TAB: "ItemType"]
	bool canAbandon;

	#可掉落
	[TAB: "ItemType"]
	bool candrop;

	#可被使用
	[TAB: "ItemType"]
	bool canUse;

	#可被保存
	[TAB: "ItemType"]
	bool needSave;

#################################################################
## 其他 OTHER
	#陷阱
	[TAB: "ItemType"]
	bool trap;

	#弹夹配置
	[TAB: "ItemType"]
	ItemContainer itemContainer;

	[TAB: "Trigger", TRIGGER: "ItemTriggers"]
	TriggerSet triggers;

};

enum ItemEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("item")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};


#################################################################
########################### Skill ###############################
#################################################################

# 技能动作
enum ActionType{
	"attack2",
	"attack",
	"aim2",
	"aim3",
	"jump3",
	"fly",
	"hammer"
};

# 技能类型
enum SkillType {
	"Base",
	"MeleeAttack",
	"Missile",
	"Reload",
	"Buff",
	"Ray",
	"UseItem"
};

# 弹夹设置
struct SkillContainer{
	attrs_updater(function(self)
		set_attr(self, "autoReloadSkill", "Visible", self.isValid and "true" or "false")
		set_attr(self, "takeNum", "Visible", self.isValid and "true" or "false")
	end);

	bool isValid;
	SkillEntry autoReloadSkill;
	[Min: "0"]
	number takeNum = 1;
	
	monitor("isValid", function(self, path, oval)
		set_attr(self, "autoReloadSkill", "Visible", self.isValid and "true" or "false")
		set_attr(self, "takeNum", "Visible", self.isValid and "true" or "false")
	end);
};

struct Skill_Base{
};

# 近战攻击
struct Skill_MeleeAttack : Skill_Base{
	[Min: "0"]
	number range = 4;

	#击退距离
	[Min: "0"]
	number hurtDistance = 0.1;
	
	[Min: "0"]
	number damage;

	[Min: "0"]
	hide number dmgFactor = 0;
};

#装弹技能
struct Skill_Reload : Skill_Base{
	#装弹时间
	Time reloadTime = Time(value = 20);
	#子弹
	ConsumeItemType consumeItem;
};

#buff目标
enum BuffTarget {
	"self",
	"skill_target"
};

#Buff技能
struct Skill_Buff : Skill_Base{
	BuffEntry buffCfg;
	Time buffTime;
	BuffTarget target = "skill_target";
};

#后坐力相关
#struct AutoRecoverRecoil {
#	bool recover;
#	number value;
#	Time time;
#};

struct Skill_Ray : Skill_Base{

	# 射线长度
	[Min: "0", Max: "1000"]
	number rayLenth;

	# 命中特效
	Resource_Effect hitEffect;

	# 轨道特效
	Resource_Effect trajectoryEffect;
	
	# 后坐力
	[Min: "0"]
	number recoil;

	# 命中触发
	SkillEntry hitEntitySkill;

	# 爆头触发
	SkillEntry hitEntityHeadSkill;
	
	# 命中方块触发
	SkillEntry hitBlockSkill;
};

struct MissileData {
	MissileEntry missileCfg;
	Vector3 startPos;
	
	[GROUP: "MissileData.GROUP.direction_of_fire"]
	number startYaw;
	[GROUP: "MissileData.GROUP.direction_of_fire"]
	number startPitch;
	
	[GROUP: "MissileData.GROUP.direction_of_the_missile"]
	number bodyYawOffset;
	[GROUP: "MissileData.GROUP.direction_of_the_missile"]
	number bodyPitchOffset;
	Time startWait;
};

#子弹目标类型
enum MissileTargetType {
	"CameraYaw",
	"Camera",
	"BodyYaw",
	"Entity",
	"Self",
	"Block",
	"FrontEntity",
	"Any",
	"None"
};

struct MissileTargetParam{
};

struct MissileTargetParam_FrontEntity : MissileTargetParam{
	number frontDistance = 1;
	number frontRange = 1;
	number frontHeight = 1;
};

struct MissileTargetStruct{
	attrs_updater(function(self)
		set_attr(self, "param", "Visible", self.type == "FrontEntity" and "true" or "false")
	end);

	MissileTargetType type = "Any";
	MissileTargetParam param;
	monitor("type", function(self, path, oval)
		if self.type == "FrontEntity" then
			self.param = ctor("MissileTargetParam_FrontEntity")
		else
			self.param = ctor("MissileTargetParam")
		end
		set_attr(self, "param", "Visible", self.type == "FrontEntity" and "true" or "false")
	end);
};

struct Skill_Missile : Skill_Base {
	MissileTargetStruct target;
	MissileData missile[];
};

struct Skill_UseItem : Skill_Base {
};

[EditorData: "true"]
struct Skill {
	attrs_updater(function(self)
		set_attr(self, "base", "Visible", 
			(self.type == "Base" or self.type == "" or self.type == "UseItem") and "false" or "true")
	end);
	SkillType type = "MeleeAttack";
	Skill_Base base = Skill_MeleeAttack();

	monitor("type", function(self, path, oval)
		if self.type == "MeleeAttack" then
			self.base = ctor("Skill_MeleeAttack")
		elseif  self.type == "Reload" then
			self.base = ctor("Skill_Reload")
		elseif self.type == "Buff" then
			self.base = ctor("Skill_Buff")
		elseif self.type == "Ray" then
			self.base = ctor("Skill_Ray")
		elseif self.type == "UseItem" then
			self.base = ctor("Skill_UseItem")
		elseif self.type == "Missile" then
			self.base = ctor("Skill_Missile")
		elseif self.type == "Base" or self.type == "" then
			self.base = ctor("Skill_Base")
		else
			assert(false, self.type)
		end
		set_attr(self, "base", "Visible", 
			(self.type == "Base" or self.type == "" or self.type == "UseItem") and "false" or "true")
	end);
};

#技能图标位置
struct SkillIconPos{
	number area_number;
};

#长按连发
struct EmitContinuously{
	bool isValid;
	Time castInterval;
};

#技能释放方式
struct SkillReleaseWay{

	attrs_updater(function(self)
		set_attr(self, "icon", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "iconPos", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "emitContinuously", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "draggingEnabled", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "sensitivityFactor", "Visible", self.isClickIcon and "true" or "false")
	end);

	#点击图标释放
	bool isClickIcon = true;
	#图标
	Resource_SkillTexture icon;
	#技能图标
	SkillIconPos iconPos;
	#图标可移动
	bool draggingEnabled;
	#移动灵敏度
	number sensitivityFactor;
	#长按连发
	EmitContinuously emitContinuously;
	
	monitor("isClickIcon", function(self, path, oval)
		set_attr(self, "icon", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "iconPos", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "emitContinuously", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "draggingEnabled", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "sensitivityFactor", "Visible", self.isClickIcon and "true" or "false")
	end);
	
	#点击释放
	bool isClick;
	
	#长按释放
	bool isTouch;
	# 长按时间
	Time touchTime;
};

struct SkillCfg {
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	
	#技能释放方式
	[TAB: "Base"]
	SkillReleaseWay skillReleaseWay;

	#冷却时间
	[TAB: "Base"]
	Time cdTime;

	#技能消耗
	[TAB: "Base"]
	ConsumeItem consumeItem[];

	# 饥饿度
	[TAB: "Base", Min: "0"]	
	number consumeVp = 0;

	#弹夹
	[TAB: "Base"]	
	SkillContainer container;
	
		
#################################################################
## 技能类型 TYPE
	[TAB: "Base"]
	Skill skill;


#################################################################
## 技能表现 SHOW
	
	# 准星
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW", EnumText: "Value"]
	FrontSightEntry frontSight;
	
	# 狙击镜 
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	hide bool snipe;

	# 释放动作
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW", Editable: "true"]
	ActionType castAction;
	
	# 释放动作时间
#	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
#	Time castActionTime;

	# 起手动作
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW", Editable: "true"]
	ActionType startAction;
	
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	Time startActionTime;
	
	# 音效
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	CastSound castSound;

	# 特效
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	EntityEffect castEffect;
	
	# 起手特效
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	hide EntityEffect startEffect;

	# 蓄力动作
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW", Editable: "true"]
	hide ActionType sustainAction;
	
	# 蓄力特效
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	hide EntityEffect sustainEffect;
	
	# 结束特效
	[TAB: "Expression", GROUP: "SKILL.GROUP.SHOW"]
	hide EntityEffect stopEffect;

#################################################################
## 其他 OTHER
	[TAB: "Trigger", TRIGGER: "SkillTriggers"]
	TriggerSet triggers;
};

enum SkillEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("skill")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

#################################################################
########################### Missile #############################
#################################################################

enum MissileEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("missile")
		
		for key , item in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key,
				attrs = {name = item:val().name.value}
			})
		end

		collectgarbage("collect")
		return ret
	end);
};

#################################################################
########################### FrontSight #############################
#################################################################

struct FrontSightCfg {
#################################################################
## 基础属性 BASE

};

enum FrontSightEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("frontsight")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end
		collectgarbage("collect")
		return ret
	end);
};

#################################################################
########################### Buff ################################
#################################################################

enum BuffSync {
	"all",
	"self",
	"team",
	"other"
};

#buff外观
struct BuffFacade {
	[RegExp: "[A-Z0-9a-z_.]*"]
	string slaveName;
	string masterName;
};

#动火替换
struct ReplaceAction {
	string beReplacedAction;
	string replaceAction;
};

[Nonempty : "true"]
enum BuffSuperposition {
	"superposition",
	"append",
	"reset",
	"max"
};

struct BuffCfg{
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	#可保存
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	bool needSave;
	
	#叠加规则
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	BuffSuperposition fixTime = "superposition";
	
	#死亡时移除
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	bool deadRemove;

#################################################################
## Buff效果 PECULIARITY

	# 最大血量
	[TAB: "Base", GROUP: "BUFF.GROUP.BIOLOGY"]
	number maxHp;

	# 走动速率
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveSpeed;

	# 移动速率
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveFactor;

	# 跳跃速度
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number jumpSpeed;
	
	# 加速度
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveAcc;

	# 重力
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number gravity;
		
	#反重力
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE", Min: "0", Step: "0.01"]
	number antiGravity;
	
	#替换动作
	[TAB: "Base"]
	ReplaceAction replaceAction[];

	# 落地扣血速度阈值
	[TAB: "Base", GROUP: "BUFF.GROUP.DROP"]
	number dropDamageStart;

	# 落地扣血速率
	[TAB: "Base", GROUP: "BUFF.GROUP.DROP"]
	number dropDamageRatio;
	
#################################################################
## 战斗

	# 攻击力
	[TAB: "Battle"]
	number damage;
	
	#攻击力系数
	[TAB: "Battle", Min: "-1", Step: "0.01"]
	number damagePct;
	
	#减伤系数
	[TAB: "Battle", Min: "-1", Max: "1", Step: "0.01"]
	number deDmgPct;
	
	# 攻击距离
	[TAB: "Battle"]
	number reachDistance;

	# 持续伤害
	[TAB: "Battle"]
	number continueDamage;
	
	# 不可被伤害
	[TAB: "Battle"]
	bool undamageable;

	# 不可被攻击
	[TAB: "Battle"]
	bool unassailable;
	
#################################################################
#表现

	#音效
	[TAB: "Expression"]
	CastSound sound;
	
	#特效
	[TAB: "Expression"]
	EntityEffect castEffect;
	
	#外观
	[TAB: "Expression"]
	BuffFacade skin[];
	
	# 是否透明
	[TAB: "Expression"]
	bool hide;
	
	# 透明度
	[TAB: "Expression", Min: "0", Max: "1"]
	number hideDeep = 0.4;

	#同步
	[TAB: "Expression"]
	BuffSync sync = "all";

};

enum BuffEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("buff")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

struct RotateTheCamera {
	attrs_updater(function(self)
		set_attr(self, "time", "Visible", self.enable and "true" or "false")
		set_attr(self, "pitch", "Visible", self.enable and "true" or "false")
		set_attr(self, "yaw", "Visible", self.enable and "true" or "false")
	end);

	bool enable;
	Time time;
	[Min: "-90", Max: "90"]
	number pitch;
	number yaw;
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "time", "Visible", self.enable and "true" or "false")
		set_attr(self, "pitch", "Visible", self.enable and "true" or "false")
		set_attr(self, "yaw", "Visible", self.enable and "true" or "false")
	end);
};

struct RegionView {
	attrs_updater(function(self)
		if self.enable then
			set_attr(self, "type",			"Visible", "true")
			set_attr(self, "viewFovAngle",	"Visible", "true")
			set_attr(self, "back_dragView",	"Visible", "true")
			if self.type == "FirstPerson" or self.type == "Fixed" then
				set_attr(self, "distance",		"Visible", "false")
				set_attr(self, "viewIsBlocked",	"Visible", "false")
				set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
			else
				set_attr(self, "distance",		"Visible", "true")
				set_attr(self, "viewIsBlocked",	"Visible", "true")
				set_attr(self, "pos",			"Visible", "false")
			end
		else
			set_attr(self, "type",			"Visible", "false")
			set_attr(self, "viewFovAngle",	"Visible", "false")
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "back_dragView",	"Visible", "false")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);

	bool enable;
	ViewType type = "Follow";
	[Min: "0", Max: "180"]
	number viewFovAngle = 75;
	[Min: "0"]
	number distance = 4;
	ViewIsBlocked viewIsBlocked = "PushCamera";
	bool back_dragView = true;
	ScenePos pos;
	
	monitor("enable", function(self, path, oval)
		if self.enable then
			set_attr(self, "type",			"Visible", "true")
			set_attr(self, "viewFovAngle",	"Visible", "true")
			set_attr(self, "back_dragView",	"Visible", "true")
			if self.type == "FirstPerson" or self.type == "Fixed" then
				set_attr(self, "distance",		"Visible", "false")
				set_attr(self, "viewIsBlocked",	"Visible", "false")
				set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
			else
				set_attr(self, "distance",		"Visible", "true")
				set_attr(self, "viewIsBlocked",	"Visible", "true")
				set_attr(self, "pos",			"Visible", "false")
			end
		else
			set_attr(self, "type",			"Visible", "false")
			set_attr(self, "viewFovAngle",	"Visible", "false")
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "back_dragView",	"Visible", "false")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);
	
	monitor("type", function(self, path, oval)
		if self.type == "FirstPerson" or self.type == "Fixed" then
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
		else
			set_attr(self, "distance",		"Visible", "true")
			set_attr(self, "viewIsBlocked",	"Visible", "true")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);
};


#################################################################
########################### Region ##############################
#################################################################

struct RegionCfg {

#################################################################
# 基础 BASE
	
	[TAB: "TAB.PROP", GROUP: "REGION.GROUP.BASE"]
	RotateTheCamera rotateTheCamera;
	
	[TAB: "TAB.PROP", GROUP: "REGION.GROUP.BASE"]
	RegionView view;

#################################################################
# 其他 OTHER

	[TRIGGER: "RegionTriggers"]
	hide TriggerSet triggers;
};

enum RegionEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("region")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = key
			})
		end

		return ret
	end);
};

#################################################################
########################### Game ################################
#################################################################
[Nonempty : "true"]
enum VarType {
	"int",
	"double",
	"bool",
	"entity",
	"vector3",
	"scene_pos",
	"string",
	"var"
};

[Property_Show_Root: "true"]
struct VarItem {
	string key;
	VarType type = "int";
	hide T_Int value;
	bool save = false;

	monitor("type", function(self, path, oval)
		if self.type == "int" then
			self.value = ctor("T_Int")
		elseif self.type == "double" then
			self.value = ctor("T_Double")
		elseif self.type == "bool" then
			self.value = ctor("T_Bool")
		elseif self.type == "entity" then
			self.value = ctor("T_Entity")
		elseif self.type == "vector3" then
			self.value = ctor("T_Vector3")
		elseif self.type == "scene_pos" then
			self.value = ctor("T_ScenePos")
		elseif self.type == "string" then
			self.value = ctor("T_String")
		elseif self.type == "var" then
			self.value = ctor("T_Var")
		end
	end);
};

[EditorData: "true"]
struct VarTable {
	VarItem global[];
	VarItem entity[];
};

struct Team {
	[Integer : "true", Min: "1"]
	number id = 1;
	ScenePos startPos;
};

struct TeamCfg {
	bool automatch;
	bool teammateHurt;
	bool showTeamStatusBar = true;
	Team team[];
};

struct CommodityItem{
	Text name;
	Text tip;
	ConsumeItemType item;
	[Integer : "true", Min: "0"]
	number count = 1;
	[Integer : "true", Min: "0"]
	number price = 1;
};

struct CommodityPageIndex{
	number val;
};

struct CommodityPage{
	CommodityPageIndex index;
	Resource_ShopTexture icon;
	Text name;
	CommodityItem items[];
};

[Nonempty : "true", EnumText : "Name"]
enum CurrencyEntry{
	list(function()
		local ret = {}
		table.insert(ret, {
			value = "gDiamonds",
			attrs = {name = "Currency.gDiamonds.name"}
		})
		local Coin = require "we.gamedata.coin"
		local Module = require "we.gamedata.module.module"
		local m = Module:module("item")
		
		for _, id in ipairs(Coin:list()) do
			local name = m:item(id):obj().name.value
			table.insert(ret, {
				value = id,
				attrs = {name = name}
			})
		end
		
		collectgarbage("collect")
		return ret
	end);
};

[Nonempty : "true", EnumText : "Name"]
enum UserCurrencyEntry {
	list(function()
	
		local ret = {}
		local Coin = require "we.gamedata.coin"
		local Module = require "we.gamedata.module.module"
		local m = Module:module("item")
		
		for _, id in ipairs(Coin:list()) do
			local name = m:item(id):obj().name.value
			table.insert(ret, {
				value = id,
				attrs = {name = name}
			})
		end
		
		collectgarbage("collect")
		return ret
	end);
};

#购买显示
[Nonempty : "true"]
enum LimitType{
	"NoLimit",
	#"Common",
	"Personal"
};

# 商城道具种类
struct ShopItemType{
	#道具类型 只会为item、block
	string type = "item";
	string item;
};

# 商城道具
struct ShopItem{
	ShopItemType item;
	Text name;
	[Integer : "true", Min: "0"]
	number price;
	CurrencyEntry coinId;
	[Integer : "true", Min: "1"]
	number num = 1;
	[Integer : "true", Min: "0"]
	number limit;
	LimitType limitType = "NoLimit";
	[Integer : "true", Min: "0"]
	number stackLimit = 1;
	Text detail;
};

struct ShopPage{
	Text name;
	ShopItem items[];
};

#视角类型
[Nonempty: "true"]
enum ViewType {
	"FirstPerson",
	"Back",
	"Front",
	"Follow",
	"Fixed"
};

#当视角被挡住
[Nonempty: "true"]
enum ViewIsBlocked {
	"PushCamera",
	"Don't"
};

struct ViewEnable {
	bool enable;
};

struct GameCfg {

	attrs_updater(function(self)
		set_attr(self, "firstPerson_viewFovAngle", "Visible", self.firstPerson_enable.enable and "true" or "false")
		set_attr(self, "firstPerson_dragView", "Visible", self.firstPerson_enable.enable and "true" or "false")
		
		set_attr(self, "back_viewFovAngle", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_distance", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_viewIsBlocked", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_dragView", "Visible", self.back_enable.enable and "true" or "false")
		
		set_attr(self, "front_viewFovAngle", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_distance", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_viewIsBlocked", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_dragView", "Visible", self.front_enable.enable and "true" or "false")
		
		set_attr(self, "follow_viewFovAngle", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_distance", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_viewIsBlocked", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_dragView", "Visible", self.follow_enable.enable and "true" or "false")
		
		set_attr(self, "fixed_viewFovAngle", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_viewPos", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_dragView", "Visible", self.fixed_enable.enable and "true" or "false")
		
		set_attr(self, "playTime", "Visible", self.unlimitedPlayTime and "false" or "true");
	end);
	
#################################################################
## 基础属性 BASE	

	hide EntityEntry playerCfg = "player1";

	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	ScenePos initPos;

	#可重玩
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool replay;

	#等待玩家进入时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitPlayerTime;

	#等待游戏开始时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitStartTime;

	#游戏正式开始
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitGoTime;

	#无限游戏时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool unlimitedPlayTime = true;

	#游戏时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time playTime = Time(value = 1200);
	
	monitor("unlimitedPlayTime", function(self, path, oval)
		set_attr(self, "playTime", "Visible", self.unlimitedPlayTime and "false" or "true");
	end);
	
	#显示结算面板时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time reportTime;

	#最大玩家数量
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE", Min: "0", Integer: "true"]
	number maxPlayers = 6;

	#最小玩家数量
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE",Min: "0", Integer: "true"]
	number minPlayers = 1;

	#游戏时间不流逝
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool isTimeStopped;

	#进入游戏的时间
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE", Min: "0", Max: "24", ShowSlider: "true"]
	number nowTime = 6;

	#一日时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE", Min: "1", Max: "1200"]
	Time oneDayTime = Time(value = 12000);

	#背包容量
	[Integer: "true",TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE", Min: "0", Max: "54"]
	number bagCap = 9;

	#显示任务图标
	#[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	#bool needTask;

	#可中途加入
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool canJoinMidway;
	
	#全局的数据储存
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool needSave = false;

#################################################################
## 队伍 TEAM
	
	#队伍
	[TAB: "TAB.TEAM"]
	TeamCfg team;

#################################################################
## 视角 VIEW

	#初始视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	ViewType defaultView = "FirstPerson";
	
	#允许切换视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	bool canSwitchView = true;
	
	#初始俯仰角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW", Min: "-90", Max: "90"]
	number defaultPitch;
	
	#初始偏航角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	number defaultYaw;
	
#####################第一视角#####################

	monitor("firstPerson_enable", function(self, path, oval)
		set_attr(self, "firstPerson_viewFovAngle", "Visible", self.firstPerson_enable.enable and "true" or "false")
		set_attr(self, "firstPerson_dragView", "Visible", self.firstPerson_enable.enable and "true" or "false")
	end);
	
	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON"]
	ViewEnable firstPerson_enable = ViewEnable(enable = true);
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON", Min: "0", Max: "180"]
	number firstPerson_viewFovAngle = 75;
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON"]
	bool firstPerson_dragView = true;
	
#####################后视角#####################

	monitor("back_enable", function(self, path, oval)
		set_attr(self, "back_viewFovAngle", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_distance", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_viewIsBlocked", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_dragView", "Visible", self.back_enable.enable and "true" or "false")
	end);
	
	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	ViewEnable back_enable = ViewEnable(enable = true);
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK", Min: "0", Max: "180"]
	number back_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK", Min: "0"]
	number back_distance = 4;
	
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	ViewIsBlocked back_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	bool back_dragView = true;
	
#####################前视角#####################

	monitor("front_enable", function(self, path, oval)
		set_attr(self, "front_viewFovAngle", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_distance", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_viewIsBlocked", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_dragView", "Visible", self.front_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	ViewEnable front_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT", Min: "0", Max: "180"]
	number front_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT", Min: "0"]
	number front_distance = 4;
		
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	ViewIsBlocked front_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	bool front_dragView = true;
	
#####################跟随视角#####################

	monitor("follow_enable", function(self, path, oval)
		set_attr(self, "follow_viewFovAngle", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_distance", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_viewIsBlocked", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_dragView", "Visible", self.follow_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	ViewEnable follow_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW", Min: "0", Max: "180"]
	number follow_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW", Min: "0"]
	number follow_distance = 4;
	
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	ViewIsBlocked follow_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	bool follow_dragView = true;
	
#####################固定视角#####################

	monitor("fixed_enable", function(self, path, oval)
		set_attr(self, "fixed_viewFovAngle", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_viewPos", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_dragView", "Visible", self.fixed_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	ViewEnable fixed_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED", Min: "0", Max: "180"]
	number fixed_viewFovAngle = 75;
	
	#摄像机坐标
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	ScenePos fixed_viewPos;
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	bool fixed_dragView = true;

#################################################################
# 其他 OTHER
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.OTHER", TRIGGER: "GameTriggers"]
	TriggerSet triggers;

#####################脚本#####################
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerMainScript main_srcipt;

	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript server_srcipt = TriggerGlobalScript(type = "server");
	
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript client_srcipt = TriggerGlobalScript(type = "client");

	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript common_srcipt = TriggerGlobalScript(type = "common");

#################################################################
# 隐藏 HIDE

	#变量
	hide VarTable vars;
	
	#商店
	hide CommodityPage commoditys[];
	
	#魔方商城
	hide ShopPage shops[];
	
	#显示魔方商店
	hide bool showShop;

};

#################################################################
############################## Tag ##########################
#################################################################

struct TagCfg {	
	#标签
	string tags[];
};

#################################################################
############################## Reward ##########################
#################################################################

#奖励类型
[Nonempty : "true"]
enum RewardType {
	"Block",
	"Item",
	"Coin",
	"List"	#随机奖励
};

struct RewardBase {	
};

struct RewardBlock : RewardBase {
	#block模板
	BlockEntry name;
	#数量
	[Integer : "true", Min : "0"]
	number count;
};

struct RewardItem : RewardBase {
	#item模板
	ItemEntry name;
	#取值范围
	[Integer: "true",Min: "0"]
	ValueRange countRange;
};

struct RewardCoin : RewardBase {
	#货币类型
	UserCurrencyEntry name = "green_currency";
	#数量
	[Integer : "true", Min : "0"]
	number count;
};

#随机奖励
struct RewardList : RewardBase {
	#取值范围
	[Integer: "true",Min: "0"]
	ValueRange countRange;
	#奖励表
	RewardListItem array[];
};

#随机奖励项
struct RewardListItem {
	Reward reward;
	number weight;
};

[EditorData: "true"]
struct Reward {
	RewardType type = "Block";
	RewardBase base = RewardBlock();

	monitor("type",function(self,path,oval)
		if self.type == "Block" then
			self.base = ctor("RewardBlock")
		elseif self.type == "Item" then
			self.base = ctor("RewardItem")
		elseif self.type == "Coin" then
			self.base = ctor("RewardCoin")
		elseif self.type == "List" then
			self.base = ctor("RewardList")
		end
	end);
};

#奖励配置
struct RewardCfg {
	[TAB: "Base", EditorData: "true"]
	Text name;

	#奖励列表
	[TAB: "Base"]
	Reward rewardArray[];
};

enum RewardEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("reward")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

#################################################################
############################## Trigger ##########################
#################################################################

#################################################################
struct T_Base {
	string action;
};

struct T_Any {
};

struct T_Array : T_Base {
};

[Compatible: "T_Int,T_Bool,T_String,T_Double,T_Entity,T_Vector3,T_ScenePos"]
struct T_Var : T_Base {

};

struct T_Void : T_Base {
};

struct Context {
	string key;
};

#TODO 上下文key
[Compatible: "T_String"]
struct T_Context : T_Base {
	Context rawval;
};

[Compatible: "T_Var,T_Double"]
struct T_Int : T_Base {
	[Integer: "true"]
	number rawval;
};

[Compatible: "T_Int,T_Var"]
struct T_Double : T_Base {
	number rawval;
};

[Compatible: "T_Int"]
struct T_MinInt : T_Base {
	[Min: "0"]
	number rawval;
};

[Compatible: "T_Var"]
struct T_String : T_Base {
	string rawval;
};

[Compatible: "T_Var,T_Entity,T_Object,T_Item,T_MapObj,T_Buff"]
struct T_Bool : T_Base {
	bool rawval;
};

[Compatible: "T_String"]
struct T_Text : T_Base {
	Text rawval;
};

[Compatible: "T_Var,T_ScenePos"]
struct T_Vector3i : T_Base {
	Vector3i rawval;
};

[Compatible: "T_Var,T_ScenePos"]
struct T_Vector3 : T_Base {
	Vector3 rawval;
};

[Compatible: "T_Int,T_Double,T_Var"]
struct T_Time : T_Base {
	Time rawval;
};

struct T_Region : T_Base {
	RegionEntry rawval;
};

struct T_Block : T_Base {
	BlockEntry rawval;
};

struct T_BlockArray : T_Base {
	BlockArray rawval;
};

struct T_EntityEntry : T_Base {
	EntityEntry rawval;
};

struct T_BuffEntry : T_Base {
	BuffEntry rawval;
};

struct T_SkillEntry : T_Base {
	SkillEntry rawval;
};

struct T_ItemEntry : T_Base {
	ItemEntry rawval;
};

struct T_RewardEntry : T_Base {
	RewardEntry rawval;
};

struct T_Box : T_Base {
	Box rawval;
};

#entity对象
[Compatible: "T_Var,T_Object"]
struct T_Entity : T_Base {
};

struct T_RankInfo : T_Base {
};

struct T_Buff : T_Base {
};

[Compatible: "T_Entity"]
struct T_Object : T_Base {
};

struct T_ObjectID : T_Base {
	number rawval;
};

struct T_Item : T_Base {
};

struct T_Missile : T_Base {
};

[Nonempty : "true",integer: "true"]
enum TipType{
	"1",
	"2",
	"3",
	"4",
	"5"
};

struct TipTypeCvr {
	TipType type;
};

struct T_TipType : T_Base {
	TipTypeCvr rawval;
};

struct T_MapObj : T_Base {
};

struct T_MapEntry : T_Base {
	MapEntry rawval;
};

[Compatible: "T_MapObj, T_MapEntry"]
struct T_Map : T_Base {
	MapEntry rawval;
};

struct T_IfBranch : T_Base {
};

[Compatible: "T_Var,T_Vector3"]
struct T_ScenePos : T_Base {
	ScenePos rawval; 
};

struct T_SceneRegion : T_Base {
	SceneRegion rawval;
};

struct T_Resource_Actor : T_Base {
	Resource_Actor rawval;
};

struct T_AIData : T_Base {
};

struct Talk {
	EntityEntry npc;
	Text msg;
};

struct TalkList {
	Talk talk[];
};

struct T_TalkList : T_Base {
	TalkList rawval;
};

struct TriggerName{
	string value;
};

struct Option {
	Text showText;
	TriggerName triggerName;
};

struct OptionList {
	Option option[];
};

struct T_OptionList : T_Base {
	OptionList rawval;
};

[Nonempty : "true", integer: "true"]
enum Compute {
	"add",
	"sub"
};

struct T_Compute : T_Base {
	Compute rawval;
};

[Nonempty : "true"]
enum BinaryOperCompute {
	"+",
	"-",
	"*",
	"/",
	"%"
};

struct T_BinaryOperCompute : T_Base {
	BinaryOperCompute rawval;
};

[Nonempty : "true"]
enum BinaryOperBool {
	">",
	"<",
	"==",
	"~=",
	">=",
	"<="
};

struct T_BinaryOperBool : T_Base {
	BinaryOperBool rawval;
};

[Nonempty : "true"]
enum BinaryOper {
	"and",
	"or"
};

struct T_BinaryOper : T_Base {
	BinaryOper rawval;
};

#struct VarKey {
#	ActionVarType type;
#	string key;
#};

#struct T_VarKey : T_Base {
#	VarKey rawval;
#};

[EnumText : "Value", EnumUpdate : "true"]
enum ObjectVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("entity")
		
		for key , v in pairs(vars) do
			table.insert(ret, {
				value = v
			})
		end

		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum GlobalVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("global")
		
		for key , v in pairs(vars) do
			table.insert(ret, {
				value = v
			})
		end
		
		return ret
	end);
};

struct T_ObjectVar : T_Base {
	ObjectVar_Selector rawval;
};

struct T_GlobalVar : T_Base {
	GlobalVar_Selector rawval;
};

enum Condition {
	"score"
};

struct T_Condition : T_Base {
	Condition rawval;
};

#################################################################
########################### Action ##############################
#################################################################
enum Enum_Action {
	list(function()
		local Action = require "we.gamedata.action"
		return Action:list()
	end);
};

enum ActionVarType {
	"global",
	"entity",
	"item",
	"team",
	"map",
	"region"
};

struct ActionParam {
	string key;
	T_Base value;
	bool must = false;
};

struct Component_Base {
};

struct Component_Var : Component_Base {
	ActionVarType type;
	string key;
};

struct Component_Params : Component_Base {
	ActionParam params[];
};

struct Component_Context : Component_Base {
	string key;
};

struct Component_Sequence : Component_Base {
	T_Base children[];
};

struct Component_Condition : Component_Base {
	T_IfBranch children[];
};

############################### Sys #############################
struct Node_Base {
	Uuid id;
	Vector2 pos;
};

struct ImportPort {
	Text name;
	string id;
	ActionParam param;
	T_Base children;
};

struct Node_Imports : Node_Base {
	ImportPort ports[];
};

struct ExportPort {
	Text name;
	string id;
	string type;
	T_Base value;
};

struct Node_Exports : Node_Base {
	ExportPort ports[];
};

struct Node_CollapseGraph : Node_Base {
	Text name;
	Node_Exports export_node;
	Node_Imports import_node;
	Action_Base actions[];
};

############################### Action_Base #############################
struct Action_Base : Node_Base {
	string name;
	string type;			# 返回类型
};

############################### Action_Entity #############################

[Catalog: "ActionCatalog_Entity"]
struct Action_SetHp : Action_Base {
	base(name = "SetHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "hp", value = T_Int(rawval = 1),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_Damage : Action_Base {
	base(name = "Damage", type = "T_Void");
	attrs_updater(function(self)
		local damage = self.components[1].params[2].value
		set_attr(damage, "rawval","Min", "0")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "damage", value = T_Int(),must = true),
			ActionParam(key = "from", value = T_Entity())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityHp : Action_Base {
	base(name = "AddEntityHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_RecoverFullHp : Action_Base {
	base(name = "RecoverFullHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_KillEntity : Action_Base {
	base(name = "KillEntity", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "from", value = T_Entity())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_ReviveEntity : Action_Base {
	base(name = "ReviveEntity", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityPosition : Action_Base {
	base(name = "SetEntityPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_Map()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityRebirthPosition : Action_Base {
	base(name = "SetEntityRebirthPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityHeight : Action_Base {
	base(name = "SetEntityHeight", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "height", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_MoveAllPlayers : Action_Base {
	base(name = "MoveAllPlayers", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityBuff : Action_Base {
	base(name = "AddEntityBuff", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_BuffEntry(),must = true),
			ActionParam(key = "buffTime", value = T_Time(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_RemoveEntityBuff : Action_Base {
#	base(name = "RemoveEntityBuff", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true),
#			ActionParam(key = "buff", value = T_Buff(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityScore : Action_Base {
	base(name = "SetEntityScore", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "val", value = T_MinInt(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityScore : Action_Base {
	base(name = "AddEntityScore", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "add", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_EntityDieDrop : Action_Base {
	base(name = "EntityDieDrop", type = "T_Item");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityVp : Action_Base {
	base(name = "AddEntityVp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_AddEntityExp : Action_Base {
#	base(name = "AddEntityExp", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true),
#			ActionParam(key = "exp", value = T_Int())
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_RewardMechanism : Action_Base {
	base(name = "RewardMechanism", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "path", value = T_RewardEntry(),must = true),
			#ActionParam(key = "check", value = T_Bool())
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_SetPlayerGameId : Action_Base {
#	base(name = "SetPlayerGameId", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_ChangeEntityActor : Action_Base {
	base(name = "ChangeEntityActor", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_Resource_Actor(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_CreateNpc : Action_Base {
	base(name = "CreateNpc", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true),
			ActionParam(key = "name", value = T_String()),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "enableAI", value = T_Bool()),
#			ActionParam(key = "aiData", value = T_AIData()),
			ActionParam(key = "owner", value = T_Entity()),
			ActionParam(key = "level", value = T_Int()),
#			ActionParam(key = "camp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_CreateNpcInArea : Action_Base {
	base(name = "CreateNpcInArea", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "minNumber", value = T_Int(),must = true),
			ActionParam(key = "maxNumber", value = T_Int(),must = true),
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true),
			ActionParam(key = "name", value = T_String()),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "enableAI", value = T_Bool()),
#			ActionParam(key = "aiData", value = T_AIData()),
			ActionParam(key = "owner", value = T_Entity()),
			ActionParam(key = "level", value = T_Int()),
#			ActionParam(key = "camp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_setPlayCameraYawToAttacker : Action_Base {
	base(name = "setPlayCameraYawToAttacker", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "target", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllEntities : Action_Base {
	base(name = "GetAllEntities", type = "T_Array");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntitiesByFullName : Action_Base {
	base(name = "GetEntitiesByFullName", type = "T_Array");
	attrs_updater(function(self)
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "fullName", value = T_EntityEntry(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_ShowPersonalInformations : Action_Base {
#	base(name = "ShowPersonalInformations", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "target", value = T_Entity(),must = true),
#			ActionParam(key = "player", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityCurHp : Action_Base {
	base(name = "GetEntityCurHp", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityScore : Action_Base {
	base(name = "GetEntityScore", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObjectDistance : Action_Base {
	base(name = "GetObjectDistance", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "obj1", value = T_Object(),must = true),
			ActionParam(key = "obj2", value = T_Object(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllPlayersCount : Action_Base {
	base(name = "GetAllPlayersCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllPlayers : Action_Base {
	base(name = "GetAllPlayers", type = "T_Array");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetSurvivePlayersCount : Action_Base {
	base(name = "GetSurvivePlayersCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetPlayerKillCount : Action_Base {
	base(name = "GetPlayerKillCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityMovingStyle : Action_Base {
	base(name = "GetEntityMovingStyle", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityYaw : Action_Base {
	base(name = "GetEntityYaw", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityCurVp : Action_Base {
	base(name = "GetEntityCurVp", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityLevel : Action_Base {
	base(name = "GetEntityLevel", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};


[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityHeight : Action_Base {
	base(name = "GetEntityHeight", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObjectID : Action_Base {
	base(name = "GetObjectID", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "object", value = T_Object(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityPosition : Action_Base {
	base(name = "GetEntityPosition", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetRebirthPos : Action_Base {
	base(name = "GetRebirthPos", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityStartPos : Action_Base {
	base(name = "GetEntityStartPos", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObject : Action_Base {
	base(name = "GetObject", type = "T_Object");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "objID", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IsPlayer : Action_Base {
	base(name = "IsPlayer", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IfEntityInArea : Action_Base {
	base(name = "IfEntityInArea", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "region", value = T_Region(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IsEntityAlive : Action_Base {
	base(name = "IsEntityAlive", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_AcceptTask : Action_Base {
#	base(name = "AcceptTask", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "player", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry()),
#			ActionParam(key = "show", value = T_Bool())
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityName : Action_Base {
	base(name = "GetEntityName", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetOwner : Action_Base {
	base(name = "GetOwner", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityYaw : Action_Base {
	base(name = "SetEntityYaw", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rotationYaw", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_RemoveBuffByFullName : Action_Base {
	base(name = "RemoveBuffByFullName", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "toTeam", value = T_Bool()),
			ActionParam(key = "buff", value = T_BuffEntry(),must = true)
		})
	};
};

############################### Action_Block #############################
[Catalog: "ActionCatalog_Block"]
struct Action_CreateBlock : Action_Base {
	base(name = "CreateBlock", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_RemoveBlock : Action_Base {
	base(name = "RemoveBlock", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "block", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_CreateRandomBlocksInRegion : Action_Base {
	base(name = "CreateRandomBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "creatnum", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_FillBlocksInRegion : Action_Base {
	base(name = "FillBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "block", value = T_Block(),must = true),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_RemoveBlocksInRegion : Action_Base {
	base(name = "RemoveBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "blockArray", value = T_BlockArray()),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_ClearBlocksInRegion : Action_Base {
	base(name = "ClearBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "blockArray", value = T_BlockArray()),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Block"]
#struct Action_DoDamgeToBlock : Action_Base {
#	base(name = "DoDamgeToBlock", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "pos", value = T_ScenePos()),
#			ActionParam(key = "damage", value = T_Int()),
#			ActionParam(key = "owner", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Block", RValue: "true"]
struct Action_GetBlockFullName : Action_Base {
	base(name = "GetBlockFullName", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_AddBlockItem : Action_Base {
	base(name = "AddBlockItem", type = "T_Void");

	attrs_updater(function(self)
		local vnode = self.components[1].params[3].value
		set_attr(vnode, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "count", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Block", RValue: "true"]
struct Action_FindFrontBlock : Action_Base {
	base(name = "FindFrontBlock", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "distance", value = T_Int(),must = true),
			ActionParam(key = "deep", value = T_Int(),must = true)
		})
	};
};

############################### Action_Item #############################

[Catalog: "ActionCatalog_Item"]
struct Action_AddItem : Action_Base {
	base(name = "AddItem", type = "T_Void");

	attrs_updater(function(self)
		local vnode = self.components[1].params[3].value
		set_attr(vnode, "rawval", "Min", "1")
		set_attr(vnode, "rawval", "Integer", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_ItemEntry(),must = true),
			ActionParam(key = "count", value = T_MinInt(rawval = 1),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Item"]
struct Action_ConsumeItem2 : Action_Base {
	base(name = "ConsumeItem2", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "item", value = T_ItemEntry(),must = true),
			ActionParam(key = "num", value = T_Int(),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Item"]
struct Action_SpawnItemToWorld : Action_Base {
	base(name = "SpawnItemToWorld", type = "T_Void");

	attrs_updater(function(self)
		local key = self.components[1].params[6].key
		if key ~= "params_control" then
			return
		end
		local params_control = self.components[1].params[6].value.rawval
		local pitch = self.components[1].params[7].value
		local yaw = self.components[1].params[8].value
		set_attr(pitch, "rawval", "Visible", params_control and "false" or "true")
		set_attr(yaw, "rawval", "Visible", params_control and "false" or "true")
		set_attr(self.components[1].params[6].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "fullName", value = T_ItemEntry(),must = true),
			ActionParam(key = "count", value = T_Int(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "time", value = T_Time(),must = true),
			ActionParam(key = "params_control", value = T_Bool()),
			ActionParam(key = "pitch", value = T_Int()),
			ActionParam(key = "yaw", value = T_Int())
		})
	};

	monitor("components", function(self,path,oval)
		local key = self.components[1].params[6].key
		if path[4] ~= 6 or key ~= "params_control" then
			return
		end
		local params_control = self.components[1].params[6].value.rawval
		local pitch = self.components[1].params[7].value
		local yaw = self.components[1].params[8].value
		set_attr(pitch, "rawval", "Visible", params_control and "false" or "true")
		set_attr(yaw, "rawval", "Visible", params_control and "false" or "true")
	end);
};

############################### Action_Skill #############################

[Catalog: "ActionCatalog_Skill"]
struct Action_AddSkill : Action_Base {
	base(name = "AddSkill", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Skill"]
struct Action_RemoveSkill : Action_Base {
	base(name = "RemoveSkill", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Skill"]
#struct Action_LearnSkill : Action_Base {
#	base(name = "LearnSkill", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry())
#		})
#	};
#};

#[Catalog: "ActionCatalog_Skill"]
#struct Action_ForgetSkill : Action_Base {
#	base(name = "ForgetSkill", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry())
#		})
#	};
#};

[Catalog: "ActionCatalog_Skill"]
struct Action_AddSkillToAllPlayers : Action_Base {
	base(name = "AddSkillToAllPlayers", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

############################### Action_AI #############################
[Catalog: "ActionCatalog_AI"]
struct Action_StopAI : Action_Base {
	base(name = "StopAI", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_AI"]
#struct Action_EnableAITargetPos : Action_Base {
#	base(name = "EnableAITargetPos", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "enable", value = T_Bool())
#		})
#	};
#};

############################### Action_UI #############################

[Catalog: "ActionCatalog_UI"]
struct Action_SetHeadText : Action_Base {
	base(name = "SetHeadText", type = "T_Void");

	attrs_updater(function(self)
		local x_vnode = self.components[1].params[2].value
		local y_vnode = self.components[1].params[3].value
		set_attr(x_vnode, "rawval", "Min", "-2")
		set_attr(x_vnode, "rawval", "Max", "2")
		set_attr(y_vnode, "rawval", "Min", "-3")
		set_attr(y_vnode, "rawval", "Max", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "x", value = T_Int()),
			ActionParam(key = "y", value = T_Int()),
			ActionParam(key = "headText", value = T_Text())
		})
	};
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_SetDamageText : Action_Base {
#	base(name = "SetDamageText", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "text", value = T_Text())
#		})
#	};
#};

#[Catalog: "ActionCatalog_UI"]
#struct Action_ShowCountDown : Action_Base {
#	base(name = "ShowCountDown", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "time", value = T_Time()),
#			ActionParam(key = "flag", value = T_Bool())
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowTip : Action_Base {
	base(name = "ShowTip", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "tipType", value = T_TipType(),must = true),
			ActionParam(key = "textKey", value = T_Text()),
			ActionParam(key = "keepTime", value = T_Time(),must = true)
##			ActionParam(key = "textP1", value = T_Text()),
##			ActionParam(key = "textP2", value = T_Text()),
##			ActionParam(key = "textP3", value = T_Text())
		})
	};
};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowShop : Action_Base{
	base(name = "ShowShop", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "showType", value = T_String( rawval = "shop"))
		})
	};
	
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_SendGameSettlement : Action_Base {
#	base(name = "SendGameSettlement", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "condition", value = T_Condition(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowSystemChat : Action_Base {
	base(name = "ShowSystemChat", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "key", value = T_Text())
		})
	};
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_ShowNumberEffect : Action_Base {
#	base(name = "ShowNumberEffect", type = "T_Void");

#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "player", value = T_Entity()),
#			ActionParam(key = "pos", value = T_ScenePos()),
#			ActionParam(key = "number", value = T_Int())
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_OpenConversation : Action_Base {
	base(name = "OpenConversation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "talkList", value = T_TalkList(),must = true),
			ActionParam(key = "optionList", value = T_OptionList()),
			ActionParam(key = "optionNpc", value = T_EntityEntry(),must = true)
		})
	};
};

############################### Action_Map #############################
[Catalog: "ActionCatalog_Map"]
struct Action_CreateMap : Action_Base {
	base(name = "CreateMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_MapEntry(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Map"]
#struct Action_CloseMap : Action_Base {
#	base(name = "CloseMap", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "map", value = T_MapObj(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Map"]
struct Action_EnterMap : Action_Base {
	base(name = "EnterMap", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetEntityMap : Action_Base {
	base(name = "GetEntityMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetPlayerMap : Action_Base {
	base(name = "GetPlayerMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "player", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetRandomPosInArea : Action_Base {
	base(name = "GetRandomPosInArea", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

# 进入副本
[Catalog: "ActionCatalog_Map"]
struct Action_EnterDuplication : Action_Base {
	base(name = "EnterDuplication", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Map"]
struct Action_LeaveDuplication : Action_Base {
	base(name = "LeaveDuplication", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map"]
struct Action_MoveMapPlayerTo : Action_Base {
	base(name = "MoveMapPlayerTo", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "newmap", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct GetStaticMap : Action_Base {
	base(name = "GetStaticMap", type = "T_MapObj");
	attrs_updater(function(self)
		local create_node = self.components[1].params[2].value
		set_attr(create_node, "rawval","Visible", "false")
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_Map(),must = true),
			ActionParam(key = "create", value = T_Bool(rawval = true))
		})
	};
};

############################### Action_Game #############################

[Catalog: "ActionCatalog_Game"]
struct Action_GameOver : Action_Base {
	base(name = "GameOver", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

#[Catalog: "ActionCatalog_Game"]
#struct Action_GameOverToPlayer : Action_Base {
#	base(name = "GameOverToPlayer", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity())
#		})
#	};
#};

[Catalog: "ActionCatalog_Game", RValue: "true"]
struct Action_GetGameTime : Action_Base {
	base(name = "GetGameTime", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true"]
struct Action_GetTime : Action_Base {
	base(name = "GetTime", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true"]
struct Action_GetMonth : Action_Base {
	base(name = "GetMonth", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "time", value = T_Time(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true"]
struct Action_GetYear : Action_Base {
	base(name = "GetYear", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "time", value = T_Time(),must = true)
		})
	};
};

############################### Logic #############################
[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ComputeInt : Action_Base {
	base(name = "BinaryOper", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Int(),must = true),
			ActionParam(key = "op", value = T_BinaryOperCompute(),must = true),
			ActionParam(key = "right", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ComputeDouble : Action_Base {
	base(name = "BinaryOper", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Double(),must = true),
			ActionParam(key = "op", value = T_BinaryOperCompute(),must = true),
			ActionParam(key = "right", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_ComputeBool : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Double(),must = true),
			ActionParam(key = "op", value = T_BinaryOperBool(),must = true),
			ActionParam(key = "right", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic",RValue: "true"]
struct Action_ComputeString : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_String(),must = true),
			ActionParam(key = "right", value = T_String(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic",RValue: "true"]
struct Action_BinaryOper : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "op", value = T_BinaryOper(),must = true),
			ActionParam(key = "left", value = T_Bool(),must = true),
			ActionParam(key = "right", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic",RValue: "true"]
struct Action_UnaryOper_Not : Action_Base {
	base(name = "UnaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "value", value = T_Bool(),must = true),
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_GetContextVar : Action_Base {
	base(name = "GetContextVar", type = "T_Base");

	Component_Base components[] = {
		Component_Context()
	};
};

[Catalog: "ActionCatalog_Var", RValue: "true"]
struct Action_GetUserContextVar : Action_Base {
	base(name = "GetContextVar", type = "T_Any");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String())
		})
	};
};

[Filter: "T_Void", Catalog: "ActionCatalog_Logic"]
struct Action_Parallel : Action_Base {
	base(name = "Parallel", type = "T_Void", pos = Vector2(x = 400, y = 300));

	Component_Base components[] = {
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_Sequence : Action_Base {
	base(name = "Sequence", type = "T_Bool");

	Component_Base components[] = {
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_Selector : Action_Base {
	base(name = "Selector", type = "T_Bool");

	Component_Base components[] = {
		Component_Sequence()
	};
};

[Filter: "T_Void", Catalog: "ActionCatalog_Logic"]
struct Action_If : Action_Base {
	base(name = "If", type = "T_Void");

	Component_Base components[] = {
		Component_Condition()
	};
};

[Filter: "T_IfBranch", Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_IfBranch : Action_Base {
	base(name = "IfBranch", type = "T_IfBranch");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "condition", value = T_Bool())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_LoopTimes : Action_Base {
	base(name = "LoopTimes", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "times", value = T_Time(),must = true),
			ActionParam(key = "key", value = T_String())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_ForLoop : Action_Base {
	base(name = "ForLoop", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "from", value = T_Int(),must = true),
			ActionParam(key = "to", value = T_Int(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true),
			ActionParam(key = "key", value = T_String())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_Foreach : Action_Base {
	base(name = "Foreach", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String()),
			ActionParam(key = "array", value = T_Array(),must = true)
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ComputeV3 : Action_Base {
	base(name = "ComputeV3", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Vector3(),must = true),
			ActionParam(key = "op", value = T_Compute(),must = true),
			ActionParam(key = "p2", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_Random : Action_Base {
	base(name = "Random", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "min", value = T_Int(),must = true),
			ActionParam(key = "max", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_NumberFloor : Action_Base {
	base(name = "NumberFloor", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_NumberCeil : Action_Base {
	base(name = "NumberCeil", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_Concat : Action_Base {
	base(name = "Concat", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_String()),
			ActionParam(key = "p2", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ArraySize : Action_Base {
	base(name = "ArraySize", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "array", value = T_Array(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ArrayGet : Action_Base {
	base(name = "ArrayGet", type = "T_Any");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "array", value = T_Array(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_StartTimer2 : Action_Base {
	base(name = "StartTimer2", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "interval", value = T_Time(),must = true),
			ActionParam(key = "time", value = T_Int(),must = true),
			ActionParam(key = "timer", value = T_String()),
			ActionParam(key = "object", value = T_Entity())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic"]
struct Action_StopTimer2 : Action_Base {
	base(name = "StopTimer2", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "timer", value = T_String())
		})
	};
};


[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_IsNil : Action_Base {
	base(name = "IsNil", type = "T_Bool");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "data",value = T_Base(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_ToString : Action_Base {
	base(name = "ToString", type = "T_String");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(value = T_Double(),must = true)
		})
	};
};

############################### Var #############################
[Catalog: "ActionCatalog_Var", RValue: "true"]
struct Action_GetObjectVar : Action_Base {
	base(name = "GetObjectVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_ObjectVar(),must = true),
			ActionParam(key = "obj", value = T_Entity(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[2] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("entity",key)
			if var_key_type then
				local type = "T_"..var_key_type:gsub("^%l", string.upper)
				if var_key_type == "scene_pos" then
					self.type = "T_ScenePos"
				else
					self.type = type
				end
			end
		end
	end);
};

[Catalog: "ActionCatalog_Var"]
struct Action_SetObjectVar : Action_Base {
	base(name = "SetObjectVar", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_ObjectVar(),must = true),
			ActionParam(key = "value", value = T_Var()),
			ActionParam(key = "obj", value = T_Entity(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[4] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("entity",key)
			local type = "T_Var"
			if var_key_type then
				type = "T_"..var_key_type:gsub("^%l", string.upper)
			end
			if var_key_type == "scene_pos" then
				self.components[1].params[2].value = ctor("T_ScenePos")
			else
				self.components[1].params[2].value = ctor(type)	
			end
		end
	end);
};

[Catalog: "ActionCatalog_Var", RValue: "true"]
struct Action_GetGlobalVar : Action_Base {
	base(name = "GetGlobalVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_GlobalVar(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[2] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("global",key)
			if var_key_type then
				local type = "T_"..var_key_type:gsub("^%l", string.upper)
				if var_key_type == "scene_pos" then
					self.type = "T_ScenePos"
				else
					self.type = type
				end
			end
		end
	end);
};

[Catalog: "ActionCatalog_Var"]
struct Action_SetGlobalVar : Action_Base {
	base(name = "SetGlobalVar", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_GlobalVar(),must = true),
			ActionParam(key = "value", value = T_Var())
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[4] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("global",key)
			local type = "T_Var"
			if var_key_type then
				type = "T_"..var_key_type:gsub("^%l", string.upper)
			end
			if var_key_type == "scene_pos" then
				self.components[1].params[2].value = ctor("T_ScenePos")
			else
				self.components[1].params[2].value = ctor(type)	
			end
		end
	end);
};

############################### Action_Debug #############################
[Catalog: "ActionCatalog_Debug"]
struct Action_Test : Action_Base {
	base(name = "Test", type = "T_Void");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "Message",value = T_Base(),must = true)
		})
	};
};

############################### Action_Object #############################

############################### Action_Pet #############################
[Catalog: "ActionCatalog_Pet"]
struct Action_CreatePet : Action_Base {
	base(name = "CreatePet", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_EntityEntry(),must = true),
			ActionParam(key = "show", value = T_Bool(),must = true),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet", RValue: "true"]
struct Action_GetPet : Action_Base {
	base(name = "GetPet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_ShowPet : Action_Base {
	base(name = "ShowPet", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_HidePet : Action_Base {
	base(name = "HidePet", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_ChangePet : Action_Base {
	base(name = "ChangePet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true),
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_AddPet : Action_Base {
	base(name = "AddPet", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "player", value = T_Entity(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_RelievedPet : Action_Base {
	base(name = "RelievedPet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

############################### Action_Player #############################

############################### Action_Rank #############################

############################### Action_Team #############################

[Catalog: "ActionCatalog_Team"]
struct Action_AddTeamBuff : Action_Base {
	base(name = "AddTeamBuff", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamId", value = T_Int(),must = true),
			ActionParam(key = "cfg", value = T_BuffEntry(),must = true),
			ActionParam(key = "buffTime", value = T_Time())
		})
	};
};

[Catalog: "ActionCatalog_Team"]
struct Action_RemoveTeamBuff : Action_Base {
	base(name = "RemoveTeamBuff", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamId", value = T_Int(),must = true),
			ActionParam(key = "buff", value = T_Buff(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team", RValue: "true"]
struct Action_GetEntityTeam : Action_Base {
	base(name = "GetEntityTeam", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team"]
struct Action_SetEntityTeam : Action_Base {
	base(name = "SetEntityTeam", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "teamId", value = T_Int(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Team", RValue: "true"]
#struct Action_GetTeamEntityList : Action_Base {
#	base(name = "GetTeamEntityList", type = "T_Array");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "teamId", value = T_Int())
#		})
#	};
#};

############################### Action_Var #############################

#################################################################
############################# Trigger ###########################
#################################################################

struct TriggerArg {
	string key;
	string type;
};

struct Trigger {
	bool custom = false;
	string type;
	Action_Base actions[];
	Action_Parallel root;
};

[EditorData: "true"]
struct TriggerSet {
	Trigger list[];
};

struct TriggerMainScript {
};

struct TriggerGlobalScript {
	string type;
};

struct Trigger_Base {
	const string name;
	TriggerArg contexts[];
};

## Block
enum BlockTriggers {
	#"Trigger_BlockDead",
	"Trigger_BlockHitted",
	"Trigger_BlockIn",
	"Trigger_BlockOut",
	"Trigger_BlockClick",
	"Trigger_BlockOn",
	"Trigger_BlockLeave",
	"Trigger_BlockTouch",
	"Trigger_BlockBreak"
};

#struct Trigger_BlockDead : Trigger_Base {
#	base(name = "BLOCK_DEAD", contexts = {
#		TriggerArg(key = "obj1", type = "T_Entity"),
#		TriggerArg(key = "pos", type = "T_ScenePos")
#	});
#};

struct Trigger_BlockHitted : Trigger_Base {
	base(name = "BLOCK_HITTED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_BlockIn : Trigger_Base {
	base(name = "BLOCK_IN", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockOut : Trigger_Base {
	base(name = "BLOCK_OUT", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockClick : Trigger_Base {
	base(name = "BLOCK_CLICK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockOn : Trigger_Base {
	base(name = "BLOCK_ON", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockLeave : Trigger_Base {
	base(name = "BLOCK_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockTouch : Trigger_Base {
	base(name = "BLOCK_TOUCH", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockBreak : Trigger_Base {
	base(name = "BLOCK_BREAK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

##Entity

enum EntityTriggers {
	"Trigger_EntityEnter",
	"Trigger_EntityLeave",
	"Trigger_EntityDie",
	"Trigger_EntityRebirth",
	"Trigger_EntityDamage",
	"Trigger_EntityHitted",
	"Trigger_HitEntity",
	"Trigger_EntityClick",
	"Trigger_EntityLevelUP",
	"Trigger_ENTITY_TOUCH_ALL",
	"Trigger_GameReady_Entity",
	"Trigger_GameStart_Entity",
	"Trigger_GameGo_Entity",
	"Trigger_GameOver_Entity",
#	"Trigger_GameExit_Entity"
};

struct Trigger_EntityEnter : Trigger_Base {
	base(name = "ENTITY_ENTER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityLeave : Trigger_Base {
	base(name = "ENTITY_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityDie : Trigger_Base {
	base(name = "ENTITY_DIE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityRebirth : Trigger_Base {
	base(name = "ENTITY_REBIRTH", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityDamage : Trigger_Base {
	base(name = "ENTITY_DAMAGE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityHitted : Trigger_Base {
	base(name = "ENTITY_HITTED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_HitEntity : Trigger_Base {
	base(name = "HIT_ENTITY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_EntityClick : Trigger_Base {
	base(name = "ENTITY_CLICK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityLevelUP : Trigger_Base {
	base(name = "ENTITY_LEVELUP", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_ENTITY_TOUCH_ALL : Trigger_Base {
	base(name = "ENTITY_TOUCH_ALL", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_GameReady_Entity : Trigger_Base {
	base(name = "GAME_READY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameStart_Entity : Trigger_Base {
	base(name = "GAME_START", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameGo_Entity : Trigger_Base {
	base(name = "GAME_GO", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameOver_Entity : Trigger_Base {
	base(name = "GAME_OVER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

#struct Trigger_GameExit_Entity : Trigger_Base {
#	base(name = "GAME_EXIT", contexts = {
#		TriggerArg(key = "obj1", type = "T_Entity")
#	});
#};

##Item

enum ItemTriggers {
	"Trigger_ItemTrap",
	"Trigger_DropItemPicked",
	"Trigger_UseItem",
	"Trigger_Hand",
	"Trigger_UnHand"
};

struct Trigger_ItemTrap : Trigger_Base {
	base(name = "ITEM_TRAP", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_DropItemPicked : Trigger_Base {
	base(name = "DROPITEM_PICKED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_UseItem : Trigger_Base {
	base(name = "USE_ITEM", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item"),
		TriggerArg(key = "itemName", type = "T_ItemEntry")
	});
};

struct Trigger_Hand : Trigger_Base {
	base(name = "HAND_ITEM_CHANGED_HAND", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_UnHand : Trigger_Base {
	base(name = "HAND_ITEM_CHANGED_UNHAND", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

##Skill

enum SkillTriggers{
	"Trigger_SkillCast"
};

struct Trigger_SkillCast : Trigger_Base {
	base(name = "SKILL_CAST", contexts = {
		TriggerArg(key = "owner", type = "T_Entity"),
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
#		TriggerArg(key = "pos", type = "T_Vector3"),
		TriggerArg(key = "fullName", type = "T_SkillEntry")
	});
};

##GameSetting

enum GameTriggers{
	"Trigger_GameInit",
	"Trigger_GameReady",
	"Trigger_GameStart",
	"Trigger_GameGo",
	"Trigger_GameOver"
##	"Trigger_GameExit"
};

struct Trigger_GameInit : Trigger_Base {
	base(name = "GAME_INIT", contexts = {
	});
};

struct Trigger_GameReady : Trigger_Base {
	base(name = "GAME_READY", contexts = {

	});
};

struct Trigger_GameStart : Trigger_Base {
	base(name = "GAME_START", contexts = {
		
	});
};

struct Trigger_GameGo : Trigger_Base {
	base(name = "GAME_GO", contexts = {
		
	});
};

struct Trigger_GameOver : Trigger_Base {
	base(name = "GAME_OVER", contexts = {
		
	});
};

##Region

enum RegionTriggers{
	"Trigger_RegionEnter",
	"Trigger_RegionLeave"
};

struct Trigger_RegionEnter : Trigger_Base {
	base(name = "REGION_ENTER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_RegionLeave : Trigger_Base {
	base(name = "REGION_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

##Missile
enum MissileTriggers{
	"Trigger_MissileHitEntity",
	"Trigger_MissileHitBlock"
};

struct Trigger_MissileHitEntity : Trigger_Base {
	base(name = "HIT_ENTITY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_MissileHitBlock : Trigger_Base {
	base(name = "HIT_BLOCK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

#################################################################
############################# BlockList #########################
#################################################################

struct BlockListCfg{
	[EditorData: "true"]
	Text name;
	hide number model[];
	hide Vector3i dis;
};

############################# UI #########################

enum Enum_Widget {
	list(function()
		local Widget = require "we.gamedata.widget"
		return Widget:list()
	end);
};

enum HorzAlignment{
	"LeftAligned",
	"RightAligned",
	"CentreAligned",
	"Justified"
};

enum VertAlignment{
	"TopAligned",
	"CentreAligned",
	"BottomAligned",
}; 

enum HorzScaling{
	"LeftAligned",
	"CentreAligned",
	"RightAligned",
	"Stretched",
	"Tiled"
};

enum VertsSaling{
	"TopAligned",
	"CentreAligned",
	"BottomAligned",
	"Stretched",
	"Tiled"
};

[Nonempty : "true"]
enum HorAlignment{
	"Left",
	"Centre",
	"Right"
};

[Nonempty : "true"]
enum VerAlignment{
	"Top",
	"Centre",
	"Bottom"
};

[Nonempty: "true"]
enum Resource_Font{
	"DroidSans",
};

[Nonempty: "true"]
enum Font_Size{
	"8",
	"10",
	"12",
	"14",
	"16",
	"18",
	"20",
	"22",
	"24",
	"26",
	"28",
	"36"
};

struct UI_ScriptItem{
	string path;
};

struct ImageStretch{
	[Min : "0", Update: "true"]
	number top_left;
	[Min : "0", Update: "true"]
	number top_right;
	[Min : "0", Update: "true"]
	number bottom_left;
	[Min : "0", Update: "true"]
	number bottom_right;
};

struct Anchor{
	number anchor = 1;
};

struct Thumb {
	Resource_CEGUITexture thumb_image = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/slider_thumb.png", name = "slider_thumb.png");
	ImageStretch thumb_stretch;
};

struct Window_Base{
	hide Uuid id;
	UI_ScriptItem script;
	[GUIWindow_Name: "true", RegExp: "[A-Z0-9a-z_.]*", Update: "true"]
	string name;
	[Enabled: "false"]
	string gui_type;		#窗口类型
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool Visible = true;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	UVector2 pos;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	UVector2 size;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	hide HorAlignment HorizontalAlignment = "Left";
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	hide VerAlignment VerticalAlignment = "Top";
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	Anchor anchor;
	#Vector3 Rotation;
	[Min: "0", Max: "1",GROUP: "GUI.WINDOW_BASE.BASE", Update: "true", Step: "0.05"]
	number Alpha = 1;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	hide bool lock = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool ClippedByParent = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool Disabled = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool MousePassThroughEnabled;
	#Margin MarginProperty;
};

struct Window : Window_Base
{
	hide Window_Base children[];
};

[Catalog: "base"]
struct DefaultWindow : Window{
	base(gui_type = "DefaultWindow",name = "DefaultWindow", size = UVector2(UDim_X = UDim(Scale = 0,Offect =400), UDim_Y = UDim(Scale = 0,Offect =300)));
};

[Catalog: "base"]
struct StaticText : Window{
	base(gui_type = "StaticText", name = "Text", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 128)));
	attrs_updater(function(self)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);
	
	[GROUP: "GUI.STATICTEXT", Update: "true"]
	string Text = "Here is text";
	[GROUP: "GUI.STATICTEXT"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.STATICTEXT",Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.STATICTEXT"]
	Color TextColours = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.STATICTEXT"]
	bool BackgroundEnabled = false;
	[GROUP: "GUI.STATICTEXT"]
	Color BackgroundColours;
	monitor("BackgroundEnabled", function(self, path, oval)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICTEXT"]
	bool FrameEnabled = false;
	[GROUP: "GUI.STATICTEXT"]
	Color FrameColours;
	monitor("FrameEnabled", function(self, path, oval)
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICTEXT"]
	bool word_warpped = false;
	[GROUP: "GUI.STATICTEXT"]
	HorzAlignment HorzFormatting = "LeftAligned";
	[GROUP: "GUI.STATICTEXT"]
	VertAlignment VertFormatting = "TopAligned";

	[GROUP: "GUI.STATICTEXT"]
	bool BorderEnable = false;
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.STATICTEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.STATICTEXT"]
	Color BorderColor;
	monitor("BorderEnable",function(self,path,oval)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);
};

[Catalog: "base"]
struct StaticImage : Window{
	base(gui_type = "StaticImage", name = "Image", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 128), UDim_Y = UDim(Scale = 0,Offect = 128)));
	attrs_updater(function(self)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(stretch, "top_left", "Visible", "true")
			set_attr(stretch, "bottom_left", "Visible", "true")
		else
			set_attr(stretch, "top_left","Visible", "false")
			set_attr(stretch, "bottom_left","Visible", "false")
		end
		if vert == "Stretched" then
			set_attr(stretch, "top_right", "Visible", "true")
			set_attr(stretch, "bottom_right", "Visible", "true")
		else
			set_attr(stretch, "top_right","Visible", "false")
			set_attr(stretch, "bottom_right","Visible", "false")
		end

		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICIMAGE"]
	HorzScaling horzFormatting = "Stretched";
	monitor("horzFormatting", function(self, path, oval)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(stretch, "top_left", "Visible", "true")
			set_attr(stretch, "bottom_left", "Visible", "true")
		else
			set_attr(stretch, "top_left","Visible", "false")
			set_attr(stretch, "bottom_left","Visible", "false")
		end
		
	end);

	[GROUP: "GUI.STATICIMAGE"]
	VertsSaling vertFormatting = "Stretched";
	monitor("vertFormatting", function(self, path, oval)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if vert == "Stretched" then
			set_attr(stretch, "top_right", "Visible", "true")
			set_attr(stretch, "bottom_right", "Visible", "true")
		else
			set_attr(stretch, "top_right","Visible", "false")
			set_attr(stretch, "bottom_right","Visible", "false")
		end
	end);

	[GROUP: "GUI.STATICIMAGE"]
	Resource_CEGUITexture Image = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/def_image.png", name = "def_image.png");
	[GROUP: "GUI.STATICIMAGE"]
	ImageStretch StaticImageStretch;
	[GROUP: "GUI.STATICIMAGE"]
	bool FrameEnabled = false;
	[GROUP: "GUI.STATICIMAGE"]
	Color FrameColours;
	monitor("FrameEnabled", function(self, path, oval)
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICIMAGE"]
	Color ImageColours; 
	[GROUP: "GUI.STATICIMAGE"]
	bool BackgroundEnabled = false;
	[GROUP: "GUI.STATICIMAGE"]
	Color BackgroundColours;
	monitor("BackgroundEnabled", function(self, path, oval)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
	end);
};

[Catalog: "base"]
struct Button : Window{
	base(gui_type = "Button", name = "Button", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 96), UDim_Y = UDim(Scale = 0,Offect = 32)));
	attrs_updater(function(self)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(nor_stretch, "top_left", "Visible", "true")
			set_attr(nor_stretch, "bottom_left", "Visible", "true")
			set_attr(dis_stretch, "top_left", "Visible", "true")
			set_attr(dis_stretch, "bottom_left", "Visible", "true")
			set_attr(pus_stretch, "top_left", "Visible", "true")
			set_attr(pus_stretch, "bottom_left", "Visible", "true")
		else
			set_attr(nor_stretch, "top_left", "Visible", "false")
			set_attr(nor_stretch, "bottom_left", "Visible", "false")
			set_attr(dis_stretch, "top_left", "Visible", "false")
			set_attr(dis_stretch, "bottom_left", "Visible", "false")
			set_attr(pus_stretch, "top_left", "Visible", "false")
			set_attr(pus_stretch, "bottom_left", "Visible", "false")
		end
		if vert == "Stretched" then
			set_attr(nor_stretch, "top_right", "Visible", "true")
			set_attr(nor_stretch, "bottom_right", "Visible", "true")
			set_attr(dis_stretch, "top_right", "Visible", "true")
			set_attr(dis_stretch, "bottom_right", "Visible", "true")
			set_attr(pus_stretch, "top_right", "Visible", "true")
			set_attr(pus_stretch, "bottom_right", "Visible", "true")
		else
			set_attr(nor_stretch, "top_right", "Visible", "false")
			set_attr(nor_stretch, "bottom_right", "Visible", "false")
			set_attr(dis_stretch, "top_right", "Visible", "false")
			set_attr(dis_stretch, "bottom_right", "Visible", "false")
			set_attr(pus_stretch, "top_right", "Visible", "false")
			set_attr(pus_stretch, "bottom_right", "Visible", "false")
		end
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);

	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Update: "true"]
	string Text = "Button";
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color NormalTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	hide Color HoverTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color PushedTextColour;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	bool BorderEnable = false;
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color BorderColor;
	monitor("BorderEnable",function(self,path,oval)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);

	[GROUP: "GUI.BUTTON/BUTTON_IMAGE"]
	HorzScaling HorzImageFormatting = "Stretched";
	monitor("HorzImageFormatting", function(self, path, oval, op)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(nor_stretch, "top_left", "Visible", "true")
			set_attr(nor_stretch, "bottom_left", "Visible", "true")
			set_attr(dis_stretch, "top_left", "Visible", "true")
			set_attr(dis_stretch, "bottom_left", "Visible", "true")
			set_attr(pus_stretch, "top_left", "Visible", "true")
			set_attr(pus_stretch, "bottom_left", "Visible", "true")
		else
			set_attr(nor_stretch, "top_left", "Visible", "false")
			set_attr(nor_stretch, "bottom_left", "Visible", "false")
			set_attr(dis_stretch, "top_left", "Visible", "false")
			set_attr(dis_stretch, "bottom_left", "Visible", "false")
			set_attr(pus_stretch, "top_left", "Visible", "false")
			set_attr(pus_stretch, "bottom_left", "Visible", "false")
		end
	end);

	[GROUP: "GUI.BUTTON/BUTTON_IMAGE"]
	VertsSaling VertImageFormatting = "Stretched";
	monitor("VertImageFormatting", function(self, path, oval, op)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if vert == "Stretched" then
			set_attr(nor_stretch, "top_right", "Visible", "true")
			set_attr(nor_stretch, "bottom_right", "Visible", "true")
			set_attr(dis_stretch, "top_right", "Visible", "true")
			set_attr(dis_stretch, "bottom_right", "Visible", "true")
			set_attr(pus_stretch, "top_right", "Visible", "true")
			set_attr(pus_stretch, "bottom_right", "Visible", "true")
		else
			set_attr(nor_stretch, "top_right", "Visible", "false")
			set_attr(nor_stretch, "bottom_right", "Visible", "false")
			set_attr(dis_stretch, "top_right", "Visible", "false")
			set_attr(dis_stretch, "bottom_right", "Visible", "false")
			set_attr(pus_stretch, "top_right", "Visible", "false")
			set_attr(pus_stretch, "bottom_right", "Visible", "false")
		end
	end);

	[GROUP: "GUI.BUTTON/BUTTON_NORMALIMAGE"]
	Resource_CEGUITexture NormalImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/button_green_nor.png", name = "button_green_nor.png");
	[GROUP: "GUI.BUTTON/BUTTON_NORMALIMAGE"]
	ImageStretch NormalStretch;
	[GROUP: "GUI.BUTTON/BUTTON_HOVERIMAGE"]
	hide Resource_CEGUITexture HoverImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/button_green_nor.png", name = "button_green_nor.png");
	hide ImageStretch HoverStretch;
	[GROUP: "GUI.BUTTON/BUTTON_DISABLEDIMAGE"]
	Resource_CEGUITexture DisabledImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/button_green_disable.png", name = "button_green_disable.png");
	[GROUP: "GUI.BUTTON/BUTTON_DISABLEDIMAGE"]
	ImageStretch DisabledStretch;
	[GROUP: "GUI.BUTTON/BUTTON_PUSHEDIMAGE"]
	Resource_CEGUITexture PushedImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/button_green_act.png", name = "button_green_act.png");
	[GROUP: "GUI.BUTTON/BUTTON_PUSHEDIMAGE"]
	ImageStretch PushedStretch;
	

	monitor("NormalImage", function(self, path, oval, op)
		self.HoverImage.selector = self.NormalImage.selector
		self.HoverImage.asset = self.NormalImage.asset
		self.HoverImage.name = self.NormalImage.name
	end);

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);

	monitor("NormalStretch",function(self, path, oval, op)
		self.HoverStretch.top_left = self.NormalStretch.top_left
		self.HoverStretch.top_right = self.NormalStretch.top_right
		self.HoverStretch.bottom_left = self.NormalStretch.bottom_left
		self.HoverStretch.bottom_right = self.NormalStretch.bottom_right
	end);
};

[Catalog: "base"]
struct ProgressBar : Window{
	base(gui_type = "ProgressBar", name = "ProgressBar", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 32)));
	[Min : "0", Max : "1", Step : "0.01", GROUP: "GUI.PROGRESSBAR", Update: "true"]
	Percentage CurrentProgress;
	[GROUP: "GUI.PROGRESSBAR"]
	bool VerticalProgress = false;
	[GROUP: "GUI.PROGRESSBAR"]
	bool ReversedProgress = false;
	[GROUP: "GUI.PROGRESSBAR"]
	Resource_CEGUITexture progress_lights_image = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/progressbar_top.png", name = "progressbar_top.png");
	[GROUP: "GUI.PROGRESSBAR"]
	ImageStretch ProgressLightsStretch;
	[GROUP: "GUI.PROGRESSBAR"]
	Resource_CEGUITexture progress_background_image = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/progressbar_bg.png", name = "progressbar_bg.png");
	[GROUP: "GUI.PROGRESSBAR"]
	ImageStretch ProgressBgStretch;
};

[Catalog: "base"]
struct Editbox : Window{
	base(gui_type = "Editbox", name = "Editbox", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 32)));
	[GROUP: "GUI.EDITBOX", Update: "true"]
	string Text;
	[GROUP: "GUI.EDITBOX"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.EDITBOX", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.EDITBOX"]
	Color NormalTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.EDITBOX"]
	Color SelectedTextColour = Color( r = 255, g = 255, b = 255, a = 255);
	[GROUP: "GUI.EDITBOX"]
	Color ReadOnlyBGColour = Color( r = 223, g = 223, b = 223, a = 255);
	[GROUP: "GUI.EDITBOX"]
	bool MaskText;
	[Integer: "true",GROUP: "GUI.EDITBOX",Min:"0",Max:"10000"]
	number MaxTextLength = 10;
	[GROUP: "GUI.EDITBOX"]
	bool ReadOnly = false;
	[GROUP: "GUI.EDITBOX"]
	Resource_CEGUITexture BackGroundImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/editorbox_bg.png", name = "editorbox_bg.png");
	[GROUP: "GUI.EDITBOX"]
	ImageStretch BackGroundStretch;
	[GROUP: "GUI.EDITBOX"]
	Color ActiveSelectionColour = Color( r = 96, g = 127, b = 255, a = 255);
};

[Catalog: "base"]
struct Checkbox : Window{
	base(gui_type = "Checkbox", name = "Checkbox", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 36)));
	attrs_updater(function(self)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);
	[GROUP: "GUI.CHECKBOX"]
	bool Selected;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT", Update: "true"]
	string Text = "Checkbox";
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT", Min:"8", Max:"72", Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color NormalTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	hide Color HoverTextColour;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	bool BorderEnable = false;
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color BorderColor;
	monitor("BorderEnable",function(self,path,oval)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE"]
	Resource_CEGUITexture unselectableImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/checkbox_unselectable.png", name = "checkbox_unselectable.png");
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE"]
	ImageStretch UnselectableStretch;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE"]
	Resource_CEGUITexture selectableImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/checkbox_selectable.png", name = "checkbox_selectable.png");
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE"]
	ImageStretch SelectableStretch;

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);
};

[Catalog: "base"]
struct RadioButton : Window{
	base(gui_type = "RadioButton", name = "RadioButton", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 36)));
	attrs_updater(function(self)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);
	[GROUP: "GUI.RADIOBUTTON"]
	bool Selected;
	[Min: "-10000000", Max: "10000000", GROUP: "GUI.RADIOBUTTON"]
	number GroupID = 0;
	
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT", Update: "true"]
	string Text = "Radiobutton";
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;

	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color NormalTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	hide Color HoverTextColour;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	bool BorderEnable = false;
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color BorderColor;
	monitor("BorderEnable",function(self,path,oval)
		set_attr(self, "BorderWidth", "Visible", self.BorderEnable and "true" or "false")
		set_attr(self, "BorderColor", "Visible", self.BorderEnable and "true" or "false")
	end);

	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE"]
	Resource_CEGUITexture unselectableImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/radio_button_unselectable.png", name = "radio_button_unselectable.png");
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE"]
	ImageStretch UnselectableStretch;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE"]
	Resource_CEGUITexture selectableImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/radio_button_selectable.png", name = "radio_button_selectable.png");
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE"]
	ImageStretch SelectableStretch;

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);
};

[Catalog: "base"]
struct HorizontalSlider : Window{
	base(gui_type = "HorizontalSlider", name = "Slider",size = UVector2(UDim_X = UDim(Scale = 0,Offect =254), UDim_Y = UDim(Scale = 0,Offect = 30)));
	[GROUP: "GUI.HORIZONTALSLIDER", Update: "true"]
	number CurrentValue;
	[GROUP: "GUI.HORIZONTALSLIDER", Update: "true"]
	number MaximumValue = 1;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	hide bool ReversedDirection = false;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	Resource_CEGUITexture slider_top = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/slider_top_h.png", name = "slider_top_h.png");
	[GROUP: "GUI.HORIZONTALSLIDER"]
	ImageStretch TopImageStretch;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	Resource_CEGUITexture slider_bg = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/slider_bg.png", name = "slider_bg.png");
	[GROUP: "GUI.HORIZONTALSLIDER"]
	ImageStretch BgImageStretch;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	Thumb thumb;
};

[Catalog: "base"]
struct VerticalSlider : Window{
	base(gui_type = "VerticalSlider", name = "Slider",size = UVector2(UDim_X = UDim(Scale = 0,Offect = 30), UDim_Y = UDim(Scale = 0,Offect = 254)));
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	number CurrentValue;
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	number MaximumValue = 1;
	[GROUP: "GUI.VERTICALSLIDER"]
	hide bool ReversedDirection = false;
	[GROUP: "GUI.VERTICALSLIDER"]
	Resource_CEGUITexture slider_top = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/slider_top_v.png", name = "slider_top_v.png");
	[GROUP: "GUI.VERTICALSLIDER"]
	ImageStretch TopImageStretch;
	[GROUP: "GUI.VERTICALSLIDER"]
	Resource_CEGUITexture slider_bg = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/slider_bg.png", name = "slider_bg.png");
	[GROUP: "GUI.VERTICALSLIDER"]
	ImageStretch BgImageStretch;
	[GROUP: "GUI.VERTICALSLIDER"]
	Thumb thumb;
};

[Catalog: "base"]
struct ScrollableView : Window{
	base(gui_type = "ScrollableView", name = "ScrollableView",size = UVector2(UDim_X = UDim(Scale = 0,Offect =200), UDim_Y = UDim(Scale = 0,Offect = 200)));
	
	attrs_updater(function(self)
		set_attr(self, "MousePassThroughEnabled", "Visible", "false")
	end);

	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool moveAble = true;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	Resource_CEGUITexture BackGroundImage = Resource_CEGUITexture(selector = "def", asset = "asset/Texture/Gui/scrollable_pane_bg.png", name = "scrollable_pane_bg.png");
	[GROUP: "GUI.SCROLLABLEVIEW"]
	ImageStretch BgImageStretch;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool ForceHorzScrollbar = true;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool ForceVertScrollbar = true;
};

[Catalog: "layout"]
struct HorizontalLayoutContainer : Window{
	base(gui_type = "HorizontalLayoutContainer", name = "HorizontalLayout", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		local size_x = self.size.UDim_X
		local size_y = self.size.UDim_Y
		set_attr(size_x, "Scale", "Enabled", "false")
		set_attr(size_x, "Offect", "Enabled", "false")
		set_attr(size_y, "Scale", "Enabled", "false")
		set_attr(size_y, "Offect", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Visible", "false")
	end);
	[GROUP: "GUI.HORIZONTALLAYOUTCONTAINER", Min: "0", Max: "10000", Update: "true"]
	number space = 0;
	
};

[Catalog: "layout"]
struct VerticalLayoutContainer : Window{
	base(gui_type = "VerticalLayoutContainer", name = "VerticalLayout", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		local size_x = self.size.UDim_X
		local size_y = self.size.UDim_Y
		set_attr(size_x, "Scale", "Enabled", "false")
		set_attr(size_x, "Offect", "Enabled", "false")
		set_attr(size_y, "Scale", "Enabled", "false")
		set_attr(size_y, "Offect", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Visible", "false")
	end);
	[GROUP: "GUI.VERTICALLAYOUTCONTAINER", Min: "0", Max: "10000", Update: "true"]
	number space = 0;
};

[Catalog: "layout"]
struct GridView : Window {
	base(gui_type = "GridView", name = "GridView", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		local size_x = self.size.UDim_X
		local size_y = self.size.UDim_Y
		set_attr(size_x, "Scale", "Enabled", "false")
		set_attr(size_x, "Offect", "Enabled", "false")
		set_attr(size_y, "Scale", "Enabled", "false")
		set_attr(size_y, "Offect", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Visible", "false")
	end);
	[GROUP: "GUI.GRIDVIEW", Min: "0",  Max: "10000", Update: "true"]
	number hInterval;
	[GROUP: "GUI.GRIDVIEW", Min: "0",  Max: "10000", Update: "true"]
	number vInterval;
	[GROUP: "GUI.GRIDVIEW", Min: "0", Update: "true", Integer: "true"]
	number rowSize;
};

struct LayoutCfg{
	attrs_updater(function(self)
		local window_attrs = require "we.logic.ui.window_attrs"
		window_attrs:init(self.root)
	end);
	[Property_Show_Root: "true"]
	UI_ScriptItem script;
	[UndoStack: "fork"]
	DefaultWindow root = DefaultWindow(name = "Root");
};