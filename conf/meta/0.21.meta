#################################################################
############################## BASE #############################
#################################################################

# 多语言串
[Resettable: "false"]
struct Text {
	[UUID: "true", COPY_LANG: "true"]
	string value;
};

struct Time {
	number value;
};

struct ClockTime {
	number h;
	number m;
	number s;
};

struct Uuid {
	[UUID: "true"]
	string value;
};

struct Tags {
	string module;
	string tags[];
};

#百分比类型，数值在0-1之间
[Step: "0.01"]
struct Percentage {
	number value;
};

#################################################################
# color

struct Color {
	number r = 255;
	number g = 255;
	number b = 255;
	number a = 255;
};
#自定义属性的按钮,点击按钮弹出"添加自定义属性"窗口
struct AddAttribute
{
	string describe;
};
[Alias:"Color"]
struct UIBluePrintColor {
	number r = 255;
	number g = 255;
	number b = 255;
	number a = 255;
};

#################################################################
# math
struct Vector2 {
	number x;
	number y;
};

#取值范围
struct ValueRange {
	
	attrs_updater(function(self)
		if attr(self, nil, "Integer") == "true" then
			set_attr(self, "min", "Integer", "true")
			set_attr(self, "max", "Integer", "true")
		end
		local min = attr(self, nil, "Min")
		if min then
			set_attr(self, "min", "Min", min)
		end
		local max = attr(self, nil, "Max")
		if min then
			set_attr(self, "max", "Max", max)
		end
		set_attr(self, "max", "Min", tostring(self.min))
		set_attr(self, "min", "Max", tostring(self.max))
	end);
	[Update: "true"]
	number min;
	[Update: "true"]
	number max;
	
	monitor("min", function(self, path, val)
		set_attr(self, "max", "Min", tostring(self.min))
		return true
	end);
	monitor("max", function(self, path, val)
		set_attr(self, "min", "Max", tostring(self.max))
		return true
	end);
};

# XYZ三轴组件
struct Vector3 {
	[Min:"-5000", Max:"5000"]
	number x;
	[Min:"-5000", Max:"5000"]
	number y;
	[Min:"-5000", Max:"5000"]
	number z;
};

struct Vector3i {
	[Integer: "true", Min:"-5000", Max:"5000"]
	number x;

	[Integer: "true", Min:"-5000", Max:"5000"]
	number y;

	[Integer: "true", Min:"-5000", Max:"5000"]
	number z;
};

struct UIRotation {
	[Integer: "true", Update: "true", Min:"0", Max:"360"]
	number x;

	[Integer: "true", Update: "true", Min:"0", Max:"360"]
	number y;

	[Integer: "true", Update: "true", Min:"0", Max:"360"]
	number z;
};

struct Vector2i {
	[Integer: "true"]
	number x;

	[Integer: "true"]
	number y;
};

struct UDim{
	[Step: "0.01"]
	number Scale;
	number Offect;
};

struct UVector2 {
	[Alias:"MyUDim", Update: "true"]
	UDim UDim_X;
	[Alias:"MyUDim", Update: "true"]
	UDim UDim_Y;
};

struct UDim2 {
	[Alias:"MyUDim"]
	UDim UDim_X;
	[Alias:"MyUDim"]
	UDim UDim_Y;
};

struct Rect {
	[Integer: "true"]
	number left;

	[Integer: "true"]
	number top;

	[Integer: "true"]
	number width;

	[Integer: "true"]
	number height;
};

struct Box {
	attrs_updater(function(self)
		set_attr(self.min, "x", "Min", "0")
		set_attr(self.min, "y", "Min", "0")
		set_attr(self.min, "z", "Min", "0")
		
		set_attr(self.max, "x", "Min", "0")
		set_attr(self.max, "y", "Min", "0")
		set_attr(self.max, "z", "Min", "0")
		
		set_attr(self.min, "x", "Max", "1")
		set_attr(self.min, "y", "Max", "1")
		set_attr(self.min, "z", "Max", "1")
		
		set_attr(self.max, "x", "Max", "1")
		set_attr(self.max, "y", "Max", "1")
		set_attr(self.max, "z", "Max", "1")
	end);
	[Alias: "MyVector3"]
	Vector3 min = Vector3(x = 0, y = 0, z = 0);
	[Alias : "MyVector3"]
	Vector3 max = Vector3(x = 1, y = 1, z = 1);
};



struct Margin {
	Vector2 top = Vector2(x = 0, y = 0);
	Vector2 left = Vector2(x = 0, y = 0);
	Vector2 bottom = Vector2(x = 0, y = 0);
	Vector2 right = Vector2(x = 0, y = 0);
};
#################################################################

struct ScenePos {
	Vector3 pos;
};

struct MapPos {
	MapEntry map;
	Vector3 pos;
};

struct Region {
	Vector3i min;
	Vector3i max;
};

struct SceneRegion {
	MapEntry map;
	Region region;
};
#################################################################
## resource
[Filters:"*.png *.jpg"]
struct Resource_BlockTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
	end);
};

[Filters:"*.png *.jpg"]
struct Resource_EntityTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
	end);
};

[Filters:"*.png *.jpg *tga *.imageset"]
struct Resource_CEGUITexture{
	string selector;
	string asset;
	string type = "image";
	string imageset_key = "";

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
		return true
	end);
};

[Filters:"*.png *.jpg"]
struct Resource_SkillTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
	end);
};

[Filters:"*.png *.jpg *.tga"]
struct Resource_ItemTexture {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
	end);
};

[Filters:"*.layout"]
struct Resource_Layout {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector, self.asset)
	end);
};


enum Resource_ShopTexture_Selector{
	list(function()
		local Res = require "we.gamedata.res"
		return Res.list("texture/shop", "png")
	end);
};

[Filters:"*.png *.jpg"]
struct Resource_ShopTexture {
	Resource_ShopTexture_Selector selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

[Filters:"*.mp3"]
struct Resource_Sound {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

[Filters:"*.actor"]
struct Resource_Actor {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

[Filters:"*.effect"]
struct Resource_Effect {
	string selector;
	string asset;

	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

[Filters:"*.mesh"]
struct Resource_Mesh {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};


[Filters:"*.skin"]
struct Resource_Skin {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};

#动作 动画资源
[Filters:"*.anim"]
struct Resource_Anim {
	string selector;
	string asset;
	
	monitor("selector", function(self, path, oval)
		local Res = require "we.gamedata.res"
		self.asset = Res.import(self.selector)
	end);
};


struct CastSound {
	bool selfOnly;
	bool loop;
	Percentage volume=Percentage(value = 1);
	Resource_Sound sound;
};


struct EntityEffect{
	attrs_updater(function(self)
		set_attr(self.scale, "x", "Min", "0")
		set_attr(self.scale, "y", "Min", "0")
		set_attr(self.scale, "z", "Min", "0")
		
		set_attr(self.scale, "x", "Max", "10000")
		set_attr(self.scale, "y", "Max", "10000")
		set_attr(self.scale, "z", "Max", "10000")
	end);
	Resource_Effect effect;
	bool selfOnly;
	bool once = true;
	[Alias: "MyVector3"]
	Vector3 pos;
	number yaw;
	[Alias: "MyVector3"]
	Vector3 scale = Vector3(x = 1, y = 1, z = 1);
};

#################################################################
########################### BLOCK ###############################
#################################################################


# 包围盒纹理
struct Block_CubeTexture {
	Resource_BlockTexture up;
	Resource_BlockTexture down;
	Resource_BlockTexture front;
	Resource_BlockTexture back;
	Resource_BlockTexture left;
	Resource_BlockTexture right;
};

struct Block_DropSelf {
	bool canDropSelf = true;
	[Integer: "true", Min: "1"]
	number dropCount = 1;
};

struct Block_DropItem {
	ItemEntry item;
	[Integer: "true",Min: "1"]
	number count = 1;
};

struct BlockCfg {

	attrs_updater(function(self)
		local isQuad = self.isQuad and "false" or "true"
		set_attr(self, "textures", "Visible", isQuad)
		set_attr(self, "isOpaqueFullCube", "Visible", isQuad)
	end);

#################################################################
## 基础属性 BASE

	# 名字
	[TAB: "Block_Facade", EditorData: "true"]
	Text name;

	# 分类标签
	[EditorData: "true"]
	hide Tags tags = Tags(module = "block");

	# 碰撞体积
	[TAB: "Physics", RELOAD: "true"]
	Box collisionBoxes[] = {
		Box()
	};

	# 贴图
	[TAB: "Block_Facade", RELOAD: "true"]
	Block_CubeTexture textures;

	# 不透明度
	[TAB: "Block_Facade", RELOAD: "true"]
	bool isOpaqueFullCube = true;
	
	# 死亡后掉落
	[TAB: "Block_Facade", RELOAD: "true"]
	bool candrop;
	
	# 弹性
	[TAB: "Physics", Min: "0", Max: "20"]
	number spring;

	# 自动下落
	[TAB: "Physics"]
	bool fall = false;

	# 自动下降速度
	[TAB: "Physics", Min: "0"]
	number maxFallSpeed = 30;


#################################################################
# 交互相关

	# 可被点击
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.CLICK"]
	bool canClick = false;
	
	#点击切换别的方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.CLICK"]
	BlockEntry clickChangeBlock;

	# 可被破坏
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	bool canBreak = true;

	# 硬度
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Time breakTime = Time(value = 20);
	
	# 掉落自身
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Block_DropSelf dropSelf;

	# 掉落道具
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Block_DropItem dropItems[];
	
	# 破坏后重生
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	bool recycle = false;
	
	# 破坏后重生时间
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BREAK"]
	Time recycleTime = Time(value = 20);
	
	# 踩上方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry onBuff;

	# 进入方块
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry inBuff;
	
	# 跳跃buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry jumpBuff[];
	
	# 跑动buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry runBuff[];
	
	# 疾跑buff
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.BUFF"]
	BuffEntry sprintBuff[];

#################################################################
# 音效相关 SOUND

	# 放置音效
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.SOUND"]
	CastSound placeBlockSound;

	# 敲碎音效
	[TAB: "Interactive", GROUP: "BLOCK.GROUP.SOUND"]
	CastSound breakBlockSound;

#################################################################
# 攀爬相关 CLIMB

	# 攀爬速度
	[TAB: "Special", Min: "0"]
	number climbSpeed;

#################################################################
## 其它 OTHER

	# 可游泳
	[TAB: "Special"]
	bool canSwim = false;

	# 最大移动速度
	[TAB: "Special", Min: "0"]
	number maxSpeed = 10000;

	[TAB: "Trigger", TRIGGER: "BlockTriggers"]
	TriggerSet triggers;
	
	hide bool isQuad;
};

enum BlockEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("block")
		
		for key , item in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key,
--				attrs = {name = item:val().name.value}
			})
		end

		collectgarbage("collect")
		return ret
	end);
};

struct BlockArray {
	BlockEntry blockArray[];
};

struct BlockObj{
	attrs_updater(function(self)
		set_attr(self.pos, "x", "Enabled", "false")
		set_attr(self.pos, "y", "Enabled", "false")
		set_attr(self.pos, "z", "Enabled", "false")
	end);
	[Module: "block"]
	Entrance block;
	[Alias:"MyVector3"]
	Vector3i pos;
};

#################################################################
########################### Entity ##############################
#################################################################

[Nonempty : "true"]
enum BdVolumeType{
	"Box",
	"Sphere",
	"Capsule",
	"Cylinder",
};

struct BoundingVolumeMemory
{
	string Sphere;
	string Capsule;
	string Cylinder;
};

struct BoundingVolume{
	attrs_updater(function(self)
		set_attr(self, "params", "Visible", self.type == "Box" and "true" or "false")
		set_attr(self, "radius", "Visible", self.type ~= "Box" and "true" or "false")

		local height_visiabel = self.type == "Capsule" or self.type == "Cylinder"
		set_attr(self, "height", "Visible", height_visiabel and "true" or "false")
		set_attr(self.params, "x", "Min", "0.01")
		set_attr(self.params, "y", "Min", "0.01")
		set_attr(self.params, "z", "Min", "0.01")
	end);

	BdVolumeType type = "Box";
	monitor("type", function(self, path, oval)
		set_attr(self, "params", "Visible", self.type == "Box" and "true" or "false")
		set_attr(self, "radius", "Visible", self.type ~= "Box" and "true" or "false")
		local height_visiabel = self.type == "Capsule" or self.type == "Cylinder"
		set_attr(self, "height", "Visible", height_visiabel and "true" or "false")

		if self.memory[oval] then
			self.memory[oval] = string.format("%f-%f", self.height,self.radius)
		end
		
		if self.memory[self.type] and self.memory[self.type] ~= "" then
			local str = self.memory[self.type]
			local pos = string.find(str, "-")

			if pos then
				self.height = tonumber(string.sub(str, 1, pos - 1))
				self.radius = tonumber(string.sub(str, pos + 1, #str))
			end
		else
			self.height = 1.8
			self.radius = 0.45
		end
	end);

	[Alias: "MyVector3"]
	Vector3 params = Vector3(x = 0.6, y = 1.8, z = 0.6);
	[Max: "999", Min:"0.01"]
	number height = 1.8;
	[Max: "999", Min:"0.01"]
	number radius = 0.45;

	hide BoundingVolumeMemory memory;
};

[integer: "true"]
enum EquipSlot{
	"1",
	"2",
	"3",
	"4"
};

struct AI_Skill {
	[Min : "0"]
	number attackDis = 4;
	[Min : "0"]
	number priority;
	SkillEntry fullName;
};

#当AI走出领地
[Nonempty : "true"]
enum AI_OutOfHome {
	"birthplace",	#回到出生地
	"random"		#回到领地内随机位置
};

#AI领地相关
struct AI_Home {
	
	attrs_updater(function(self)
		set_attr(self, "homeSize", "Visible", self.enable and "true" or "false")
		set_attr(self, "outOfHome", "Visible", self.enable and "true" or "false")
	end);
	
	bool enable = true;
	[Min : "0"]
	number homeSize = 10;
	AI_OutOfHome outOfHome = "birthplace";
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "homeSize", "Visible", self.enable and "true" or "false")
		set_attr(self, "outOfHome", "Visible", self.enable and "true" or "false")
	end);

};

#AI攻击模式
[Nonempty : "true"]
enum AI_AttackMode {
	"hitBack",
	"autoAttack"
};

#AI攻击目标
[Nonempty : "true"]
enum AI_TargetType {
	"player",
	"any"
};

struct AI_Attack {
		
	attrs_updater(function(self)
		set_attr(self, "attackMode", "Visible", self.enable and "true" or "false")
		set_attr(self, "targetType", "Visible", self.enable and "true" or "false")
		set_attr(self, "chaseDistance", "Visible", self.enable and "true" or "false")
		set_attr(self, "maxVisualAngle", "Visible", self.enable and "true" or "false")
		set_attr(self, "skillList", "Visible", self.enable and "true" or "false")
	end);

	bool enable;
	AI_AttackMode attackMode = "hitBack";
	AI_TargetType targetType = "player";
	[Min : "0"]
	number chaseDistance = 10;
	[Min : "0", Max : "360", Integer : "true"]
	number maxVisualAngle = 360;
	AI_Skill skillList[];
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "attackMode", "Visible", self.enable and "true" or "false")
		set_attr(self, "targetType", "Visible", self.enable and "true" or "false")
		set_attr(self, "chaseDistance", "Visible", self.enable and "true" or "false")
		set_attr(self, "maxVisualAngle", "Visible", self.enable and "true" or "false")
		set_attr(self, "skillList", "Visible", self.enable and "true" or "false")
	end);
};

#AI巡逻方式
[Nonempty : "true"]
enum AI_PatrolMode {
	"no",
	"randomPath"
};

struct TimeRange {
	Time min;
	Time max;
};

#AI闲置
struct AI_Idle {
	Percentage prob;
	TimeRange idleTime = TimeRange(min = Time(value = 10), max = Time(value = 30));
};


#AI巡逻相关
struct AI_Patrol {
	attrs_updater(function(self)
		set_attr(self, "patrolDistance", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
		set_attr(self, "idle", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
	end);

	#巡逻方式
	AI_PatrolMode patrolMode = "no";
	#巡逻半径
	[Min : "0"]
	number patrolDistance = 5;
	AI_Idle idle;
	
	monitor("patrolMode", function(self, path, oval)
		set_attr(self, "patrolDistance", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
		set_attr(self, "idle", "Visible", 
			self.patrolMode == "randomPath" and "true" or "false")
	end);
};

#AI遇到悬崖
struct AI_FaceCliff {
	attrs_updater(function(self)
		set_attr(self, "height", "Visible", self.avoidCliff and "true" or "false")
	end);

	bool avoidCliff = true;
	#悬崖的高度
	[Min : "1"]
	number height = 5;
	
	monitor("avoidCliff", function(self, path, oval)
		set_attr(self, "height", "Visible", self.avoidCliff and "true" or "false")
	end);
};

#智能寻路
struct AiNavigation{
    #是否应该增加自定义的翻译?
	bool enable;
	monitor("enable", function(self, path, oval)
		if self.enable then
			local GameRequest = require "we.proto.request_game"
			local VN = require "we.gamedata.vnode"

			local choose = GameRequest.request_enable_ai_dialog()
			if not choose then
				VN.assign(self, "enable", false, 3)
			end
		end
	end);
};

#AI移动规则
struct AI_WalkingRules {
	AI_FaceCliff faceCliff;
	AiNavigation ai_navigation; 
};

struct ScriptItem {
	string path;
};

#死亡动画属性
struct DeadAction{
	string playDeadAction;
	Time deathHideTime = Time(value = 20);
};

[Nonempty : "true"]
enum ActorModelEnum{
	"System",
	"Customize"
};

struct ActorModel{
	attrs_updater(function(self)
		set_attr(self, "actorName", "Visible", self.modelType == "Customize" and "true" or "false")
		set_attr(self, "girlactor", "Visible", self.modelType == "Customize" and "true" or "false")
	end);
  
	ActorModelEnum modelType = "System";
	monitor("modelType", function(self, path, oval)
		set_attr(self, "actorName", "Visible", self.modelType == "Customize" and "true" or "false")
		set_attr(self, "girlactor", "Visible", self.modelType == "Customize" and "true" or "false")
	end);

	Resource_Actor actorName = Resource_Actor(
	asset = "asset/Actor/charactor/charactor_boy/character_boy.actor");

	Resource_Actor girlactor = Resource_Actor(
		asset = "asset/Actor/charactor/charactor_girl/character_girl.actor");
};

[Preview: "actorName"]
struct EntityCfg {
#################################################################
## 基础属性 BASE

	attrs_updater(function(self)
		set_attr(self, "AI_home", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_attack", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_patrol", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_walkRules", "Visible", self.enableAI and "true" or "false")
		
		local module = require "we.gamedata.module.module"
		local m = module:module("entity")
		
		local item = m:item("player1"):val()
		set_attr(self, "actorModel", "Visible", self.name.value == item.name.value  and "true" or "false")
		set_attr(self, "actorName", "Visible", self.name.value ~= item.name.value and "true" or "false")
		set_attr(self, "girlactor", "Visible", self.name.value ~= item.name.value and "true" or "false")
		
		local GameConfig = require "we.gameconfig"
		if GameConfig:disable_block() then
			set_attr(self, "canBoat", "Visible", "false")
			set_attr(self, "swimSpeed", "Visible", "false")
			set_attr(self, "waterLine", "Visible", "false")
		else
			set_attr(self, "checkPartTouchEvent", "Visible", "false")
		end
	end);

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	#头像
	[TAB: "Base", Resettable: "false"]
	Resource_EntityTexture headPic;

	# 分类标签
	hide Tags tags = Tags(module = "entity");

	hide bool isPlayer = false;
	
	#角色模型
	[TAB: "Base", RELOAD: "true"]
	ActorModel actorModel;
	
	#模型
	[TAB: "Base", RELOAD: "true"]
	Resource_Actor actorName = Resource_Actor(
		asset = "asset/Actor/charactor/charactor_boy/character_boy.actor");

	[TAB: "Base", RELOAD: "true"]
	Resource_Actor girlactor = Resource_Actor(
		asset = "asset/Actor/charactor/charactor_girl/character_girl.actor");

	#最大生命值
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY", Min: "1", Max: "10000000"]
	number maxHp = 20;
		
	#是否复活
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY"]
	bool canRevive;
	
	#复活时间
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY"]
	Time reviveTime;
	
	#单位死亡的动作
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY/DEATH", Expand: "false"]
	DeadAction deadAction;

	#死亡音效
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY/DEATH", Expand: "false", Resettable: "false"]
	CastSound deadSound;

	#死亡销毁延迟
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY"]
	Time destroyTime;

	#眼睛高度
	[TAB: "Base", GROUP: "ENTITY.GROUP.BIOLOGY", Min: "1", Max: "2"]
	number eyeHeight = 1.62;
	
	#可被点击
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK"]
	bool canClick;

	#被点选距离
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK", Min: "1"]
	number clickDistance = 4;
	
	#可点击距离
	[TAB: "Base", GROUP: "ENTITY.GROUP.CLICK", Min: "0", Max: "1000"]
	number reachDistance = 6.5;

	[TAB: "Base"]
	hide bool disableShadowAtFirstPRV = true;

	[TAB: "Base"]
	hide bool castRealShadowAtFirstPRV = false;

#################################################################
# 音效相关 SOUND
	


#################################################################
# 战斗 BATTLE

	#不可被攻击
	[TAB: "Battle"]
	bool unAssailable;
	
	#免疫攻击时间
	[TAB: "Battle"]
	Time hurtResistantTime = Time(value = 0);

	#不可被伤害
	[TAB: "Battle"]
	bool unDamageable;

	#攻击力
	[TAB: "Battle", GROUP: "ENTITY.GROUP.ATTACK", Min: "0"]
	number damage = 0;

#################################################################
# 移动 MOVE
	
	#可移动
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE"]
	bool canMove = true;

	#加速度
	hide number moveAcc = 0.2;

	#移动速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE", Min: "0"]
	number moveSpeed = 4;
	
	#抬脚高度
	[TAB: "Move", GROUP: "ENTITY.GROUP.MOVE", Min: "0"]
	number stepHeight = 0.6;

	#移动速度倍率
	hide number moveFactor = 1;

# 跳跃 JUMP

	#可跳跃
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP"]
	bool canJump = true;

	#离地速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP", Min: "0"]
	number jumpSpeed = 10;

	#跳起高度
	[TAB: "Move", GROUP: "ENTITY.GROUP.JUMP", Min: "0"]
	number jumpHeight = 0.6;

# 转身 Twist
	#锁定身体朝向
	[TAB: "Move", GROUP: "ENTITY.GROUP.Twist"]
	bool twist = false;

#################################################################
# 扣血 SUBHP

	#掉落阈值 掉落速度大于该值会有掉落伤害
	[TAB: "Move", GROUP: "ENTITY.GROUP.SUBHP", Min: "0", Max: "30", ShowSlider: "true"]
	number dropDamageStart = 30;
	
	# 落地扣血速率
	[TAB: "Move", GROUP: "ENTITY.GROUP.SUBHP", Min: "0"]
	number dropDamageRatio = 0;

# 漂浮 FLOAT

	#可漂浮
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT"]
	bool canBoat;

	#吃水线
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT", Min: "0"]
	number waterLine;
	
	#游泳速度
	[TAB: "Move", GROUP: "ENTITY.GROUP.FLOAT", Min: "0"]
	number swimSpeed = 4;

#################################################################
# 血条 LIFEBAR

	#隐藏血条
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",RELOAD: "true"]
	bool hideHp = true;

	#血条颜色
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",RELOAD: "true"]
	Color hpBarColor = Color(r = 255, g = 0, b = 0);

	#血条高度
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR", Min: "0",RELOAD: "true"]
	number hpBarHeight = 0.2;

	#血条宽度
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR", Min: "0",RELOAD: "true"]
	number hpBarWidth = 1;
	
	#隐藏名字
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",RELOAD: "true"]
	bool hideName;
	
	#名字高度
	[TAB: "Base", GROUP: "ENTITY.GROUP.LIFEBAR",Min: "0",RELOAD: "true"]
	number textHeight = 2.3;

#################################################################
# 技能 SKILL

	#技能
	[TAB: "Battle", GROUP: "ENTITY.GROUP.SKILL", Resettable: "false"]
	SkillEntry skill[];

#################################################################
# 物理 Physics

	#有碰撞体积
	[TAB: "Physics", GROUP: "ENTITY.GROUP.COLLISION", RELOAD: "true"]
	bool collision;

	#碰撞体积
	[TAB: "Physics", GROUP: "ENTITY.GROUP.COLLISION", RELOAD: "true", Resettable: "false"]
	BoundingVolume boundingVolume = BoundingVolume(
		params = Vector3(x = 0.6, y = 1.8,z = 0.6)
	);
	
	#触发碰撞零件事件
	[TAB: "Physics", GROUP: "ENTITY.GROUP.COLLISION"]
	bool checkPartTouchEvent = true;
	
	#重力
	[TAB: "Physics", Min: "0"]
	number gravity = 1.6;

	#受重力下落
	[TAB: "Physics"]
	bool autoMove;
	
#################################################################
# 装备 EQUIP

	#装备槽
	[TAB: "Battle", GROUP: "ENTITY.GROUP.EQUIP"]
	EquipSlot equip[];

#################################################################
# AI

	#开启AI
	[TAB: "AI"]
	bool enableAI;

	#领地
	[TAB: "AI"]
	AI_Home AI_home;

	#战斗
	[TAB: "AI"]
	AI_Attack AI_attack;

	#巡逻
	[TAB: "AI"]
	AI_Patrol AI_patrol;

	#移动
	[TAB: "AI"]
	AI_WalkingRules AI_walkRules;
	
	#脚本
	[TAB: "Trigger", GROUP: "ENTITY.GROUP.CODE",ReomoveWarning: "true"]
	ScriptItem _clientScript[];
	monitor("_clientScript", function(self, path, oval, op)
		if op == "INSERT" then
			self._clientScript[path[#path]].path="client/client_script"--..#self._clientScript
		end
	end);

	[TAB: "Trigger", GROUP: "ENTITY.GROUP.CODE",ReomoveWarning: "true"]
	ScriptItem _serverScript[] ;
	monitor("_serverScript", function(self, path, oval, op)
		if op == "INSERT" then
			self._serverScript[path[#path]].path="server/server_script"--..#self._serverScript
		end
	end);
	
	monitor("enableAI", function(self, path, oval)
		set_attr(self, "AI_home", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_attack", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_patrol", "Visible", self.enableAI and "true" or "false")
		set_attr(self, "AI_walkRules", "Visible", self.enableAI and "true" or "false")
	end);

#宠物跟随
	
	#有目标时跟随距离
	[TAB: "AI", GROUP: "ENTITY.GROUP.PET", Min: "1", Expand: "false"]
	number followEntityDistanceWhenHasTarget = 10;
	
	#无目标时跟随距离
	[TAB: "AI", GROUP: "ENTITY.GROUP.PET", Min: "1", Expand: "false"]
	number followEntityDistanceWhenNotTarget = 5;

#################################################################
# 其他 OTHER
	[TAB: "Trigger", GROUP: "ENTITY.GROUP.OTHER", TRIGGER: "EntityTriggers"]
	TriggerSet triggers;

};

enum EntityEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("entity")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};


#################################################################
########################### MISSILE #############################
#################################################################

#子弹碰撞方块
enum MissileCollideBlock {
	"0",	#无碰撞
	"1",	#碰撞消失
	"2",	#碰撞反弹
	"3",	#碰撞阻挡
	"4",	#命中方块
};

#子弹碰撞单位
enum MissileCollideEntity {
	"0",	#无碰撞
	"1",	#任何单位
	"2",	#仅目标单位
};

[Nonempty: "true"]
enum MissileModelType {
	list(function()
			local ret = {}
			table.insert(ret, {value = "empty"})
			table.insert(ret, {value = "mesh"})
			local GameConfig = require "we.gameconfig"
			if not GameConfig:disable_block() then
				table.insert(ret, {value = "block"})
			end
			return ret
		 end
		);
};

struct MissileModel {
	attrs_updater(function(self)
		set_attr(self, "modelMesh", "Visible", self.type == "mesh" and "true" or "false")
		set_attr(self, "modelBlock", "Visible", self.type == "block" and "true" or "false")
	end);

	MissileModelType type = "empty";
	Resource_Mesh modelMesh;
	BlockEntry modelBlock;
	
	monitor("type", function(self, path, oval)
		set_attr(self, "modelMesh", "Visible", self.type == "mesh" and "true" or "false")
		set_attr(self, "modelBlock", "Visible", self.type == "block" and "true" or "false")
	end);
};

struct MissileEffect {
	attrs_updater(function(self)
		set_attr(self.scale, "x", "Min", "0")
		set_attr(self.scale, "y", "Min", "0")
		set_attr(self.scale, "z", "Min", "0")
		
		set_attr(self.scale, "x", "Max", "10000")
		set_attr(self.scale, "y", "Max", "10000")
		set_attr(self.scale, "z", "Max", "10000")
	end);
	Resource_Effect effect;
	bool once;
	bool timeLimit;
	Time time;
	[Alias: "MyVector3"]
	Vector3 pos;
	number yaw;
	[Alias: "MyVector3"]
	Vector3 scale = Vector3(x = 1, y = 1, z = 1);
};

struct MissileHitCount {
	attrs_updater(function(self)
		local GameConfig = require "we.gameconfig"
		if GameConfig:disable_block() then
			set_attr(self, "hitBlockCount", "Visible", "false")
			set_attr(self, "hitCount", "Visible", "false")
		end
	end);
	
	#开启碰撞
	bool isValid;

	#最大碰撞次数
	[Min: "0", Integer : "true"]
	number hitCount;
	
	#最大碰撞单位次数
	[Min: "0", Integer : "true"]
	number hitEntityCount;
	
	#最大碰撞方块次数
	[Min: "0", Integer : "true"]
	number hitBlockCount;
};

[Nonempty : "true"]
enum TargetTeam{
	"hitAllTeam",
	"hitOtherTeam",
	"hitSelfTeam",
	"hitTargetTeam"
};

[Nonempty : "true"]
enum TargetType{
	"hitAllEntitys",
	"hitPlayer",
	"hitNpc",
};

[Nonempty : "true"]
enum TargetCfg{
	"hitAllConfigEntity",
	"hitTargetConfigEntity"
};

struct MissileCfg {
	attrs_updater(function(self)
		local GameConfig = require "we.gameconfig"
		if GameConfig:disable_block() then
			set_attr(self, "collideBlock", "Visible", "false")
			set_attr(self, "hitBlockSkill", "Visible", "false")
			set_attr(self, "hitBlockSound", "Visible", "false")
			set_attr(self, "hitBlockEffect", "Visible", "false")
		end
		set_attr(self, "teams", "Visible", self.target_team == "hitTargetTeam" and "true" or "false")
		set_attr(self, "entitys", "Visible", self.target_cfg == "hitTargetConfigEntity" and "true" or "false")
	end);
#################################################################
## 名称&模型 NAME&MODEL

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	
	#子弹外形
	[TAB: "Base"]
	MissileModel missileModel;
	
	#包围盒
	[TAB: "Base"]
	BoundingVolume boundingVolume = BoundingVolume(
		params = Vector3(x = 0.2, y = 0.2,z = 0.2)
	);
	
#################################################################
## 飞行状态 FLY
	
	#移动速度/最大速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number moveSpeed = 40;
	
	#加速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number moveAcc;
		
	#重力
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number gravity;
	
	#旋转速度
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	number rotateSpeed;
	
#################################################################
## 追踪目标 FOLLOW
	
	#追踪目标
	[TAB: "Base", GROUP: "MISSILE.GROUP.FLY"]
	bool followTarget;
	
#################################################################
## 生命周期 LIFECYCLE
	
	#存在时间
	[TAB: "Lifecycle"]
	Time lifeTime = Time(value = 100);
	
	#消亡时间
	[TAB: "Lifecycle"]
	Time vanishTime = Time(value = 10);
	
	#消亡显示
	[TAB: "Lifecycle"]
	bool vanishShow;
	
#################################################################
## 发射 SHOOT
		
	#发射时音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.SHOOT"]
	CastSound startSound;
	
	#发射时特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.SHOOT"]
	MissileEffect startEffect;
	
#################################################################
## 命中 HIT

	#碰撞次数
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT"]
	MissileHitCount hitCount;
	
	#目标队伍
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	TargetTeam target_team;
	monitor("target_team",function(self,path,oval)
		set_attr(self, "teams", "Visible", self.target_team == "hitTargetTeam" and "true" or "false")
	end);
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY", Integer: "true", Min:"1"]
	number teams[];
	monitor("teams",function(self,path,oval,op)
		if op == "INSERT" then
			local index = path[2]
			if index == 0 then
				return false
			end
			self.teams[index] = 1
		end
		return true
	end);
	#目标类型
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	TargetType target_type;
	
	#目标配置
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	TargetCfg target_cfg;
	monitor("target_cfg",function(self,path,oval)
		set_attr(self, "entitys", "Visible", self.target_cfg == "hitTargetConfigEntity" and "true" or "false")
	end);
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	EntityEntry entitys[];

	#命中单位间隔
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	Time hitInterval = Time(value = 10);
	
	#命中单位后技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	SkillEntry hitEntitySkill;
	
	#命中单位音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	CastSound hitEntitySound;
	
	#命中单位特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/ENTITY"]
	MissileEffect hitEntityEffect;
		
	#子弹碰到方块
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/BLOCK"]
	MissileCollideBlock collideBlock = "1";
	
	#命中方块后技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/BLOCK"]
	SkillEntry hitBlockSkill;
	
	#命中方块音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/BLOCK"]
	CastSound hitBlockSound;
	
	#命中方块特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/BLOCK"]
	MissileEffect hitBlockEffect;
	
	#反弹音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.HIT/BLOCK"]
	hide CastSound reboundBlockSound;
	

	
#################################################################
## 消失 VANISH

	#消失时技能
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	SkillEntry vanishSkill;
		
	#消失音效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	CastSound vanishSound;
	
	#消失时特效
	[TAB: "Lifecycle", GROUP: "MISSILE.GROUP.VANISH"]
	MissileEffect vanishEffect;

#################################################################
## 其他 OTHER
	
	[TAB: "Trigger", TRIGGER: "MissileTriggers"]
	TriggerSet triggers;

};

#################################################################
########################### Map #################################
#################################################################

#交互上使用，跳转到模板
struct Entrance{
	string cfg;
};

struct EntityObj{
	attrs_updater(function(self)
		set_attr(self.pos, "y", "Min", "0")
	end);

	[UUID: "true"]
	hide string id;
	hide string cfg;
	[Module: "entity"]
	Entrance entity;
	Vector3 pos;
	number ry;
};

struct RegionObj{
	[UUID: "true"]
	string id;
	Text name;
	RegionEntry cfg;
	Vector3i min;
	Vector3i max;
};

#地图迷雾
struct MapFog{
	bool hideFog = true;
	#可见范围
	[Min: "0"]
	number start = 10;
	#迷雾厚度
	[Min: "0"]
	number range = 5;
	#迷雾强度
	Percentage density = Percentage(value = 0.45);
	#迷雾颜色
	Color color = Color(r = 67, g = 207, b = 238);
};

# 天空盒切换模式
[Nonempty : "true"]
enum SkyBoxMode {
	"dynamic_switch",
	"static_display"
};

# 天空盒贴图
struct Map_SkyBoxTexture {
	Resource_ItemTexture front;
	Resource_ItemTexture back;
	Resource_ItemTexture left;
	Resource_ItemTexture right;
	Resource_ItemTexture top;
	Resource_ItemTexture bottom;
};


struct SkyBoxItemBase{

};

struct SkyBoxDynamicItem{
	# 天空盒切换时刻
	[Min: "0", Max: "24", ShowSlider: "true"]
	number time = 6;
	# 切换过渡时长
	[Integer: "false", Min: "0"]
	number transition = 0;
	# 天空盒贴图
	Map_SkyBoxTexture texture;
};

# 动态切换天空盒
struct SkyBoxDynamic : SkyBoxItemBase{
	SkyBoxDynamicItem items[];
};

# 静态天空盒
struct SkyBoxStatic : SkyBoxItemBase{
	Resource_ItemTexture front;
	Resource_ItemTexture back;
	Resource_ItemTexture left;
	Resource_ItemTexture right;
	Resource_ItemTexture top;
	Resource_ItemTexture bottom;
};


struct SkyBoxItem{
	SkyBoxMode type = "static_display";
	SkyBoxItemBase base = SkyBoxStatic(
		front = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_front.png"),
		back = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_back.png"),
		left = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_left.png"),
		right = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_right.png"),
		top = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_top.png"),
		bottom = Resource_ItemTexture(asset = "asset/Texture/SkyBox/Common2/Sky03_bottom.png")
	);

	monitor("type",function(self,path,oval)
		if self.type == "dynamic_switch" then
			self.base = ctor("SkyBoxDynamic")
		elseif self.type == "static_display" then
			self.base = ctor("SkyBoxStatic", {
				front = {asset = "asset/Texture/SkyBox/Common2/Sky03_front.png"},
				back = {asset = "asset/Texture/SkyBox/Common2/Sky03_back.png"},
				left = {asset = "asset/Texture/SkyBox/Common2/Sky03_left.png"},
				right = {asset = "asset/Texture/SkyBox/Common2/Sky03_right.png"},
				top = {asset = "asset/Texture/SkyBox/Common2/Sky03_top.png"},
				bottom = {asset = "asset/Texture/SkyBox/Common2/Sky03_bottom.png"}
			})
			--[[
			self.base.front.asset = "asset/Texture/SkyBox/SkyBox_front.png"
			self.base.back.asset = "asset/Texture/SkyBox/SkyBox_back.png"
			self.base.left.asset = "asset/Texture/SkyBox/SkyBox_left.png"
			self.base.right.asset = "asset/Texture/SkyBox/SkyBox_right.png"
			self.base.top.asset = "asset/Texture/SkyBox/SkyBox_top.png"
			self.base.bottom.asset = "asset/Texture/SkyBox/SkyBox_bottom.png"
			--]]
		end
	end);
};

struct TouchPos{
	[Min: "-1024", Max:"1024"]
	number down = -30.00;
	[Min: "-1024", Max:"1024"]
	number up =720.00;
};

[UndoStack: "fork"]
struct MapCfg {
	attrs_updater(function(self)
		local GameConfig = require "we.gameconfig"
		local disable_block = GameConfig:disable_block()
		if disable_block then
			set_attr(self, "canBreak", "Visible", "false")
			set_attr(self, "fog", "Visible", "false")
			set_attr(self, "fog", "Visible", "false")
		end
		if not disable_block then
			set_attr(self, "touch_pos", "Visible", "false")
		end
	end);

	# 名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	[TAB: "Base", RELOAD: "true"]
	bool canBreak = true;

	[TAB: "Base", Store: "0", Enabled: "false", Visible: "false"]
	string mapId;

	# 地图迷雾
	[TAB: "Base", RELOAD: "true"]
	MapFog fog;

	# 虚空配置
	[TAB: "Base", RELOAD: "true"]
	TouchPos touch_pos;

	hide EntityObj entitys[];
	hide RegionObj regions[];

	hide Instance instances[];
	# 天空盒贴图(动态/静态)
	[TAB: "SkyBox", EditorData: "false", RELOAD: "true"]
	SkyBoxItem box;

	# 天空盒旋转速度
	[TAB: "SkyBox", RELOAD: "true"]
	number rotateSpeed = 0;
};

enum MapEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("map")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = key
			})
		end

		return ret
	end);
};

#################################################################
############################# Actor #############################
#################################################################

#高光
struct HightLight{
	#高光颜色
	Color light_color ;
	#高光系数 0~1
	[Min: "0.01"]
	Percentage light_ratio = Percentage(value = 0.15); 
	#高光强度 0~100 todo
	hide Percentage brightness = Percentage(value = 1.0);
};


#反射
struct ReflexLight{
	
	attrs_updater(function(self)
		set_attr(self, "reflect_scale", "Visible", self.enable and "true" or "false")
		set_attr(self, "reflect_texture", "Visible", self.enable and "true" or "false")
		set_attr(self, "reflect_mask_texture", "Visible", self.enable and "true" or "false")
	end);
	
	#是否启用
	bool enable = false;
	
	#系数
	[Min: "0.01"]
	Percentage reflect_scale = Percentage(value = 1);
	#反射贴图
	Resource_EntityTexture reflect_texture;
	#反射这招贴图
	Resource_EntityTexture reflect_mask_texture;
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "reflect_scale", "Visible", self.enable and "true" or "false")
		set_attr(self, "reflect_texture", "Visible", self.enable and "true" or "false")
		set_attr(self, "reflect_mask_texture", "Visible", self.enable and "true" or "false")
	end);
};

#边缘光
struct EdgeLight{
	attrs_updater(function(self)
		set_attr(self, "light_color", "Visible", self.enable and "true" or "false")
	end);
	#是否启用
	bool enable = false;
	#系数
	Color light_color = Color(r = 255, g = 0, b = 0);
	monitor("enable", function(self, path, oval)
		set_attr(self, "light_color", "Visible", self.enable and "true" or "false")
	end);
};


#是否启用 循环播放 次数  动作 及 动作的特效 都用到 
struct LoopPlaySet {
	attrs_updater(function(self)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
	end);
	#是否启用
	bool enable = false;
	#次数只能是 大于零的整数
	[Min: "0"]
	number play_times = 1;
	monitor("enable", function(self, path, oval)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
		if self.enable then
			self.play_times = -1
		else
			self.play_times = 1
		end
	end);
};


#动作作用通道模式 全身 上半身 下半身
[Nonempty : "true"]
enum ChannelMode {
	"all",
	"upper",
	"lower"
};

#是否启用 自定义时长 动作配置 特效
struct CustomTimeSet{
	attrs_updater(function(self)
		set_attr(self, "play_times", "Visible", self.enable and "true" or "false")
	end);
	#是否启用
	bool enable = false;
	#系数
	[Min: "0"]
	number play_times = 1;
	monitor("enable", function(self, path, oval)
		set_attr(self, "play_times", "Visible", self.enable and "true" or "false")
		if self.enable then
			self.play_times = 1
		else
			self.play_times = -1
		end
	end);
};

#覆盖颜色模式
[Nonempty : "true"]
enum OverlayColorMode {
	"no",
	"overlay",
	"replace"
};

#材质 
struct Material{
	attrs_updater(function(self)
		set_attr(self, "overlayColor", "Visible", self.overlayMode ~= "no" and "true" or "false")
	end);

	#透明度 0~1
	Percentage alpha= Percentage(value = 1);
	#透明遮罩 0~1
	Percentage discard_alpha= Percentage(value = 0);
	#亮度 0~100 todo
	Percentage brightness = Percentage(value = 1.0);  
	#辉光
	bool glow_enable = false;
	#光照
	hide bool linght_enable = false;
	
	#覆盖颜色模式
	OverlayColorMode overlayMode;
	#覆盖颜色
	Color overlayColor;
	
	monitor("overlayMode", function(self, path, oval)
		set_attr(self, "overlayColor", "Visible", self.overlayMode ~= "no" and "true" or "false")
	end);
	
	#高光 TODO 演示版本 临时隐藏 因为旧版也没找到作用回头查 
	HightLight hight_light;
	#反射
	ReflexLight reflex_light;
	#边缘光
	EdgeLight edge_light;
};

#变换 
struct ActorEditorTransform{
	attrs_updater(function(self)
		set_attr(self.pos, "x", "Step", "0.01")
		set_attr(self.pos, "y", "Step", "0.01")
		set_attr(self.pos, "z", "Step", "0.01")
		
		set_attr(self.pos, "x", "Update", "true")
		set_attr(self.pos, "y", "Update", "true")
		set_attr(self.pos, "z", "Update", "true")
		
		set_attr(self.rotate, "x", "Update", "true")
		set_attr(self.rotate, "y", "Update", "true")
		set_attr(self.rotate, "z", "Update", "true")
	end);
	[Alias : "MyVector3"]
	Vector3 pos = Vector3(x = 0, y = 0, z = 0);
	[Alias: "MyVector3"]
	Vector3 rotate = Vector3(x = 0, y = 0, z = 0);
	#比例
	[Min: "0", Max: "10000"]
	number scale = 1;
};

#ActorEditor ID
struct WithID {
	#ID
	[UndoStack: "barrier",Store: "0"]
	hide number id = 0;
};

#ActorEditor skin
struct ActorEditorSkin : WithID {
	#名字
	[RenameJudgment : "true"]
	string name= "skin_name";
	
	#类型
	[Enabled: "false"]
	string type= "skin";
	
	#资源文件	
	#Resource_EntityTexture headPic1;
	Resource_Skin res_file;
	#string res_file= "skin_res_name";
	
	#材质
	Material material;
};

[Nonempty : "true", EnumText : "Name"]
enum ActorBindPart {
	list(function()
		local actor_main = require "we.sub_editors.actor_main"
		local cjson = require "cjson"
		local str = actor_main:getActor():GetBoneList()
		local tb = cjson.decode(str).bones
		local ret = {}
		table.insert(ret,{value = "Origin197011", attrs = {name = "Origin197011"}})--意思是防止有和骨骼重名的
		for _, v in ipairs(tb) do
			table.insert(ret, {
				value = v
			})
		end
		return ret
	end);
};

# Editor mesh
struct ActorEditorMesh : WithID {
	#名字
	[RenameJudgment : "true"]
	string name = "mesh_name";
	
	#类型
	[Enabled: "false"]
	string type= "mesh";
	
	#变换 
	ActorEditorTransform transform;
	
	#资源文件	
	#Resource_EntityTexture headPic1;
	Resource_Mesh res_file;

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	
	#材质
	Material material;
};

#ActorEditor Effect 外观特效
struct ActorEditorEffect : WithID {
	#名字
	[RenameJudgment : "true"]
	string name ="effect_name";
	
	#类型
	[Enabled: "false"]
	string type= "effect";
	
	#变换 
	ActorEditorTransform transform;
	
	#资源文件
	#Resource_EntityTexture headPic1;
	Resource_Effect res_file;

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	
	#透明度 0~100 TODO ctor 的特效部件，透明度属性没有效果（先屏蔽掉这个属性）。
	hide Percentage alpha= Percentage(value = 1);
	
	#播放速度
	[Min: "0", Max: "10000"]
	number play_speed = 1;
};

enum BodyPartMasterName{
	"body",
	"feet",
	"hand",
	"face",
	"clothes",
	"hair",
	"weapon",
	"shoulder"
};

#部件
struct ActorEditorBodyPart : WithID {
	[Actor_Facade_Name: "true", RenameJudgment: "true"]
	string slave_name ="slave_name";
	[Editable : "true", EnumText : "Value", RenameJudgment : "true"]
	BodyPartMasterName master_name = "mutex_name";
	
	hide bool default_use_enable = true;
	
	#对应原文件的索引
	hide number index = -1;
	
	#Skin 属性
	hide ActorEditorSkin skin[];
	
	#mesh 属性
	hide ActorEditorMesh mesh[];
	
	#effect 属性
	hide ActorEditorEffect effect[];
};

#外观
[UndoStack: "fork"]
struct ActorFace {
	ActorEditorBodyPart body_parts[];
};

#Skill 技能

struct ActorEditorSkill{
	#名字
	[Actor_Action_Name: "true", RenameJudgment : "true"]
	string name ="skill_name";
	#类型 只读
	[Enabled: "false"]
	string type = "action";
	
	##动作编辑 动画属性
	hide ActionEditorAnimation action_editor_animation;
	
		##动作编辑 特效属性
	hide ActionEditorEffect action_editor_effect[];
	
	##动作编辑 音效属性 ToDo 引擎目前不支持
	#[TAB: "TAB.PROP", GROUP: "ACTORACTION.GROUP.SOUND"]
	#ActionEditorSound action_editor_sound[];
};

#动作编辑 动画属性
struct ActionEditorAnimation{
	#名字
	hide string name = "action_ani_name";
	#类型 只读
	[Enabled: "false"]
	string type = "animation"; 
	
	#资源文件
	[NotClearable: "true"]
	Resource_Anim res_file;
	
	#开始时间 
	[Min: "0", Enabled: "false"]
	number start_time;
	
	#持续时间
	#类型 只读
	[Enabled: "false"]
	number length = 1;
	
	#作用通道
	ChannelMode channel_mode;
	
	#播放设置
	#循环播放
	#bool enable = false;
	#播放次数
	#number play_times;
	#循环播放  播放次数
	#[TAB: "TAB.PROP", GROUP: "SKILL.GROUP.PLAYSET"] 说不定那天产品又要回来设置 播放循环
	 LoopPlaySet  loop_play_set;
	
	#播放速度
	[Min: "0.01"] #TODO 最小值限制
	number play_speed = 1;
	
	#过渡时间 0~100
	[Min: "0"] 	#TODO 最小值限制
	number transition_time = 0.25;
};

#动作编辑 特效属性
struct ActionEditorEffect{
	#名字 暂时没用了
	hide string name = "action_effect_name";
	#类型 只读
	[Enabled: "false"]
	string type = "action_effect";
	
	#资源文件	
	Resource_Effect res_file;
	monitor("res_file", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("res_file")
    end);
	
	#变换 
	ActorEditorTransform transform;
	monitor("transform", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	

	#绑定位置
	#Resource_EntityTexture headPic2;
	ActorBindPart bind_part;
	monitor("bind_part", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	
	#跟随绑定位置  原“是否跟随Actor”
	bool follow_bind_part = true;
	monitor("follow_bind_part", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	
	#透明度
	hide Percentage alpha = Percentage(value = 1);
	
	
	#播放设置
	#循环播放
	#bool enable = false;
	monitor("enable", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	
	#播放次数
	#number play_times;
	monitor("play_times", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	
	#循环播放  播放次数
	LoopPlaySet  loop_play_set; 
	monitor("loop_play_set", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
		
	#开始时间
	[Min: "0", Enabled: "true"]
	number start_time = 0.0;
	monitor("start_time", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
	
	[Enabled: "false",Infty :"true"]
	 number length = 1;
	monitor("length", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
		
	#播放速度
	[Min: "0"]
	number play_speed = 1;
	monitor("play_speed", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
		
	#自定义播放时长
	CustomTimeSet custom_time_set;
	monitor("custom_time_set", function(self, path, oval)
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_effect_refresh("")
    end);
};

#动作编辑 音效属性
struct ActionEditorSound{
	#效果类型
	string name ="sound_name";
	#音效资源
	string res_name = "sound_res_sound";
	
	#播放设置
	#音量
	Percentage volume = Percentage(value = 1);
	#开始时间
	[Min: "0"]
	number start_time = 0.0;
	#持续时间
	[Min: "0"]
	number doing_time = 0.14;
	#循环播放
	bool loop_enable = false;
	#播放概率
	[Min: "0"]
	number play_probability;
	#是否广播
	bool broadcast_enable = false;

    #广播音量
	Percentage broadcast_volume = Percentage(value = 1);
};


#动作
[UndoStack: "fork"]
struct ActorAction{
	#Skill 属性
	ActorEditorSkill skill[];
	
	#动画资源列表 ToDo 没相关控件
	string ani_list[];
};

#actor 编辑器
struct ActorEditorCfg{

	attrs_updater(function(self)
		set_attr(self.position, "x", "Update", "true")
		set_attr(self.position, "y", "Update", "true")
		set_attr(self.position, "z", "Update", "true")
		
		set_attr(self.rotation, "x", "Update", "true")
		set_attr(self.rotation, "y", "Update", "true")
		set_attr(self.rotation, "z", "Update", "true")
		
		set_attr(self.scale, "x", "Update", "true")
		set_attr(self.scale, "y", "Update", "true")
		set_attr(self.scale, "z", "Update", "true")
		
		set_attr(self.alpha, "value", "Update", "true")
	end);

	#actor名字(显示用)
	[Enabled: "false"]
	string name;
	
	#骨架文件
	[Enabled: "false"]
	string res_skeleton = "boy.skel"; 
	
	#坐标
	[Alias: "MyVector3",Store: "0", Resettable: "false"]
	Vector3 position;
	
	#旋转
	[Alias: "MyVector3",Store: "0"]
	Vector3 rotation;
	
	#缩放
	[Min: "0", Max: "10000", Alias:"MyVector3"]
	Vector3 scale = Vector3(x = 1, y = 1, z = 1);
	
	#透明度
	Percentage alpha = Percentage(value = 1);

	#外观配置
	hide ActorFace actor_face;
	
	#动作配置
	hide ActorAction actor_action;
};

#################################################################
############################ Effect #############################
#################################################################

# 特效
[UndoStack: "fork"]
struct EffectCfg {
	# 预设列表
	EffectPreset presets[];
};

# 变换（位置、旋转）
struct Transform2 {
	attrs_updater(function(self)
		set_attr(self.pos, "x", "Step", "0.01")
		set_attr(self.pos, "y", "Step", "0.01")
		set_attr(self.pos, "z", "Step", "0.01")
		
		set_attr(self.pos, "x", "Update", "true")
		set_attr(self.pos, "y", "Update", "true")
		set_attr(self.pos, "z", "Update", "true")
		
		set_attr(self.rotate, "x", "Update", "true")
		set_attr(self.rotate, "y", "Update", "true")
		set_attr(self.rotate, "z", "Update", "true")
	end);
	[Alias: "MyVector3", Resettable: "false"]
	Vector3 pos = Vector3(x = 0, y = 0, z = 0);
	[Alias: "MyVector3"]
	Vector3 rotate = Vector3(x = 0, y = 0, z = 0);
};

struct EffectLoop {
	attrs_updater(function(self)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
	end);
	# 是否启用
	bool enable = false;
	# 循环次数
	[Integer: "true", Min: "1"]
	number play_times = 1;
	# 循环间隔
	[Min: "0"]
	number interval = 0.0;
	# 循环重置
	bool reset = false;
	# 帧长度
	hide number length;
	monitor("enable", function(self, path, oval)
		set_attr(self, "play_times", "Visible", self.enable and "false" or "true")
	end);
};

# 预设
struct EffectPreset {
	hide number id = 0;
	# 名字
	[LimitLength:"60", Resettable: "false"]
	string name;
};

# 爆炸预设
struct EffectPresetExplosion : EffectPreset {
	attrs_updater(function(self)
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
	end);
	# 变换
	Transform2 transform;
	# 內焰颜色
	[GROUP: "EFFECT.EXPLOSION"]
	Color inner_color[3];
	# 外焰颜色
	[GROUP: "EFFECT.EXPLOSION"]
	Color outer_color[3];
	# 强度
	[GROUP: "EFFECT.EXPLOSION", ShowSlider: "true", Min: "0.01", Max: "1"]
	number intensity;
	# 范围
	[GROUP: "EFFECT.EXPLOSION", ShowSlider: "true", Min: "0.01", Max: "100"]
	number range;
	# 是否可见
	[GROUP: "EFFECT.EXPLOSION"]
	bool visible = true;
	# 循环
	EffectLoop loop;
};

# 火焰预设
struct EffectPresetFire : EffectPreset {
	attrs_updater(function(self)
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
	end);
	# 变换
	Transform2 transform;
	# 內焰颜色
	[GROUP: "EFFECT.FIRE"]
	Color inner_color[4];
	# 外焰颜色
	[GROUP: "EFFECT.FIRE"]
	Color outer_color[4];
	# 热度
	[GROUP: "EFFECT.FIRE", ShowSlider: "true", Min: "2", Max: "50"]
	number intensity;
	# 大小
	[GROUP: "EFFECT.FIRE", ShowSlider: "true", Min: "0.2", Max: "1", Step: "0.1"]
	number range;
	# 是否可见
	[GROUP: "EFFECT.FIRE"]
	bool visible = true;
	# 循环
	EffectLoop loop;
};

# 烟雾预设
struct EffectPresetSmoke : EffectPreset {
	attrs_updater(function(self)
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
	end);
	# 变换
	Transform2 transform;
	# 颜色
	[GROUP: "EFFECT.SMOKE"]
	Color color;
	# 上升速度
	[GROUP: "EFFECT.SMOKE", ShowSlider: "true", Step: "0.1", Min: "0.01", Max: "5"]
	number speed;
	# 大小
	[GROUP: "EFFECT.SMOKE", ShowSlider: "true", Step: "0.1", Min: "0.1", Max: "20"]
	number range;
	# 不透明度
	[GROUP: "EFFECT.SMOKE", ShowSlider: "true", Step: "0.1", Min: "0.01", Max: "1"]
	number alpha;
	# 是否可见
	[GROUP: "EFFECT.SMOKE"]
	bool visible = true;
	# 循环
	EffectLoop loop;
};

# 火花预设
struct EffectPresetSparks : EffectPreset {
	attrs_updater(function(self)
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
	end);
	# 变换
	Transform2 transform;
	# 颜色
	[GROUP: "EFFECT.SPARKS"]
	Color color;
	# 大小
	[GROUP: "EFFECT.SPARKS", ShowSlider: "true", Min: "0.5", Max: "30"]
	number size;
	# 强度
	[GROUP: "EFFECT.SPARKS", ShowSlider: "true", Min: "5", Max: "500"]
	number intensity;
	# 是否可见
	[GROUP: "EFFECT.SPARKS"]
	bool visible = true;
	# 循环
	EffectLoop loop;
};

# 天气类型
[Nonempty : "true"]
enum WeatherType {
	"Snow",
	"Rain"
};

# 天气（雪）预设
struct EffectPresetSnow {
	# 大小
	[ShowSlider: "true", Step: "0.1", Min: "0.5", Max: "5"]
	number size;
	# 强度
	[ShowSlider: "true", Min: "5", Max: "100"]
	number intensity;
	# 速度
	[ShowSlider: "true", Step: "0.1", Min: "-10", Max: "10"]
	number speed;
	# 范围
	[ShowSlider: "true", Step: "0.1", Min: "0.1", Max: "20"]
	number range;
	# 是否可见
	bool visible = true;
};

# 天气（雨）预设
struct EffectPresetRain {
	# 大小
	[ShowSlider: "true", Step: "0.1", Min: "0.5", Max: "5"]
	number size;
	# 强度
	[ShowSlider: "true", Min: "5", Max: "200"]
	number intensity;
	# 速度
	[ShowSlider: "true", Step: "0.1", Min: "-10", Max: "10"]
	number speed;
	# 范围
	[ShowSlider: "true", Step: "0.1", Min: "0.1", Max: "20"]
	number range;
	# 是否可见
	bool visible = true;
};

# 天气预设
struct EffectPresetWeather : EffectPreset {
	# 类型初始处理
	attrs_updater(function(self)
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
		set_attr(self, "snow", "Visible", self.weather_type == "Snow" and "true" or "false")
		set_attr(self, "rain", "Visible", self.weather_type == "Rain" and "true" or "false")
	end);
	# 天气类型
	WeatherType weather_type = "Snow";
	# 变换
	Transform2 transform;
	# 雪预设
	EffectPresetSnow snow;
	# 雨预设
	EffectPresetRain rain;
	# 循环
	EffectLoop loop;
	# 类型切换处理
	monitor("weather_type", function(self, path, oval)
		set_attr(self, "snow", "Visible", self.weather_type == "Snow" and "true" or "false")
		set_attr(self, "rain", "Visible", self.weather_type == "Rain" and "true" or "false")
	end);
};

# 发射器类型
[Nonempty : "true"]
enum EmitterType {
	"Point",
	"Box",
	"Sphere",
	"Cylinder"
};

# 粒子发射器
struct ParticleEmitter {
	# 类型初始处理
	attrs_updater(function(self)
		set_attr(self, "quota", "Visible", self.unlimited and "false" or "true")
	end);
	# 范围
	[Alias: "MyVector3"]
	Vector3 area;
	# 仅表面发射
	bool surface_only;
	# 是否无限粒子
	bool unlimited = true;
	# 粒子数量
	[Integer: "true", Min: "1"]
	number quota;
	# 发射率
	[Integer: "true", Min: "1", Max: "500"]
	number rate;
	# 发射角度
	number angle;
	# 是否可见
	bool visible = true;
	# 类型切换处理
	monitor("unlimited", function(self, path, oval)
		set_attr(self, "quota", "Visible", self.unlimited and "false" or "true")
	end);
};

# 颜色混合模式
[Nonempty : "true"]
enum BlendMode {
	"alpha_lighting",
	"high_lighting"
	#"distortion"
};

# 粒子材质
struct ParticleMaterial {
	# 贴图
	Resource_ItemTexture res_file;
	# 颜色混合模式
	BlendMode blend_mode;
	# 不透明度
	[ShowSlider: "true", Step: "0.1", Min: "0", Max: "1"]
	number alpha;
	# 辉光
	bool bloom;
};

# 颜色模式
[Nonempty : "true"]
enum ColorMode {
	"single",
	"gradient"
};

# UV翻转模式
[Nonempty : "true"]
enum UVFlipMode {
	"flip_none",
	"flip_u",
	"flip_v",
	"flip_both"
};

# 扰动贴图
struct NoiseMaterial {
	# 开启扰动
	bool enable;
	# 扰动贴图
	Resource_ItemTexture res_file;
	# Alpha阈值
	number threshold;
	# U偏移
	number u_offset;
	# V偏移
	number v_offset;
	# U缩放
	number u_scale;
	# V缩放
	number v_scale;
	# 时间权重
	number time_factor;
	# 只显示扰动层
	bool texture_only;
};

# 粒子系统预设
struct EffectPresetParticle : EffectPreset {
	attrs_updater(function(self)
		set_attr(self.emitter, "area", "Visible", self.emitter_type ~= "Point" and "true" or "false")
		set_attr(self.emitter, "surface_only", "Visible", self.emitter_type ~= "Point" and "true" or "false")
		set_attr(self, "loop", "Visible", self.loop.length > 0 and "true" or "false")
		set_attr(self, "color_2", "Visible", self.color_mode == "gradient" and "true" or "false")
	end);
	# 发射器类型
	EmitterType emitter_type = "Point";
	# 变换
	[Expand: "false"]
	Transform2 transform;
	# 发射器
	[Expand: "false"]
	ParticleEmitter emitter;
	# 粒子材质
	[Expand: "false"]
	ParticleMaterial material;
	# 大小
	## 粒子宽度
	[GROUP: "EFFECT.PARTICLE.SIZE", Expand: "false"]
	number width;
	## 粒子高度
	[GROUP: "EFFECT.PARTICLE.SIZE"]
	number height;
	## 比例范围
	[GROUP: "EFFECT.PARTICLE.SIZE"]
	ValueRange scale;
	# 颜色
	## 颜色模式
	[GROUP: "EFFECT.PARTICLE.COLOR", Expand: "false"]
	ColorMode color_mode;
	## 颜色范围
	[GROUP: "EFFECT.PARTICLE.COLOR"]
	Color color_1;
	[GROUP: "EFFECT.PARTICLE.COLOR"]
	Color color_2;
	# 速度
	## 速度范围
	[GROUP: "EFFECT.PARTICLE.SPEED", Expand: "false"]
	ValueRange speed;
	[GROUP: "EFFECT.PARTICLE.SPEED"]
	number acceleration;
	# 旋转
	## 角度范围
	[GROUP: "EFFECT.PARTICLE.ROTATE", Expand: "false", Min: "-359", Max: "359"]
	ValueRange angle;
	# 生命值
	## 生命值范围
	[GROUP: "EFFECT.PARTICLE.LIFE", Expand: "false", Min: "1", Max: "10000"]
	ValueRange life;
	# 循环
	[Expand: "false"]
	EffectLoop loop;
	# UV贴图
	## UV翻转
	[GROUP: "EFFECT.PARTICLE.UV", Expand: "false"]
	UVFlipMode uv_flip_mode;
	## UV互换
	[GROUP: "EFFECT.PARTICLE.UV"]
	bool uv_swap;
	## U动画速度
	[GROUP: "EFFECT.PARTICLE.UV"]
	number u_speed;
	## V动画速度
	[GROUP: "EFFECT.PARTICLE.UV"]
	number v_speed;
	# 3D粒子
	## 3D粒子
	[GROUP: "EFFECT.PARTICLE.3D", Expand: "false"]
	bool b3d_particle;
	## 视角偏移
	[GROUP: "EFFECT.PARTICLE.3D"]
	bool b3d_trans;
	# 扰动
	[Expand: "false"]
	hide NoiseMaterial noise;
	# 类型切换处理
	monitor("emitter_type", function(self, path, oval)
		set_attr(self.emitter, "area", "Visible", self.emitter_type ~= "Point" and "true" or "false")
		set_attr(self.emitter, "surface_only", "Visible", self.emitter_type ~= "Point" and "true" or "false")
	end);
	monitor("color_mode", function(self, path, oval)
		set_attr(self, "color_2", "Visible", self.color_mode == "gradient" and "true" or "false")
		if self.color_mode == "single" then
			self.color_2.r = self.color_1.r
			self.color_2.g = self.color_1.g
			self.color_2.b = self.color_1.b
		end
	end);
	monitor("color_1", function(self, path, oval)
		if self.color_mode == "single" then
			self.color_2.r = self.color_1.r
			self.color_2.g = self.color_1.g
			self.color_2.b = self.color_1.b
		end
	end);
};

# 普通（未知）预设
struct EffectPresetNormal : EffectPreset {
	# 是否可见
	bool visible = true;
	# 变换
	Transform2 transform;
	# 循环
	EffectLoop loop;
};

#################################################################
########################### Item ################################
#################################################################

# 道具类型
[Nonempty : "true"]
enum ItemType{
	"Equip",
	"InHand",
	"Use"
};

[Nonempty : "true", EnumText : "Value", Editable: "true"]
enum BoyBindPart {
	"bip01",
	"b_pelvis",
	"b_spine",
	"b_l_thigh",
	"b_l_calf",
	"b_l_foot",
	"b_r_thigh",
	"b_r_calf",
	"b_r_foot",
	"b_neck",
	"b_l_clavicle",
	"b_l_upperarm",
	"b_l_forearm",
	"b_r_clavicle",
	"b_r_upperarm",
	"b_r_forearm",
	"b_head",
	"b_l_wingbone01",
	"b_l_wingbone02",
	"b_l_wingbone03",
	"b_cloakbone01",
	"b_cloakbone02",
	"b_cloakbone03",
	"b_r_wingbone01",
	"b_r_wingbone02",
	"b_r_wingbone03",
	"b_tailbone01",
	"b_tailbone02",
	"b_tailbone03",
	"s_foot_l",
	"s_foot_r",
	"s_hand_l",
	"s_hand_r",
	"s_head",
	"s_back"
};

struct ItemBase{

};

# 装备道具
struct ItemEquip : ItemBase{
	EquipSlot tray;
	[RenameJudgment : "true"]
	string itemGuise;
	[RenameJudgment : "true"]
	string itemPosition;
	SkillEntry equip_skill[];
	BuffEntry equip_buff;
};

# 手持道具
struct ItemInHand : ItemBase{
	bool isCoin;
	[Nonempty : "true", EnumText : "Value", Editable: "true"]
	BoyBindPart handItemBoneName = "s_hand_r";
	SkillEntry skill[];
	BuffEntry handBuff;
};

# 消耗道具
struct ItemUse : ItemBase{
	BuffEntry useBuff;
	Time time;
};

struct Item{
	ItemType type = "Equip";
	ItemBase base = ItemEquip();

	monitor("type",function(self,path,oval)
		if self.type == "Equip" then
			self.base = ctor("ItemEquip")
		elseif self.type == "InHand" then
			self.base = ctor("ItemInHand")
		elseif self.type == "Use" then
			self.base = ctor("ItemUse")
		end
	end);
};

#道具消耗类型
enum ConsumeType {
	"Block",
	"Item"
};

# 消耗道具种类
struct ConsumeItemType{
	attrs_updater(function(self)
		set_attr(self, "block", "Visible", self.type == "Block" and "true" or "false")
		set_attr(self, "item", "Visible", self.type == "Item" and "true" or "false")
	end);
	ConsumeType type = "Item";
	BlockEntry block;
	ItemEntry item;
	monitor("type", function(self, path, oval)
		set_attr(self, "block", "Visible", self.type == "Block" and "true" or "false")
		set_attr(self, "item", "Visible", self.type == "Item" and "true" or "false")
	end);
};

# 消耗道具
struct ConsumeItem{
	ConsumeItemType itemType;
	[Integer : "true", Min : "0"]
	number count = 1;
};

# 弹夹Item
struct ItemContainer {
	bool isValid = false;
	[Min: "0", Integer : "true"]
	number initCapacity;
	[Min: "0", Integer : "true"]
	number maxCapacity;
	ConsumeItemType itemType;
};

struct ItemCfg{
#################################################################
## 基础属性 BASE

	# 名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	# 模型
	[TAB: "Base", RELOAD: "true"]
	Resource_Mesh mesh;

	# 图标
	[TAB: "Base", RELOAD: "true",ItemIconRule:"32"]
	Resource_ItemTexture icon;

	# 背包每个格子可放数量
	[TAB: "Base", Min: "0", Integer : "true"]
	number stack_count_max = 1;

	#可被丢弃
	[TAB: "Base"]
	bool canAbandon;

	#可掉落
	[TAB: "Base"]
	bool candrop;

	#可被使用
	[TAB: "Base"]
	bool canUse;

	#可被保存
	[TAB: "Base"]
	bool needSave;
	
#################################################################
## 道具类型 TYPE

	[TAB: "ItemType", EditorData: "true"]
	Item item;

#################################################################
## 其他 OTHER
	#陷阱
	[TAB: "ItemType"]
	bool trap;

	#弹夹配置
	[TAB: "ItemType", Expand: "false"]
	ItemContainer itemContainer;

	[TAB: "Trigger", TRIGGER: "ItemTriggers"]
	TriggerSet triggers;

};

struct StorageEntry{
	string name;
	string id;
};

enum ItemEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("item")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

[Filters:""]
struct ObjectTreeEntry{
	string name;
	string id;
};
#################################################################
########################### Skill ###############################
#################################################################

# 技能动作
enum ActionType{
	"idle",
	"attack2",
	"attack",
	"aim2",
	"aim3",
	"jump3",
	"fly",
	"hammer"
};

# 技能类型
enum SkillType {
	"Base",
	"MeleeAttack",
	"Missile",
	"Reload",
	"Buff",
	"Ray",
	"UseItem"
};

enum CdAnimation {
	"Clockwise",
	"AntiClockwise",
	"TopToBottom",
	"BottomToTop"
};

# 弹夹设置
struct SkillContainer{
	attrs_updater(function(self)
		set_attr(self, "autoReloadSkill", "Visible", self.isValid and "true" or "false")
		set_attr(self, "takeNum", "Visible", self.isValid and "true" or "false")
	end);

	bool isValid;
	SkillEntry autoReloadSkill;
	[Min: "0", Integer: "true"]
	number takeNum = 1;
	
	monitor("isValid", function(self, path, oval)
		set_attr(self, "autoReloadSkill", "Visible", self.isValid and "true" or "false")
		set_attr(self, "takeNum", "Visible", self.isValid and "true" or "false")
	end);
};

struct Skill_Base{
};

# 近战攻击
struct Skill_MeleeAttack : Skill_Base{
	[Min: "0"]
	number range = 4;

	#击退距离
	[Min: "0"]
	number hurtDistance = 0.1;
	
	[Min: "0"]
	number damage;

	[Min: "0"]
	hide number dmgFactor = 0;
};

#装弹技能
struct Skill_Reload : Skill_Base{
	#装弹时间
	Time reloadTime = Time(value = 20);
	#子弹
	ConsumeItemType consumeItem;
};

#buff目标
enum BuffTarget {
	"self",
	"skill_target"
};

#Buff技能
struct Skill_Buff : Skill_Base{
	BuffEntry buffCfg;
	Time buffTime;
	BuffTarget target = "skill_target";
};

#后坐力相关
#struct AutoRecoverRecoil {
#	bool recover;
#	number value;
#	Time time;
#};

struct Skill_Ray : Skill_Base{
	
	attrs_updater(function(self)
		local GameConfig = require "we.gameconfig"
		if GameConfig:disable_block() then
			set_attr(self, "hitBlockSkill", "Visible", "false")
		end
	end);

	# 射线长度
	[Min: "0", Max: "1000"]
	number rayLenth;

	# 命中特效
	Resource_Effect hitEffect;

	# 轨道特效
	Resource_Effect trajectoryEffect;
	
	# 后坐力
	[Min: "0"]
	number recoil;

	# 命中触发
	SkillEntry hitEntitySkill;

	# 爆头触发
	SkillEntry hitEntityHeadSkill;
	
	# 命中方块触发
	SkillEntry hitBlockSkill;
};

struct MissileData {
	MissileEntry missileCfg;
	[Alias: "MyVector3"]
	Vector3 startPos = Vector3(x = 0, y = 1.60, z = 0);
	
	[GROUP: "MissileData.GROUP.direction_of_fire"]
	number startYaw;
	[GROUP: "MissileData.GROUP.direction_of_fire"]
	number startPitch;
	
	[GROUP: "MissileData.GROUP.direction_of_the_missile"]
	number bodyYawOffset;
	[GROUP: "MissileData.GROUP.direction_of_the_missile"]
	number bodyPitchOffset;
	Time startWait;
};

#子弹目标类型
enum MissileTargetType {
	list(function()
		local ret = {}
		table.insert(ret, {value = "CameraYaw"})
		table.insert(ret, {value = "Camera"})
		table.insert(ret, {value = "BodyYaw"})
		table.insert(ret, {value = "Entity"})
		table.insert(ret, {value = "Self"})
		table.insert(ret, {value = "Any"})
		table.insert(ret, {value = "None"})
		local GameConfig = require "we.gameconfig"
			if not GameConfig:disable_block() then
				table.insert(ret, {value = "Block"})
			end
			return ret
		 end
		);
};

struct MissileTargetParam{
};

struct MissileTargetParam_FrontEntity : MissileTargetParam{
	number frontDistance = 1;
	number frontRange = 1;
	number frontHeight = 1;
};

struct MissileTargetStruct{
	attrs_updater(function(self)
		set_attr(self, "param", "Visible", self.type == "FrontEntity" and "true" or "false")
	end);

	MissileTargetType type = "Any";
	MissileTargetParam param;
	monitor("type", function(self, path, oval)
		if self.type == "FrontEntity" then
			self.param = ctor("MissileTargetParam_FrontEntity")
		else
			self.param = ctor("MissileTargetParam")
		end
		set_attr(self, "param", "Visible", self.type == "FrontEntity" and "true" or "false")
	end);
};

struct Skill_Missile : Skill_Base {
	MissileTargetStruct target;
	MissileData missile[];
};

struct Skill_UseItem : Skill_Base {
};

[EditorData: "true"]
struct Skill {
	attrs_updater(function(self)
		set_attr(self, "base", "Visible", 
			(self.type == "Base" or self.type == "" or self.type == "UseItem") and "false" or "true")
	end);
	SkillType type = "MeleeAttack";
	Skill_Base base = Skill_MeleeAttack();

	monitor("type", function(self, path, oval)
		if self.type == "MeleeAttack" then
			self.base = ctor("Skill_MeleeAttack")
		elseif  self.type == "Reload" then
			self.base = ctor("Skill_Reload")
		elseif self.type == "Buff" then
			self.base = ctor("Skill_Buff")
		elseif self.type == "Ray" then
			self.base = ctor("Skill_Ray")
		elseif self.type == "UseItem" then
			self.base = ctor("Skill_UseItem")
		elseif self.type == "Missile" then
			self.base = ctor("Skill_Missile")
		elseif self.type == "Base" or self.type == "" then
			self.base = ctor("Skill_Base")
		else
			assert(false, self.type)
		end
		set_attr(self, "base", "Visible", 
			(self.type == "Base" or self.type == "" or self.type == "UseItem") and "false" or "true")
	end);
};

#技能图标位置
struct SkillIconPos{
	number area_number;
};

#长按连发
struct EmitContinuously{
	bool isValid;
	Time castInterval;
};

#技能释放方式
struct SkillReleaseWay{

	attrs_updater(function(self)
		set_attr(self, "icon", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "iconPos", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "emitContinuously", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "draggingEnabled", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "sensitivityFactor", "Visible", self.isClickIcon and "true" or "false")
	end);

	#点击图标释放
	bool isClickIcon = true;
	#图标
	Resource_SkillTexture icon;
	#技能图标
	SkillIconPos iconPos;
	#图标可移动
	bool draggingEnabled;
	#移动灵敏度
	[Min: "0", Max: "10", ShowSlider: "true"]
	number sensitivityFactor = 1;

	#点击释放
	bool isClick;

	#长按释放
	bool isTouch;
	# 长按时间
	Time touchTime;

	#长按连发
	EmitContinuously emitContinuously;
	
	monitor("isClickIcon", function(self, path, oval)
		set_attr(self, "icon", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "iconPos", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "emitContinuously", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "draggingEnabled", "Visible", self.isClickIcon and "true" or "false")
		set_attr(self, "sensitivityFactor", "Visible", self.isClickIcon and "true" or "false")
	end);
};

struct SkillPre{
	attrs_updater(function(self)
		set_attr(self, "time", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_release", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_move", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_jump", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "move_interrupt", "Visible", self.enable_pre and "true" or "false")
	end);
	bool enable_pre = false;
	monitor("enable_pre", function(self, path, oval)
		set_attr(self, "time", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_release", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_move", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "ignore_jump", "Visible", self.enable_pre and "true" or "false")
		set_attr(self, "move_interrupt", "Visible", self.enable_pre and "true" or "false")
	end);
	Time time;
	bool ignore_release = true;
	bool ignore_move;
	bool ignore_jump;
	bool move_interrupt;
};

struct SkillRear{
	attrs_updater(function(self)
		set_attr(self, "time", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_release", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_move", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_jump", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "move_interrupt", "Visible", self.enable_rear and "true" or "false")
	end);
	bool enable_rear = false;
	monitor("enable_rear", function(self, path, oval)
		set_attr(self, "time", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_release", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_move", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "ignore_jump", "Visible", self.enable_rear and "true" or "false")
		set_attr(self, "move_interrupt", "Visible", self.enable_rear and "true" or "false")
	end);
	Time time;
	bool ignore_release;
	bool ignore_move;
	bool ignore_jump;
	bool move_interrupt;
};
#################################################################
########################### SkillSystemCfg #############################
#################################################################
struct AttackBound{	
	attrs_updater(function(self)
		set_attr(self, "size", "Visible", self.type == "Box" and "true" or "false")
		set_attr(self, "height", "Visible", self.type == "Cylinder" and "true" or "false")
		set_attr(self, "radius_c", "Visible", self.type == "Capsule" and "true" or "false")
		set_attr(self, "height_c", "Visible", self.type == "Capsule" and "true" or "false")
		
		local radius_visiabel= self.type ~= "Capsule" and self.type ~= "Box"	
		set_attr(self, "radius", "Visible", radius_visiabel and "true" or "false")
		
		set_attr(self.size, "x", "Min", "0.01")
		set_attr(self.size, "y", "Min", "0.01")
		set_attr(self.size, "z", "Min", "0.01")
	end);
  
	BdVolumeType type = "Box";
	monitor("type", function(self, path, oval)
		set_attr(self, "size", "Visible", self.type == "Box" and "true" or "false")
		set_attr(self, "height", "Visible", self.type == "Cylinder" and "true" or "false")
		set_attr(self, "radius_c", "Visible", self.type == "Capsule" and "true" or "false")
		set_attr(self, "height_c", "Visible", self.type == "Capsule" and "true" or "false")
		
		local radius_visiabel= self.type ~= "Capsule" and self.type ~= "Box"	
		set_attr(self, "radius", "Visible", radius_visiabel and "true" or "false")
		

		if self.memory[oval] then
			self.memory[oval] = string.format("%f-%f", self.height,self.radius)
		end
		
		if self.memory[self.type] and self.memory[self.type] ~= "" then
			local str = self.memory[self.type]
			local pos = string.find(str, "-")

			if pos then
				self.radius = tonumber(string.sub(str, pos + 1, #str))
				self.height = tonumber(string.sub(str, 1, pos - 1))
			end
		else
			self.height = 1
			self.radius = 0.5
		end
	end);

	[Alias: "MyVector3"]
	Vector3 position = Vector3(x = 0.0, y = 0.0, z = 0.0);
	
	[Alias: "MyVector3"]
	Vector3 rotate = Vector3(x = 0.0, y = 0.0, z = 0.0);	
	
	[Alias: "MyVector3"]
	Vector3 size = Vector3(x = 1, y = 1, z = 1);

	[Max: "999", Min: "0.01"]
	number radius = 0.5;

	[Max: "999", Min: "0.01"]
	number height = 1;
	
	[Max: "999", Min: "0.01"]
	number radius_c = 0.5;
	monitor("radius_c", function(self, path, oval)
		if self.height_c < self.radius_c*2 then
			self.radius_c = self.height_c/2
		end
	end);

	[Max: "999", Min: "0.02"]
	number height_c = 1.5;
	monitor("height_c", function(self, path, oval)
		if self.height_c < self.radius_c*2 then
			self.height_c = self.radius_c*2
		end
	end);

	hide BoundingVolumeMemory memory;	
};

struct AttackTarget {
	attrs_updater(function(self)
		set_attr(self, "teamList", "Visible", self.attackTeam == "hitTargetTeam" and "true" or "false")
		set_attr(self, "entityList", "Visible", self.attackEntity == "hitTargetConfigEntity" and "true" or "false")
		for i,_ in ipairs(self.teamList) do
			set_attr(self.teamList, tostring(i), "Integer", "true")
			set_attr(self.teamList, tostring(i), "Min", "1")
		end
	end);
		
    #可攻击目标队伍
	TargetTeam attackTeam = "hitAllTeam";
	[Integer: "true", Min:"1"]
	number teamList[];
	monitor("teamList",function(self,path,oval,op)
		if op == "INSERT" then
			local index = path[2]
			if index == 0 then
				return false
			end
			self.teamList[index] = 1
		end
		return true
	end);

	monitor("teamList", function(self, path, oval, op)
		if op == "INSERT" then
			set_attr(self.teamList, tostring(path[2]), "Integer", "true")
			set_attr(self.teamList, tostring(path[2]), "Min", "1")
		end
	end);

	#可攻击目标类型
	TargetType targetType = "hitAllEntitys";
	
	#可攻击目标单位
	TargetCfg attackEntity = "hitAllConfigEntity";
	EntityEntry entityList[];
	
	monitor("attackTeam", function(self, path, oval)
		set_attr(self, "teamList", "Visible", self.attackTeam == "hitTargetTeam" and "true" or "false")
	end);

	monitor("attackEntity", function(self, path, oval)
		set_attr(self, "entityList", "Visible", self.attackEntity == "hitTargetConfigEntity" and "true" or "false")
	end);	
};

struct SkillReleaseAction{
	attrs_updater(function(self)
		set_attr(self, "castActionTime", "Visible", self.custom_time and "true" or "false")
	end);
	[Editable: "true"]
	ActionType castAction;
	bool custom_time = false;
	monitor("custom_time", function(self, path, oval)
		set_attr(self, "castActionTime", "Visible", self.custom_time and "true" or "false")
	end);
	Time castActionTime = Time(value = 20);
};

struct SkillSystemCfg {
	attrs_updater(function(self)
		set_attr(self, "maxAttackNumber", "Visible", self.isLimit and "true" or "false")
	end);
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	
	#攻击范围 
	[TAB: "Base"]
	AttackBound attackBound;
	
	#可攻击目标
	[TAB: "Base"]
	AttackTarget attackTarget;

	#攻击数量限制
	[TAB: "Base"]
	bool isLimit;
	monitor("isLimit", function(self, path, oval)
		set_attr(self, "maxAttackNumber", "Visible", self.isLimit and "true" or "false")
	end);

	#最大攻击数量
	[TAB: "Base", Integer: "true", Min:"0", Max:"100"]
	number maxAttackNumber = 1;

	#技能伤害
	[TAB: "Base", Min:"0", Max:"10000000"]
	number damage = 5;

	#击退距离
	[TAB: "Base", Min: "0", Max: "100"]
	number hurtDistance = 0.1;
	
	#技能前摇时间
	[TAB: "Base", Min: "0", Max: "10"]
	Time preKillTime;
	
	#攻击判定时长
	[TAB: "Base", Min: "0.01", Max: "10"]
	Time lifeTime = Time(value = 2);
		
	#冷却时间
	[TAB: "Base", Min: "0", Max: "10000000"]
	Time cdTime;
	
#################################################################
## 	技能释放方式
	
	#技能按钮图标
	[TAB: "SkillReleaseWay"]
	Resource_SkillTexture skillIcon;
	
	#技能按钮图标
	[TAB: "SkillReleaseWay"]
	SkillIconPos skillIconPos;
	

	#长按连发
	[TAB: "SkillReleaseWay"]
	bool isTouch;
	
	#连发间隔
	[TAB: "SkillReleaseWay"]
	Time castInterval;


#################################################################
## 技能表现 SHOW
	
	# 释放动作
	[TAB: "Expression"]
	SkillReleaseAction castAction;

	# 释放特效
	[TAB: "Expression"]
	EntityEffect castEffect;

	# 释放音效
	[TAB: "Expression"]
	CastSound castSound;
	
	# 命中音效
	[TAB: "Expression"]
	CastSound hitEntitySound;
};

struct SkillCfg {
	attrs_updater(function(self)
		set_attr(self, "castActionTime", "Visible", self.defineActionTime and "true" or "false")
	end);
	
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;
	
#################################################################
## 技能类型 TYPE
	[TAB: "Base"]
	Skill skill;

	#技能释放方式
	[TAB: "SkillReleaseWay"]
	SkillReleaseWay skillReleaseWay;

	#冷却时间
	[TAB: "Base",Min:"0",Max:"10000000", GROUP:"SKILL.GROUP.SKILLCDSETTING"]
	Time cdTime;

	#冷却动画
	[TAB: "Base", GROUP:"SKILL.GROUP.SKILLCDSETTING"]
	CdAnimation cdAnimation;

	#填充位置
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	hide string FillPosition;

	#填充角度
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	hide FillType FillType;

	#逆时针填充
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	hide bool AntiClockwise;	

	#是否显示倒计时
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	bool enableCdTip;

	#是否显示cd小数
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	hide bool isShowCdPoint;						

	#是否启用技能遮罩
	[TAB: "Base", GROUP: "SKILL.GROUP.SKILLCDSETTING"]
	hide bool enableCdMask;

	monitor("cdAnimation", function(self, path, oval)
        if (self.cdAnimation == "Clockwise") then
			self.enableCdMask = true
            self.AntiClockwise = false
			self.FillType = "With360Degree"
			self.FillPosition = "Top_With360Degree"
		elseif self.cdAnimation == "AntiClockwise" then
			self.enableCdMask = true
			self.AntiClockwise = true
			self.FillType = "With360Degree"
			self.FillPosition = "Top_With360Degree"
		elseif self.cdAnimation == "TopToBottom" then
			self.enableCdMask = true
			self.FillPosition = "Bottom_Vertical"
			self.FillType = "Vertical"
		elseif self.cdAnimation == "BottomToTop" then
			self.enableCdMask = true
			self.FillPosition = "Top_Vertical"
			self.FillType = "Vertical"
		else
			self.enableCdMask = false
        end
    end);
	#前摇
	[TAB: "Base"]
	SkillPre skill_pre;

	#后摇
	[TAB: "Base"]
	SkillRear skill_rear;
#################################################################
## 技能消耗 CONSUME

	#技能消耗道具
	[TAB: "Consume"]
	ConsumeItem consumeItem[];

	# 消耗饥饿度
	[TAB: "Consume", Min: "0"]	
	number consumeVp = 0;

	#消耗弹夹
	[TAB: "Consume"]	
	SkillContainer container;

#################################################################
## 技能表现 SHOW
	
	# 准星
	[TAB: "Expression", EnumText: "Value"]
	FrontSightEntry frontSight;
	
	# 狙击镜 
	[TAB: "Expression"]
	hide bool snipe;

	# 释放动作
	[TAB: "Expression", Editable: "true"]
	ActionType castAction;
	
	#自定义动作时长
	[TAB: "Expression", Editable: "false"]
	bool defineActionTime = false;

	monitor("defineActionTime", function(self, path, oval)
		set_attr(self, "castActionTime", "Visible", self.defineActionTime and "true" or "false")
	end);

	# 释放动作时间
	[TAB: "Expression"]
	Time castActionTime = Time(value = 20);

	# 起手动作
	[TAB: "Expression", Editable: "true"]
	ActionType startAction;
	
	[TAB: "Expression"]
	Time startActionTime;
	
	# 音效
	[TAB: "Expression"]
	CastSound castSound;

	# 特效
	[TAB: "Expression"]
	EntityEffect castEffect;
	
	# 起手特效
	[TAB: "Expression"]
	hide EntityEffect startEffect;

	# 蓄力动作
	[TAB: "Expression", Editable: "true"]
	hide ActionType sustainAction;
	
	# 蓄力特效
	[TAB: "Expression"]
	hide EntityEffect sustainEffect;
	
	# 结束特效
	[TAB: "Expression"]
	hide EntityEffect stopEffect;

#################################################################
## 其他 OTHER
	[TAB: "Trigger", TRIGGER: "SkillTriggers"]
	TriggerSet triggers;
};

enum SkillEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("skill")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

#################################################################
########################### Missile #############################
#################################################################

enum MissileEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("missile")
		
		for key , item in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key,
				attrs = {name = item:val().name.value}
			})
		end

		collectgarbage("collect")
		return ret
	end);
};

#################################################################
########################### FrontSight #############################
#################################################################

struct FrontSightCfg {
#################################################################
## 基础属性 BASE

};

enum FrontSightEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("frontsight")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end
		collectgarbage("collect")
		return ret
	end);
};

#################################################################
########################### Buff ################################
#################################################################

enum BuffSync {
	"all",
	"self",
	"team",
	"other"
};

#buff外观
struct BuffFacade {
	[RenameJudgment : "true"]
	string slaveName;
	[RenameJudgment : "true"]
	string masterName;
};

#动作替换
struct ReplaceAction {
	string beReplacedAction;
	string replaceAction;
};

#动作播放速度
struct ActionPlaybackSpeed {
	string Action;

	[Min:"0"]
	number PlaySpeed;
};

[Nonempty : "true"]
enum BuffSuperposition {
	"superposition",
	"append",
	"reset",
	"max"
};

struct BuffCfg{
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true"]
	Text name;

	#可保存
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	bool needSave;
	
	#叠加规则
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	BuffSuperposition fixTime = "superposition";
	
	#死亡时移除
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	bool deadRemove;

	#同步
	[TAB: "Base", GROUP: "BUFF.GROUP.BASE"]
	BuffSync sync = "all";

#################################################################
## Buff效果 PECULIARITY

	# 最大血量
	[TAB: "Base", GROUP: "BUFF.GROUP.BIOLOGY"]
	number maxHp;

	# 走动速率
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveSpeed;

	# 移动速率
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveFactor;

	# 跳跃速度
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number jumpSpeed;
	
	# 加速度
	[TAB: "Base", GROUP: "BUFF.GROUP.MOVE"]
	number moveAcc;

	# 重力
	[TAB: "Base", GROUP: "BUFF.GROUP.PHYSICS"]
	number gravity;
		
	#反重力
	[TAB: "Base", GROUP: "BUFF.GROUP.PHYSICS", Min: "0", Step: "0.1"]
	number antiGravity;
	
	#替换动作
	[TAB: "Base"]
	ReplaceAction replaceAction[];
	
	# 动作播放速度
	[TAB: "Base"]
	ActionPlaybackSpeed actionPlaybackSpeed[];

	# 落地扣血速度阈值
	[TAB: "Base", GROUP: "BUFF.GROUP.DROP"]
	number dropDamageStart;

	# 落地扣血速率
	[TAB: "Base", GROUP: "BUFF.GROUP.DROP"]
	number dropDamageRatio;
	
#################################################################
## 战斗

	# 攻击力
	[TAB: "Battle"]
	number damage;
	
	#攻击力系数
	[TAB: "Battle", Min: "-1", Step: "0.01"]
	number damagePct;
	
	#减伤系数
	[TAB: "Battle", Min: "-1", Max: "1", Step: "0.01"]
	number deDmgPct;
	
	# 攻击距离
	[TAB: "Battle"]
	number reachDistance;

	# 持续伤害
	[TAB: "Battle", Min:"0"]
	number continueDamage;

	# 持续回血
	[TAB: "Battle", Min:"0"]
	number continueHeal;

	# 不可被伤害
	[TAB: "Battle"]
	bool undamageable;

	# 不可被攻击
	[TAB: "Battle"]
	bool unassailable;
	
#################################################################
#表现

	#音效
	[TAB: "Expression"]
	CastSound sound;
	
	#特效
	[TAB: "Expression"]
	EntityEffect castEffect;
	
	#外观
	[TAB: "Expression"]
	BuffFacade skin[];
	
	# 是否透明
	[TAB: "Expression"]
	bool hide;

};

enum BuffEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("buff")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

struct RotateTheCamera {
	attrs_updater(function(self)
		set_attr(self, "time", "Visible", self.enable and "true" or "false")
		set_attr(self, "pitch", "Visible", self.enable and "true" or "false")
		set_attr(self, "yaw", "Visible", self.enable and "true" or "false")
	end);

	bool enable;
	Time time;
	[Min: "-90", Max: "90"]
	number pitch;
	number yaw;
	
	monitor("enable", function(self, path, oval)
		set_attr(self, "time", "Visible", self.enable and "true" or "false")
		set_attr(self, "pitch", "Visible", self.enable and "true" or "false")
		set_attr(self, "yaw", "Visible", self.enable and "true" or "false")
	end);
};

struct RegionView {
	attrs_updater(function(self)
		if self.enable then
			set_attr(self, "type",			"Visible", "true")
			set_attr(self, "viewFovAngle",	"Visible", "true")
			set_attr(self, "back_dragView",	"Visible", "true")
			if self.type == "FirstPerson" or self.type == "Fixed" then
				set_attr(self, "distance",		"Visible", "false")
				set_attr(self, "viewIsBlocked",	"Visible", "false")
				set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
			else
				set_attr(self, "distance",		"Visible", "true")
				set_attr(self, "viewIsBlocked",	"Visible", "true")
				set_attr(self, "pos",			"Visible", "false")
			end
		else
			set_attr(self, "type",			"Visible", "false")
			set_attr(self, "viewFovAngle",	"Visible", "false")
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "back_dragView",	"Visible", "false")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);

	bool enable;
	ViewType type = "Follow";
	[Min: "0", Max: "180"]
	number viewFovAngle = 75;
	[Min: "0"]
	number distance = 4;
	ViewIsBlocked viewIsBlocked = "PushCamera";
	bool back_dragView = true;
	MapPos pos;
	
	monitor("enable", function(self, path, oval)
		if self.enable then
			set_attr(self, "type",			"Visible", "true")
			set_attr(self, "viewFovAngle",	"Visible", "true")
			set_attr(self, "back_dragView",	"Visible", "true")
			if self.type == "FirstPerson" or self.type == "Fixed" then
				set_attr(self, "distance",		"Visible", "false")
				set_attr(self, "viewIsBlocked",	"Visible", "false")
				set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
			else
				set_attr(self, "distance",		"Visible", "true")
				set_attr(self, "viewIsBlocked",	"Visible", "true")
				set_attr(self, "pos",			"Visible", "false")
			end
		else
			set_attr(self, "type",			"Visible", "false")
			set_attr(self, "viewFovAngle",	"Visible", "false")
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "back_dragView",	"Visible", "false")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);
	
	monitor("type", function(self, path, oval)
		if self.type == "FirstPerson" or self.type == "Fixed" then
			set_attr(self, "distance",		"Visible", "false")
			set_attr(self, "viewIsBlocked",	"Visible", "false")
			set_attr(self, "pos",			"Visible", self.type == "Fixed" and "true" or "false")
		else
			set_attr(self, "distance",		"Visible", "true")
			set_attr(self, "viewIsBlocked",	"Visible", "true")
			set_attr(self, "pos",			"Visible", "false")
		end
	end);
};


#################################################################
########################### Region ##############################
#################################################################

struct RegionCfg {

#################################################################
# 基础 BASE
	
	[TAB: "Base", GROUP: "REGION.GROUP.BASE"]
	RotateTheCamera rotateTheCamera;
	
	[TAB: "Base", GROUP: "REGION.GROUP.BASE"]
	RegionView view;

#################################################################
# 其他 OTHER

	[TRIGGER: "RegionTriggers"]
	hide TriggerSet triggers;
};

enum RegionEntry {
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("region")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = key
			})
		end

		return ret
	end);
};

#################################################################
########################### Game ################################
#################################################################

[Nonempty : "true"]
enum VarRunType{
	"server",
	"client"
};

[Nonempty : "true"]
enum VarType {
	[Type:"T_Int"]
	"int",
	[Type:"T_Double"]
	"double",
	[Type:"T_Bool"]
	"bool",
	[Type:"T_Entity"]
	"entity",
	[Type:"T_Vector3"]
	"vector3",
	[Type:"T_ScenePos"]
	"scene_pos",
	[Type:"T_String"]
	"string",
	[Type:"T_UDim2"]
	"udim2",
	[Type:"T_Widget"]
	"widget",
	[Type:"T_Var"]
	"var",
	[Type:"T_Part"]
	"part",
	[Type:"T_MeshPart"]
	"meshPart",
	[Type:"T_PartOperation"]
	"partOperation"	
};

[Nonempty : "true"]
enum DataStructureType {
	"array",
	"var",
};

[Property_Show_Root: "true"]
struct VarItem {

	attrs_updater(function(self)
		local Trigger = require "we.gamedata.trigger"
		local run_type = Trigger:get_run_type()
		if self.key == "" then
			self.run_type = run_type
		end
	end);

	string key;
	VarRunType run_type = "server";
	VarType type = "int";
	DataStructureType struct_type = "var";
	hide T_Int value;
	bool save = false;

	monitor("struct_type", function(self, path, oval)
		local Meta = require "we.gamedata.meta.meta"
		local meta = Meta:meta("VarType")
		local type = meta:attribute("Type", self.type)
		if self.struct_type == "array" then
			self.value = ctor(type.."Array")
			return;
		end
		self.value = ctor(type)
	end);

	monitor("type", function(self, path, oval)
		local Meta = require "we.gamedata.meta.meta"
		local meta = Meta:meta("VarType")
		local type = meta:attribute("Type", self.type)
		if self.struct_type == "array" then
			self.value = ctor(type.."Array")
			return;
		end
		self.value = ctor(type)
	end);
};

[EditorData: "true"]
struct VarTable {
	VarItem global[];
	VarItem entity[];
	VarItem ui[];
};

struct Team {
	attrs_updater(function(self)
		set_attr(self, "actorName", "Visible", self.ignorePlayerSkinEditor and "true" or "false")
		set_attr(self, "initPos", "Visible", self.use_init_pos and "true" or "false")
		set_attr(self, "startPos", "Visible", self.use_start_pos and "true" or "false")
	end);
	[Integer : "true", Min: "1"]
	number id = 1;
	string name = "team";
	[LimitSize:"false"]
	Resource_BlockTexture image =Resource_BlockTexture(
	    asset = "asset/Texture/Team/flag/flag_1.png",
        selector= "asset/Texture/Team/flag/flag_1.png"
	);
	bool use_init_pos = true;
	MapPos initPos;

	bool use_start_pos = true;
	MapPos startPos;
	[Integer : "true", Min: "1"]
	number memberLimit = 5;
	bool ignorePlayerSkinEditor = true;
	Resource_Actor actorName = Resource_Actor(
		asset = "asset/Actor/charactor/charactor_boy/character_boy.actor",
		selector = "asset/Actor/charactor/charactor_boy/character_boy.actor");
		
	monitor("use_init_pos", function(self, path, oval)
		set_attr(self, "initPos", "Visible", self.use_init_pos and "true" or "false")
	end);

	monitor("use_start_pos", function(self, path, oval)
		set_attr(self, "startPos", "Visible", self.use_start_pos and "true" or "false")
	end);

	monitor("ignorePlayerSkinEditor", function(self, path, oval)
		set_attr(self, "actorName", "Visible", self.ignorePlayerSkinEditor and "true" or "false")
	end);
};

#游戏结束条件
[Nonempty: "true"]
enum GameOverCondition {
	"TimeOut",
	"KillAllEnemy",
	"KillSomePlayers",
	"ReachEndArea",
	"CollectSomeItems",
	"GetSomePoints"
};

#排名依据
[Nonempty: "true"]
enum RankCredentials {
	"TimeOut",
	"KillAllEnemy",
	"KillSomePlayers",
	"ReachEndArea",
	"CollectSomeItems",
	"GetSomePoints"
};
	#排名依据Base
struct RankBase{
};

# 排名依据-游戏自然结束
[Nonempty : "true"]
enum TimeOutMode {
	"get_points",
	"kill_enemy",
};
#游戏自然结束 结束条件
struct RankTimeOut : RankBase{
	TimeOutMode timeout_mode;
};

#击杀所有敌方玩家 结束条件
struct RankKillAllEnemy : RankBase{
	[Enabled: "false"]
	Text tip = Text(value="RankKillAllEnemyTip");
};

#击杀指定数量敌方玩家 结束条件
struct RankKillSomePlayers : RankBase{
	[Enabled: "false"]
	Text tip= Text(value="RankKillSomePlayersTip");
};

#到达终点区域 结束条件 ①“个人”：只要一个人到达就结束；②“全体玩家”需要全体玩家都到达过才结束。
[Nonempty : "true"]
enum AreaMode {
	"single",
	"team",
};
#到达终点区域：
struct RankReachEndArea : RankBase{
	AreaMode mode;
	SceneRegion rawval;
	[Enabled: "false"]
	Text tip=Text(value="RankReachEndAreaTip");
};

#收集指定道具：
struct RankCollectSomeItems : RankBase{
	SceneRegion rawval;
	number num;
	number time;
	[Enabled: "false"]
	Text tip=Text(value="RankCollectSomeItemsTip");
};

#获得指定积分：
struct RankGetSomePoints : RankBase{
	number num;
	[Enabled: "false"]
	Text tip=Text(value="RankGetSomePointsTip");
};

#游戏结束
struct GameOverCfg{
	bool showSettlementPanel;

	#游戏时长启用
	[TAB: "TAB.GAMEOVER", GROUP: "GAME.GROUP.GAMETIME"]
	bool gameTimeEnable;

	#游戏时长
	[TAB: "TAB.GAMEOVER", GROUP: "GAME.GROUP.GAMETIME"]
	Time gameTime;

	#结束条件启用
	[TAB: "TAB.GAMEOVER", GROUP: "GAME.GROUP.GAMEOVERCONDITION"]
	bool gameOverConditonEnable;

	#结束条件
	[TAB: "TAB.GAMEOVER", GROUP: "GAME.GROUP.GAMEOVERCONDITION"]
	GameOverCondition gameOverCondition;

	#排名依据
	[TAB: "TAB.GAMEOVER", GROUP: "GAME.GROUP.GAMEOVERCONDITION"]
	RankBase rankBase = RankTimeOut(timeout_mode = "get_points");
	monitor("gameOverCondition",function(self,path,oval) 
		local game_over = require "we.logic.game.game_over" 
		game_over.GameOverRank(self)
	end);
	
	
	#RankTimeOut rankTimeOut;
	#RankKillAllEnemy rankKillAllEnemy;
	#RankKillSomePlayers rankKillSomePlayers;
	#RankReachEndArea rankReachEndArea;
	#RankCollectSomeItems rankCollectSomeItems;
	#RankGetSomePoints rankGetSomePoints;
};

struct TeamCfg {
	bool automatch;
	bool teammateHurt;
	bool showTeamStatusBar = true;
	Team team[];
};

struct CommodityItem{
	Text name;
	Text tip;
	ConsumeItemType item;
	[Integer : "true", Min: "0"]
	number count = 1;
	[Integer : "true", Min: "0"]
	number price = 1;
};

struct CommodityPageIndex{
	number val;
};

struct CommodityPage{
	CommodityPageIndex index;
	Resource_ShopTexture icon;
	Text name;
	CommodityItem items[];
};

[Nonempty : "false", EnumText : "Name"]
enum CurrencyEntry{
	list(function()
		local ret = {}
		table.insert(ret, {
			value = "gDiamonds",
			attrs = {name = "Currency.gDiamonds.name"}
		})
		local Coin = require "we.gamedata.coin"
		local Module = require "we.gamedata.module.module"
		local m = Module:module("item")
		
		for _, id in ipairs(Coin:list()) do
			local name = m:item(id):obj().name.value
			table.insert(ret, {
				value = id,
				attrs = {name = name}
			})
		end
		
		collectgarbage("collect")
		return ret
	end);
};

[Nonempty : "false", EnumText : "Name"]
enum UserCurrencyEntry {
	list(function()
	
		local ret = {}
		local Coin = require "we.gamedata.coin"
		local Module = require "we.gamedata.module.module"
		local m = Module:module("item")
		
		for _, id in ipairs(Coin:list()) do
			local name = m:item(id):obj().name.value
			table.insert(ret, {
				value = id,
				attrs = {name = name}
			})
		end
		
		collectgarbage("collect")
		return ret
	end);
};

#购买显示
[Nonempty : "true"]
enum LimitType{
	"NoLimit",
	#"Common",
	"Personal"
};

# 商城道具种类
struct ShopItemType{
	#道具类型 只会为item、block
	string type = "item";
	string item;
};

# 商城道具
struct ShopItem{
	attrs_updater(function(self)
		set_attr(self, "limit", "Enabled", self.limitType == "NoLimit" and "false" or "true");
	end);

	ShopItemType item;
	Text name;
	[Integer : "true", Min: "0"]
	number price;
	[EnumUpdate : "true", EnumText: "Name"]
	CurrencyEntry coinId;
	[Integer : "true", Min: "1"]
	number num = 1;
	[Integer : "true", Min: "0"]
	number limit;
	LimitType limitType = "NoLimit";
	monitor("limitType", function(self, path, oval)
		set_attr(self, "limit", "Enabled", self.limitType == "NoLimit" and "false" or "true");
	end);
	
	[Integer : "true", Min: "0"]
	number stackLimit = 1;
	[Long : "true", MaxLength:"1000"]
	Text detail;
};

struct ShopPage{
	Text name;
	ShopItem items[];
};

#视角类型
[Nonempty: "true"]
enum ViewType {
	"FirstPerson",
	"Back",
	"Front",
	"Follow",
	"Fixed"
};

#当视角被挡住
[Nonempty: "true"]
enum ViewIsBlocked {
	"PushCamera",
	"Don't"
};

struct ViewEnable {
	bool enable;
};

#引擎界面开关列表
struct EngineDefUIEnable {
	#摇杆及跳跃按
	bool actionControl = true;
	#顶部工具
	bool toolbar = true;
	#队伍
	#bool topteamInfo = true;
	#道具栏
	bool shortcutBar = true;  
	#背包
	bool appMainRole = true;
	#聊天
	bool chat = true;
	#血條
	bool playerinfo = true;
};

struct GameCfg {

	attrs_updater(function(self)
		set_attr(self, "firstPerson_viewFovAngle", "Visible", self.firstPerson_enable.enable and "true" or "false")
		set_attr(self, "firstPerson_dragView", "Visible", self.firstPerson_enable.enable and "true" or "false")
		
		set_attr(self, "back_viewFovAngle", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_distance", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_viewIsBlocked", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_dragView", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_view_offset", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self.back_view_offset, "x", "Max", "100");
		set_attr(self.back_view_offset, "x", "Min", "-100");
		set_attr(self.back_view_offset, "y", "Max", "100");
		set_attr(self.back_view_offset, "y", "Min", "-100");
		set_attr(self.back_view_offset, "z", "Max", "100");
		set_attr(self.back_view_offset, "z", "Min", "-100");
		
		set_attr(self, "front_viewFovAngle", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_distance", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_viewIsBlocked", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_dragView", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_view_offset", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self.front_view_offset, "x", "Max", "100");
		set_attr(self.front_view_offset, "x", "Min", "-100");
		set_attr(self.front_view_offset, "y", "Max", "100");
		set_attr(self.front_view_offset, "y", "Min", "-100");
		set_attr(self.front_view_offset, "z", "Max", "100");
		set_attr(self.front_view_offset, "z", "Min", "-100");
		
		set_attr(self, "follow_viewFovAngle", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_distance", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_viewIsBlocked", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_dragView", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_view_offset", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self.follow_view_offset, "x", "Max", "100");
		set_attr(self.follow_view_offset, "x", "Min", "-100");
		set_attr(self.follow_view_offset, "y", "Max", "100");
		set_attr(self.follow_view_offset, "y", "Min", "-100");
		set_attr(self.follow_view_offset, "z", "Max", "100");
		set_attr(self.follow_view_offset, "z", "Min", "-100");
		
		set_attr(self, "fixed_viewFovAngle", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_viewPos", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_dragView", "Visible", self.fixed_enable.enable and "true" or "false")
		
		set_attr(self, "playTime", "Visible", self.unlimitedPlayTime and "false" or "true");
		
		set_attr(self, "oneDayTime", "Visible", self.isTimeStopped and "false" or "true");
		set_attr(self, "player_range", "Warning", self.player_range.min > #self.team.team and "min number out" or "");
		local team = require "we.logic.game.team"
		set_attr(self, "player_range", "Warning", team.NumberOfInspection(self))
	end);
	
#################################################################
## 基础属性 BASE	
	
	hide EntityEntry playerCfg = "player1";
	
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool enableNewLighting = false;

	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE",Warning:"",Min:"1",Integer: "true"]
	ValueRange player_range;

	monitor("player_range", function(self, path, oval)
		local team = require "we.logic.game.team"
		set_attr(self, "player_range", "Warning", team.NumberOfInspection(self))
	end);

	
	#可中途加入
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool canJoinMidway = true;
	
	#全局的数据储存
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	bool needSave = false;
	
	#等待玩家进入时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitPlayerTime;

	#等待游戏开始时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitStartTime;

	#游戏正式开始
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	Time waitGoTime;
	
	#等待点
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	MapPos initPos;
	
	#出生点
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	MapPos startPos = MapPos(pos = Vector3(x = 31,y = 54, z =49));

	#可重玩
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	hide bool replay = false;

	#无限游戏时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE/GameTime"]
	bool unlimitedPlayTime = false;

	#游戏时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE/GameTime"]
	Time playTime = Time(value = 1200);
	
	monitor("unlimitedPlayTime", function(self, path, oval)
		set_attr(self, "playTime", "Visible", self.unlimitedPlayTime and "false" or "true");
	end);
	
	#显示结算面板时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	hide Time reportTime = Time(value = 1200);
	
	#进入游戏的时间
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE/SceneTime"]
	ClockTime nowTime = ClockTime(h = 6);
	
	#游戏时间不流逝
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE/SceneTime"]
	bool isTimeStopped = true;

	#一日时长
	[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE/SceneTime", Min: "1", Max: "1200"]
	Time oneDayTime = Time(value = 12000);
	
	monitor("isTimeStopped", function(self, path, oval)
		set_attr(self, "oneDayTime", "Visible", self.isTimeStopped and "false" or "true");
	end);
	
	#背包容量
	[Integer: "true",TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE", Min: "0", Max: "54"]
	number bagCap = 9;

	#显示任务图标
	#[TAB: "TAB.PROP", GROUP: "GAME.GROUP.BASE"]
	#bool needTask;
	
#################################################################
## 游戏结束 GAMEOVER

	#显示结算面板
	#[TAB: "TAB.GAMEOVER"]
	#GameOverCfg gameOver;
#################################################################

#################################################################
## 队伍 TEAM
	
	#队伍
	[TAB: "TAB.TEAM"]
	TeamCfg team;
	monitor("team", function(self, path, oval, op)
		local team = require "we.logic.game.team"
		team.TeamParaInit(self,op)
		set_attr(self, "player_range", "Warning", team.NumberOfInspection(self))
	end);
	
#################################################################
## 视角 VIEW

	#初始视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	ViewType defaultView = "FirstPerson";
	
	#允许切换视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	bool canSwitchView = true;
	
	#初始俯仰角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW", Min: "-90", Max: "90"]
	number defaultPitch;
	
	#初始偏航角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.VIEW"]
	number defaultYaw;
	
#####################第一视角#####################

	monitor("firstPerson_enable", function(self, path, oval)
		set_attr(self, "firstPerson_viewFovAngle", "Visible", self.firstPerson_enable.enable and "true" or "false")
		set_attr(self, "firstPerson_dragView", "Visible", self.firstPerson_enable.enable and "true" or "false")
	end);
	
	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON"]
	ViewEnable firstPerson_enable = ViewEnable(enable = true);
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON", Min: "0", Max: "180"]
	number firstPerson_viewFovAngle = 75;
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIRST_PERSON"]
	bool firstPerson_dragView = true;
	
#####################后视角#####################

	monitor("back_enable", function(self, path, oval)
		set_attr(self, "back_viewFovAngle", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_distance", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_viewIsBlocked", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_dragView", "Visible", self.back_enable.enable and "true" or "false")
		set_attr(self, "back_view_offset", "Visible", self.back_enable.enable and "true" or "false")
	end);
	
	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	ViewEnable back_enable = ViewEnable(enable = true);
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK", Min: "0", Max: "180"]
	number back_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK", Min: "0"]
	number back_distance = 4;

	#摄像机偏移
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK", Alias:"MyVector3"]
	Vector3 back_view_offset = Vector3(x = 0.0, y = 0.0, z = 0.0);
	
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	ViewIsBlocked back_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.BACK"]
	bool back_dragView = true;
	
#####################前视角#####################

	monitor("front_enable", function(self, path, oval)
		set_attr(self, "front_viewFovAngle", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_distance", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_viewIsBlocked", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_dragView", "Visible", self.front_enable.enable and "true" or "false")
		set_attr(self, "front_view_offset", "Visible", self.front_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	ViewEnable front_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT", Min: "0", Max: "180"]
	number front_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT", Min: "0"]
	number front_distance = 4;

	#摄像机偏移
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT", Alias:"MyVector3"]
	Vector3 front_view_offset = Vector3(x = 0.0, y = 0.0, z = 0.0);
		
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	ViewIsBlocked front_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FRONT"]
	bool front_dragView = true;
	
#####################跟随视角#####################

	monitor("follow_enable", function(self, path, oval)
		set_attr(self, "follow_viewFovAngle", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_distance", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_viewIsBlocked", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_dragView", "Visible", self.follow_enable.enable and "true" or "false")
		set_attr(self, "follow_view_offset", "Visible", self.follow_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	ViewEnable follow_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW", Min: "0", Max: "180"]
	number follow_viewFovAngle = 75;
	
	#摄像机距离
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW", Min: "0"]
	number follow_distance = 4;

	#摄像机偏移
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW", Alias:"MyVector3"]
	Vector3 follow_view_offset = Vector3(x = 0.0, y = 0.0, z = 0.0);
	
	#视角被挡住时
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	ViewIsBlocked follow_viewIsBlocked = "PushCamera";
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FOLLOW"]
	bool follow_dragView = true;
	
#####################固定视角#####################

	monitor("fixed_enable", function(self, path, oval)
		set_attr(self, "fixed_viewFovAngle", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_viewPos", "Visible", self.fixed_enable.enable and "true" or "false")
		set_attr(self, "fixed_dragView", "Visible", self.fixed_enable.enable and "true" or "false")
	end);

	#启用
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	ViewEnable fixed_enable;
	
	#视野范围
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED", Min: "0", Max: "180"]
	number fixed_viewFovAngle = 75;
	
	#摄像机坐标
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	MapPos fixed_viewPos;
	
	#划动屏幕旋转视角
	[TAB: "TAB.VIEW", GROUP: "GAME.GROUP.FIXED"]
	bool fixed_dragView = true;

#################################################################
# 其他 OTHER
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.OTHER", TRIGGER: "GameTriggers"]
	TriggerSet triggers;

	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.OTHER", TRIGGER: "GameClientTriggers",BluePrint_Trigger_Type : "client_trigger"]
	TriggerSet triggers_client;

#####################脚本#####################
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerMainScript main_srcipt;

	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript server_srcipt = TriggerGlobalScript(type = "server");
	
	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript client_srcipt = TriggerGlobalScript(type = "client");

	[TAB: "TAB.TRIGGER", GROUP: "GAME.GROUP.SCRIPT"]
	TriggerGlobalScript common_srcipt = TriggerGlobalScript(type = "common");

#################################################################
# 隐藏 HIDE

	#变量
	hide VarTable vars;
	
	#商店
	hide CommodityPage commoditys[];
	
	#魔方商城
	hide ShopPage shops[];
	
	#显示魔方商店
	hide bool showShop;

	#启用引擎默认界面
	hide EngineDefUIEnable ui_enable;

};

#################################################################
############################## Tag ##########################
#################################################################

struct TagCfg {	
	#标签
	string tags[];
};

#################################################################
############################## Reward ##########################
#################################################################

#奖励类型
[Nonempty : "true"]
enum RewardType {
	list(function()
			local ret = {}
			table.insert(ret,{value = "Item"})
			local GameConfig = require "we.gameconfig"
			if not GameConfig:disable_block() then
				table.insert(ret,{value = "Block"})
			end
			table.insert(ret,{value = "Coin"})
			table.insert(ret,{value = "List"})
			return ret
	end);
};

struct RewardBase {	
};

struct RewardBlock : RewardBase {
	#block模板
	BlockEntry name;
	#数量
	[Integer : "true", Min : "0"]
	number count;
};

struct RewardItem : RewardBase {
	#item模板
	ItemEntry name;
	#取值范围
	[Integer: "true",Min: "0"]
	ValueRange countRange;
};

struct RewardCoin : RewardBase {
	#货币类型
	UserCurrencyEntry name;
	#数量
	[Integer : "true", Min : "0"]
	number count;
};

#随机奖励
struct RewardList : RewardBase {
	#取值范围
	[Integer: "true",Min: "0"]
	ValueRange countRange;
	#奖励表
	RewardListItem array[];
};

#随机奖励项
struct RewardListItem {
	Reward reward;
	number weight;
};

[EditorData: "true"]
struct Reward {
	attrs_updater(function(self)
		
	end);
	RewardType type = "Item";
	RewardBase base = RewardItem();

	monitor("type",function(self,path,oval)
		if self.type == "Block" then
			self.base = ctor("RewardBlock")
		elseif self.type == "Item" then
			self.base = ctor("RewardItem")
		elseif self.type == "Coin" then
			self.base = ctor("RewardCoin")
		elseif self.type == "List" then
			self.base = ctor("RewardList")
		end
	end);
};

#奖励配置
struct RewardCfg {
	[TAB: "Base", EditorData: "true"]
	Text name;

	#奖励列表
	[TAB: "Base"]
	Reward rewardArray[];
};

enum RewardEntry{
	list(function()
		local ret = {}
		local module = require "we.gamedata.module.module"
		local m = module:module("reward")
		
		for key , _ in pairs(m:list()) do
			table.insert(ret, {
				value = "myplugin/" .. key
			})
		end

		return ret
	end);
};

#################################################################
############################## Layout ##########################
#################################################################
struct LayoutHierarchy{
	string path;
};
#################################################################
############################## Trigger ##########################
#################################################################

#################################################################
struct T_Base {
	hide string action;
};

struct T_Any {
};

[Compatible:"T_IntArray,T_DoubleArray,T_BoolArray,T_EntityArray,T_ScenePosArray,T_StringArray,T_VarArray,T_Var,T_PartArray,T_MeshPartArray,T_PartOperationArray"]
struct T_Array : T_Base {
};

[ParamsArray:"Array", Compatible:"T_Var"]
struct T_IntArray : T_Array  {
	[Integer: "true"]
	number rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_DoubleArray : T_Array {
	number rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_BoolArray : T_Array {
	bool rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_EntityArray : T_Array {
	T_Entity rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_Vector3Array : T_Array {
	Vector3 rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_ScenePosArray : T_Array {
	ScenePos rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_StringArray : T_Array {
	string rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_PartArray : T_Array {
	string rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_MeshPartArray : T_Array {
	string rawval[];
};
[ParamsArray:"Array", Compatible:"T_Var"]
struct T_PartOperationArray : T_Array {
	string rawval[];
};
[ParamsArray:"Array",Compatible: "T_IntArray,T_BoolArray,T_StringArray,T_DoubleArray,T_EntityArray,T_Vector3Array,T_ScenePosArray,T_Var"]
struct T_VarArray : T_Array {
	T_Var rawval[];
};

[Compatible: "T_Int,T_Bool,T_String,T_Double,T_Vector3,T_ScenePos,T_Entity,T_Buff,T_Item,T_MapObj"]
struct T_Var : T_Base {

};

struct T_Void : T_Base {
};

struct Context {
	string key;
};

#TODO 上下文key
[Compatible: "T_String"]
struct T_Context : T_Base {
	Context rawval;
};

[Compatible: "T_Var,T_Double"]
struct T_Int : T_Base {
	[Integer: "true"]
	number rawval;
};

[Compatible: "T_Int,T_Var"]
struct T_Double : T_Base {
	number rawval;
};

[Compatible: "T_Var"]
struct T_String : T_Base {
	string rawval;
};

[Compatible: "T_Var,T_Entity,T_Object,T_Item,T_MapObj,T_Buff"]
struct T_Bool : T_Base {
	bool rawval;
};

[Compatible: "T_String"]
struct T_Text : T_Base {
	[Long : "true"]
	Text rawval;
};

[Compatible: "T_Var,T_ScenePos"]
struct T_Vector3i : T_Base {
	Vector3i rawval;
};

[Compatible: "T_Var,T_ScenePos"]
struct T_Vector3 : T_Base {
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 rawval;
};

#自定义属性中的vector2类型
struct T_Vector2 : T_Base
{
	[TAB: "Base", Alias:"MyVector2"]
	Vector2 rawval;
};


[Compatible: "T_Int,T_Double,T_Var"]
struct T_Time : T_Base {
	Time rawval;
};

struct T_Region : T_Base {
	RegionEntry rawval;
};

[Compatible: "T_Var"]
struct T_Block : T_Base {
	BlockEntry rawval;
};

struct T_BlockArray : T_Base {
	BlockArray rawval;
};

[Compatible: "T_Var"]
struct T_EntityEntry : T_Base {
	EntityEntry rawval;
};

[Compatible: "T_Var"]
struct T_BuffEntry : T_Base {
	BuffEntry rawval;
};

[Compatible: "T_Var"]
struct T_SkillEntry : T_Base {
	SkillEntry rawval;
};

[Compatible: "T_Var"]
struct T_ItemEntry : T_Base {
	ItemEntry rawval;
};

[Compatible: "T_Var"]
struct T_RewardEntry : T_Base {
	RewardEntry rawval;
};

[Compatible: "T_Var"]
struct T_ObjectTreeEntry : T_Base {
	ObjectTreeEntry rawval;
};

[Compatible: "T_Var"]
struct T_StorageEntry : T_Base {
	StorageEntry rawval;
};

struct T_Box : T_Base {
	Box rawval;
};

#entity对象
[Compatible: "T_Var,T_Object"]
struct T_Entity : T_Base {
};

struct T_RankInfo : T_Base {
};

[Compatible: "T_Var"]
struct T_Buff : T_Base {
};

[Compatible: "T_Var,T_Entity"]
struct T_Object : T_Base {
};

struct T_ObjectID : T_Base {
	number rawval;
};

[Compatible: "T_Var"]
struct T_Item : T_Base {
};

[Compatible: "T_Var"]
struct T_Missile : T_Base {
};

[Compatible: "T_Var"]
struct T_Part : T_Base {
};

[Compatible: "T_Var"]
struct T_MeshPart : T_Base {
};

[Compatible: "T_Var"]
struct T_PartOperation : T_Base {
};

[Compatible: "T_Var"]
struct T_Constraint : T_Base {
};

[Compatible: "T_Var"]
struct T_UDim2 : T_Base{
	UDim2 rawval;
};

[ParamsArray:"Array", Compatible: "T_Var"]
struct T_UDim2Array : T_Base{
	UDim2 rawval[];
};

[Compatible: "T_Var"]
struct T_UI_Anchor : T_Base {
	Anchor rawval;
};

[Nonempty : "true",integer: "true"]
enum TipType{
	"1",
	"2",
	"3",
	"4"
};

struct TipTypeCvr {
	TipType type;
};

struct T_TipType : T_Base {
	TipType rawval;
};

[Compatible: "T_Var"]
struct T_MapObj : T_Base {
};

[Compatible: "T_Var,T_MapObj,T_MapEntry"]
struct T_Map : T_Base {
	MapEntry rawval;
};

[Compatible: "T_Var,T_MapEntry",Alias:"T_Map"]
struct T_MapStr : T_Base {
	MapEntry rawval;
};

struct T_IfBranch : T_Base {
};

[Compatible: "T_Var,T_Vector3"]
struct T_ScenePos : T_Base {
	ScenePos rawval; 
};

struct T_SceneRegion : T_Base {
	SceneRegion rawval;
};

struct T_Resource_Actor : T_Base {
	Resource_Actor rawval;
};

struct T_Resource_Image : T_Base {
	Resource_CEGUITexture rawval;
};

struct T_AIData : T_Base {
};

struct Talk {
	EntityEntry npc;
	[Long : "true"]
	Text msg;
};

struct TalkList {
	Talk talk[];
};

struct T_TalkList : T_Base {
	TalkList rawval;
};

struct TriggerName{
	string value;
};

struct Option {
	Text showText;
	TriggerName triggerName;
};

struct OptionList {
	Option option[];
};

struct T_OptionList : T_Base {
	OptionList rawval;
};

[Nonempty : "true", integer: "true"]
enum Compute {
	"add",
	"sub"
};

struct T_Compute : T_Base {
	Compute rawval;
};

[Nonempty : "true"]
enum BinaryOperCompute {
	[Lang:"add"]
	"+",
	[Lang:"subtraction"]
	"-",
	[Lang:"multiplication"]
	"*",
	[Lang:"division"]
	"/",
	[Lang:"aliquot"]
	"%"
};

struct T_BinaryOperCompute : T_Base {
	BinaryOperCompute rawval;
};

struct T_Percentage : T_Base
{
	Percentage rawval;
};

[Nonempty : "true"]
enum BinaryOperBool {
	[Lang:"greater"]
	">",
	[Lang:"less"]
	"<",
	[Lang:"equal"]
	"==",
	[Lang:"notEqual"]
	"~=",
	[Lang:"notLess"]
	">=",
	[Lang:"noGreater"]
	"<="
};

struct T_BinaryOperBool : T_Base {
	BinaryOperBool rawval;
};

[Nonempty : "true"]
enum BinaryOper {
	"and",
	"or"
};

struct T_BinaryOper : T_Base {
	BinaryOper rawval;
};

#struct VarKey {
#	ActionVarType type;
#	string key;
#};

#struct T_VarKey : T_Base {
#	VarKey rawval;
#};

[EnumText : "Value", EnumUpdate : "true"]
enum ObjectVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("entity")
		
		for key , v in pairs(vars) do
			table.insert(ret, {
				value = v
			})
		end

		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum UiVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("ui")
		
		for key , v in pairs(vars) do
			table.insert(ret, {
				value = v
			})
		end

		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum GlobalVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("global")
		
		for key , v in pairs(vars) do
				table.insert(ret, {
					value = v
				})
		end
		
		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum ArrayGlobalVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("global")
		for key , v in pairs(vars) do
			if var:var_struct_type("global",v) == "array" then
				table.insert(ret, { value = v})
			end
		end
		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum ArrayObjectVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("entity")
		for key , v in pairs(vars) do
			if var:var_struct_type("entity",v) == "array" then
				table.insert(ret, { value = v})
			end
		end
		return ret
	end);
};

[EnumText : "Value", EnumUpdate : "true"]
enum ArrayUiVar_Selector {
	list(function()
		local ret = {}
		local var = require "we.gamedata.var"
		local vars = var:get_vars("ui")
		for key , v in pairs(vars) do
			if var:var_struct_type("ui",v) == "array" then
				table.insert(ret, { value = v})
			end
		end
		return ret
	end);
};

struct T_ObjectVar : T_Base {
	ObjectVar_Selector rawval;
};

struct T_GlobalVar : T_Base {
	GlobalVar_Selector rawval;
};

struct T_UiVar : T_Base{
	UiVar_Selector rawval;
};

struct T_ArrayObjectVar : T_Base {
	ArrayObjectVar_Selector rawval;
};

struct T_ArrayGlobalVar : T_Base {
	ArrayGlobalVar_Selector rawval;
};

struct T_ArrayUiVar : T_Base {
	ArrayUiVar_Selector rawval;
};

enum Condition {
	"score"
};

struct T_Condition : T_Base {
	Condition rawval;
};

[Nonempty : "true"]
enum Operator {
	"Sin",
	"Cos",
	"Tan"
};

struct T_Operator : T_Base {
	Operator rawval;
};

[Nonempty : "true"]
enum ShapeId {
	"1",	# cube
	"2",	# sphere
	"3",	# sylinder
	"4"		# cone
};

struct T_ShapeId : T_Base {
	ShapeId rawval;
};

struct T_Color : T_Base {
	Color rawval;
};

struct T_UIBluePrintColor : T_Base {
	UIBluePrintColor rawval;
};

struct T_PartTexture : T_Base {
	PartTexture rawval;
};

[Compatible : "T_Var,T_Layout"]
struct T_Widget : T_Base{
	
};

[Compatible : "T_Var"]
struct T_Resource_Effect : T_Base{
	Resource_Effect rawval;
};

[ParamsArray:"Array", Compatible : "T_Var,T_LayoutArray"]
struct T_WidgetArray : T_Base{
	T_Widget rawval[];
};

[Compatible : "T_Var"]
struct T_Layout : T_Base{
	
};

[ParamsArray:"Array", Compatible : "T_Var"]
struct T_LayoutArray : T_Base{
	T_Layout rawval[];
};

[Compatible : "T_Var"]
struct T_Res_Layout : T_Base{
	Resource_Layout rawval;
};

struct T_Widget_Hierarchy : T_Base{
	LayoutHierarchy rawval;
};

#################################################################
########################### Action ##############################
#################################################################
enum Enum_Action {
	list(function()
		local Action = require "we.gamedata.action"
		return Action:list()
	end);
};

enum ActionVarType {
	"global",
	"entity",
	"item",
	"team",
	"map",
	"region"
};

struct ActionParam {
	string key;
	T_Base value;
	bool must = false;
};

struct ActionProtoParam : ActionParam{

	attrs_updater(function(self, path, oval)
		local Meta = require "we.gamedata.meta.meta"
		local meta = Meta:meta("VarType")
		local type = meta:attribute("Type", self.param_type)
	end);

	monitor("data_type", function(self, path, oval)
		local Meta = require "we.gamedata.meta.meta"
		local meta = Meta:meta("VarType")
		local type = meta:attribute("Type", self.data_type)
		self.value = ctor(self.data_type)
	end);

	string data_type;
};

struct Component_Base {
};

struct Component_Var : Component_Base {
	ActionVarType type;
	string key;
};

struct Component_Params : Component_Base {
	ActionParam params[];
};

struct Component_Context : Component_Base {
	string key;
};

struct Component_Function_Param : Component_Base {
	string key;
};

struct Component_Proto_Param : Component_Base {
	string key;
};

struct Component_Proto_Params : Component_Base {
	string proto_name;
	string proto_id;
	string proto_type;
	ActionProtoParam params[];
};

struct Component_Proto_Params_To_Client:Component_Proto_Params{
	ActionProtoParam params_default[];
};

struct Component_Sequence : Component_Base {
	T_Base children[];
};

struct Component_Condition : Component_Base {
	T_IfBranch children[];
};

struct Component_Protocol : Component_Base {
	T_Base children[];
	string desc = "ProtocolNode";
	string protocol_name;
};

struct ScriptParam : T_Base {
    hide string param_name;
};

struct Component_Script : Component_Base {
	string desc = "ScriptableNode";
	string script_name;
    ScriptParam children[];
};


############################### Sys #############################
struct Node_Base {
	Uuid id;
	Vector2 pos;
};

struct ImportPort {
	Text name;
	string id;
	ActionParam param;
	T_Base children;
};

struct Node_Imports : Node_Base {
	ImportPort ports[];
};

struct ExportPort {
	Text name;
	string id;
	string type;
	T_Base value;
};

struct Node_Exports : Node_Base {
	ExportPort ports[];
};

struct Node_CollapseGraph : Node_Base {
	Text name;
	Node_Exports export_node;
	Node_Imports import_node;
	Action_Base actions[];
};

############################### Action_Base #############################
struct Action_Base : Node_Base {
	string name;
	string type;			# 返回类型
};

############################### Action_Protocol #############################
[Catalog: "ActionCatalog_Protocol",HideNameLabel: "true",BluePrint_Action_Type: "client_action"]
struct Action_Protocol_SendToServer: Action_Base {
	base(name = "SendToServer", type = "T_Void", pos = Vector2(x = 400, y = 300));
	Component_Base components[] = {				
		Component_Proto_Params(params = {
		})
	};
};

[Catalog: "ActionCatalog_Protocol",HideNameLabel: "true"]
struct Action_Protocol_SendToClient : Action_Base {
	base(name = "SendToClient", type = "T_Void", pos = Vector2(x = 400, y = 300));
	Component_Base components[] = {				
		Component_Proto_Params_To_Client(
			params_default = {ActionProtoParam(key = "player", value = T_Entity(),must = true)},
			params = {}
		)
	};
};

############################### Action_Entity #############################

[Catalog: "ActionCatalog_Entity"]
struct Action_SetHp : Action_Base {
	base(name = "SetHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "hp", value = T_Int(rawval = 1),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_Damage : Action_Base {
	base(name = "Damage", type = "T_Void");
	attrs_updater(function(self)
		local damage = self.components[1].params[2].value
		set_attr(damage, "rawval","Min", "0")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "damage", value = T_Int(),must = true),
			ActionParam(key = "from", value = T_Entity())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityHp : Action_Base {
	base(name = "AddEntityHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_RecoverFullHp : Action_Base {
	base(name = "RecoverFullHp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_KillEntity : Action_Base {
	base(name = "KillEntity", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "from", value = T_Entity())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_ReviveEntity : Action_Base {
	base(name = "ReviveEntity", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityPosition : Action_Base {
	base(name = "SetEntityPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityRebirthPosition : Action_Base {
	base(name = "SetEntityRebirthPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityHeight : Action_Base {
	base(name = "SetEntityHeight", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "height", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_MoveAllPlayers : Action_Base {
	base(name = "MoveAllPlayers", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityBuff : Action_Base {
	base(name = "AddEntityBuff", type = "T_Void");
	attrs_updater(function(self)
		local buffTime = self.components[1].params[3].value
		local limit = self.components[1].params[3].value
		local buff_time = self.components[1].params[4].value

		set_attr(buffTime,"rawval","Max","1000000000")
		set_attr(limit, "rawval", "HideImport", "true")
		set_attr(buff_time, "rawval", "Visible", limit.rawval and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_BuffEntry(),must = true),
			ActionParam(key = "limit", value = T_Bool(rawval = true)),
			ActionParam(key = "buffTime", value = T_Time(),must = true)
		})
	};
	monitor("components", function(self,path,oval)
		local limit = self.components[1].params[3].value
		local buff_time = self.components[1].params[4].value
		set_attr(buff_time, "rawval", "Visible", limit.rawval and "true" or "false")
	end);
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_RemoveEntityBuff : Action_Base {
#	base(name = "RemoveEntityBuff", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true),
#			ActionParam(key = "buff", value = T_Buff(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityScore : Action_Base {
	base(name = "SetEntityScore", type = "T_Int");
	attrs_updater(function(self)
		set_attr(self.components[1].params[2].value, "rawval", "Min", "0")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "val", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityScore : Action_Base {
	base(name = "AddEntityScore", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "add", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true",Deprecated:"true"]
struct Action_EntityDieDrop : Action_Base {
	base(name = "EntityDieDrop", type = "T_Item");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_AddEntityVp : Action_Base {
	base(name = "AddEntityVp", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_AddEntityExp : Action_Base {
#	base(name = "AddEntityExp", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true),
#			ActionParam(key = "exp", value = T_Int())
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_RewardMechanism : Action_Base {
	base(name = "RewardMechanism", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "path", value = T_RewardEntry(),must = true),
			#ActionParam(key = "check", value = T_Bool())
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_SetPlayerGameId : Action_Base {
#	base(name = "SetPlayerGameId", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity"]
struct Action_ChangeEntityActor : Action_Base {
	base(name = "ChangeEntityActor", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_Resource_Actor(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_CreateNpc : Action_Base {
	base(name = "CreateNpc", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true),
			ActionParam(key = "name", value = T_String()),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "enableAI", value = T_Bool()),
#			ActionParam(key = "aiData", value = T_AIData()),
			ActionParam(key = "owner", value = T_Entity()),
			ActionParam(key = "level", value = T_Int()),
#			ActionParam(key = "camp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_CreateNpcInArea : Action_Base {
	base(name = "CreateNpcInArea", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "minNumber", value = T_Int(),must = true),
			ActionParam(key = "maxNumber", value = T_Int(),must = true),
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true),
			ActionParam(key = "name", value = T_String()),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "enableAI", value = T_Bool()),
#			ActionParam(key = "aiData", value = T_AIData()),
			ActionParam(key = "owner", value = T_Entity()),
			ActionParam(key = "level", value = T_Int()),
#			ActionParam(key = "camp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_setPlayCameraYawToAttacker : Action_Base {
	base(name = "setPlayCameraYawToAttacker", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "target", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllEntities : Action_Base {
	base(name = "GetAllEntities", type = "T_EntityArray");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntitiesByFullName : Action_Base {
	base(name = "GetEntitiesByFullName", type = "T_EntityArray");
	attrs_updater(function(self)
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "fullName", value = T_EntityEntry(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_ShowPersonalInformations : Action_Base {
#	base(name = "ShowPersonalInformations", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "target", value = T_Entity(),must = true),
#			ActionParam(key = "player", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityCurHp : Action_Base {
	base(name = "GetEntityCurHp", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetMaxHp : Action_Base {
	base(name = "GetEntityMaxHp", type = "T_Int");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityScore : Action_Base {
	base(name = "GetEntityScore", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObjectDistance : Action_Base {
	base(name = "GetObjectDistance", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "obj1", value = T_Entity(),must = true),
			ActionParam(key = "obj2", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllPlayersCount : Action_Base {
	base(name = "GetAllPlayersCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetAllPlayers : Action_Base {
	base(name = "GetAllPlayers", type = "T_EntityArray");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetSurvivePlayersCount : Action_Base {
	base(name = "GetSurvivePlayersCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetPlayerKillCount : Action_Base {
	base(name = "GetPlayerKillCount", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true",Deprecated:"true"]
struct Action_GetEntityMovingStyle : Action_Base {
	base(name = "GetEntityMovingStyle", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityYaw : Action_Base {
	base(name = "GetEntityYaw", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityCurVp : Action_Base {
	base(name = "GetEntityCurVp", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityLevel : Action_Base {
	base(name = "GetEntityLevel", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};


[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityHeight : Action_Base {
	base(name = "GetEntityHeight", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObjectID : Action_Base {
	base(name = "GetObjectID", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "object", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityPosition : Action_Base {
	base(name = "GetEntityPosition", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetRebirthPos : Action_Base {
	base(name = "GetRebirthPos", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityStartPos : Action_Base {
	base(name = "GetEntityStartPos", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetObject : Action_Base {
	base(name = "GetObject", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "objID", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IsPlayer : Action_Base {
	base(name = "IsPlayer", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IfEntityInArea : Action_Base {
	base(name = "IfEntityInArea", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_IsEntityAlive : Action_Base {
	base(name = "IsEntityAlive", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Entity"]
#struct Action_AcceptTask : Action_Base {
#	base(name = "AcceptTask", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "player", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry()),
#			ActionParam(key = "show", value = T_Bool())
#		})
#	};
#};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetEntityName : Action_Base {
	base(name = "GetEntityName", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity", RValue: "true"]
struct Action_GetOwner : Action_Base {
	base(name = "GetOwner", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_SetEntityYaw : Action_Base {
	base(name = "SetEntityYaw", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rotationYaw", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Entity"]
struct Action_RemoveBuffByFullName : Action_Base {
	base(name = "RemoveBuffByFullName", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "toTeam", value = T_Bool()),
			ActionParam(key = "buff", value = T_BuffEntry(),must = true)
		})
	};
};

############################### Action_Part #############################
[Catalog: "ActionCatalog_Part"]
struct Action_SetPartPosition : Action_Base {
	base(name = "SetPartPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartPosition : Action_Base {
	base(name = "GetPartPosition", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Part"]
#struct Action_SetPartSelectable : Action_Base {
#	base(name = "SetPartSelectable", type = "T_Bool");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "part", value = T_Part(),must = true),
#			ActionParam(key = "selectable", value = T_Bool(),must = true)
#		})
#	};
#};

#[Catalog: "ActionCatalog_Part"]
#struct Action_SetPartNeedSync : Action_Base {
#	base(name = "SetPartNeedSync", type = "T_Bool");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "part", value = T_Part(),must = true),
#			ActionParam(key = "needSync", value = T_Bool(),must = true)
#		})
#	};
#};

#[Catalog: "ActionCatalog_Part"]
#struct Action_SetPartBloom : Action_Base {
#	base(name = "SetPartBloom", type = "T_Bool");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "part", value = T_Part(),must = true),
#			ActionParam(key = "bloom", value = T_Bool(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Part"]
struct Action_SetPartRotation : Action_Base {
	base(name = "SetPartRotation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "pitch", value = T_Int(),must = true),
			ActionParam(key = "yaw", value = T_Int(),must = true),
			ActionParam(key = "roll", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartRotation : Action_Base {
	base(name = "GetPartRotation", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part"]
struct Action_SetPartSize : Action_Base {
	base(name = "SetPartSize", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "size", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartSize : Action_Base {
	base(name = "GetPartSize", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartFacade"]
struct Action_SetPartShape : Action_Base {
	base(name = "SetPartShape", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "shapeId", value = T_ShapeId(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartFacade"]
struct Action_SetPartAlpha : Action_Base {
	base(name = "SetPartAlpha", type = "T_Void");

	attrs_updater(function(self)
		local alpha = self.components[1].params[2].value
		set_attr(alpha, "rawval", "Min", "0")
		set_attr(alpha, "rawval", "Max", "1")
		set_attr(alpha, "rawval", "Step", "0.1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "alpha", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartFacade"]
struct Action_SetPartColor : Action_Base {
	base(name = "SetPartColor", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "color", value = T_Color(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartFacade"]
struct Action_SetPartMaterialTexture : Action_Base {
	base(name = "SetPartMaterialTexture", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "material", value = T_PartTexture(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartFacade"]
struct Action_SetPartMaterialOffset : Action_Base {
	base(name = "SetPartMaterialOffset", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "ux", value = T_Double(),must = true),
			ActionParam(key = "vy", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartPhysics"]
struct Action_SetPartLineVelocity : Action_Base {
	base(name = "SetPartLineVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "lv", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartLineVelocity : Action_Base {
	base(name = "GetPartLineVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartPhysics"]
struct Action_SetPartAngleVelocity : Action_Base {
	base(name = "SetPartAngleVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "av", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartAngleVelocity : Action_Base {
	base(name = "GetPartAngleVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartPhysics"]
struct Action_SetPartDensity : Action_Base {
	base(name = "SetPartDensity", type = "T_Void");
	attrs_updater(function(self)
		local density = self.components[1].params[2].value
		set_attr(density, "rawval", "Min", "0.01")
		set_attr(density, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "density", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartDensity : Action_Base {
	base(name = "GetPartDensity", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartPhysics"]
struct Action_SetPartRestitution : Action_Base {
	base(name = "SetPartRestitution", type = "T_Void");
	attrs_updater(function(self)
		local rst = self.components[1].params[2].value
		set_attr(rst, "rawval", "Min", "0")
		set_attr(rst, "rawval", "Max", "1")
		set_attr(rst, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "rst", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartRestitution : Action_Base {
	base(name = "GetPartRestitution", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/PartPhysics"]
struct Action_SetPartFriction : Action_Base {
	base(name = "SetPartFriction", type = "T_Void");
	attrs_updater(function(self)
		local friction = self.components[1].params[2].value
		set_attr(friction, "rawval", "Min", "0")
		set_attr(friction, "rawval", "Max", "1")
		set_attr(friction, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "friction", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartFriction : Action_Base {
	base(name = "GetPartFriction", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part"]
struct Action_SetPartUseCollide : Action_Base {
	base(name = "SetPartUseCollide", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "useCollide", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part"]
struct Action_SetPartUseGravity : Action_Base {
	base(name = "SetPartUseGravity", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "useGravity", value = T_Bool(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Part"]
#struct Action_SetPartStaticObject : Action_Base {
#	base(name = "SetPartStaticObject", type = "T_Bool");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "part", value = T_Part(),must = true),
#			ActionParam(key = "staticObject", value = T_Bool(),must = true)
#		})
#	};
#};
[Catalog: "ActionCatalog_Part"]
struct Action_SetPartConstraintEnable : Action_Base {
	base(name = "SetPartConstraintEnable", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "cst", value = T_Constraint(),must = true),
			ActionParam(key = "val", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part", RValue: "true"]
struct Action_GetPartConstraintByName : Action_Base {
	base(name = "GetPartConstraintByName", type = "T_Constraint");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true),
			ActionParam(key = "name", value = T_String(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/CreatePart"]
struct Action_CreatePart : Action_Base {
	base(name = "CreatePart", type = "T_Void");
	attrs_updater(function(self)
		local size = self.components[1].params[6].value
		set_attr(size.rawval, "x", "Min", "0.01")
		set_attr(size.rawval, "y", "Min", "0.01")
		set_attr(size.rawval, "z", "Min", "0.01")
	end);
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_String(),must = true),
			ActionParam(key = "shapeId", value = T_ShapeId(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "color", value = T_Color(),must = true),
			ActionParam(key = "material", value = T_PartTexture(),must = true),
			ActionParam(key = "size", value = T_Vector3(rawval = Vector3(x = 1, y = 1, z = 1)),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "pitch", value = T_Int(),must = true),
			ActionParam(key = "yaw", value = T_Int(),must = true),
			ActionParam(key = "roll", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Part/CreatePart"]
struct Action_CreatePartByPartStorage : Action_Base {
	base(name = "CreatePartByPartStorage", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
		    ActionParam(key = "id", value = T_StorageEntry(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
		})
	};
};

[Catalog: "ActionCatalog_Part"]
struct Action_DestoryPart : Action_Base {
	base(name = "DestoryPart", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_Part(),must = true)
		})
	};
};

############################### Action_MeshPart #############################
[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartPosition : Action_Base {
	base(name = "SetPartPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartPosition : Action_Base {
	base(name = "GetPartPosition", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartRotation : Action_Base {
	base(name = "SetPartRotation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "pitch", value = T_Int(),must = true),
			ActionParam(key = "yaw", value = T_Int(),must = true),
			ActionParam(key = "roll", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartRotation : Action_Base {
	base(name = "GetPartRotation", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartSize : Action_Base {
	base(name = "SetPartSize", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "size", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartSize : Action_Base {
	base(name = "GetPartSize", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartFacade"]
struct Action_SetMeshPartAlpha : Action_Base {
	base(name = "SetPartAlpha", type = "T_Void");

	attrs_updater(function(self)
		local alpha = self.components[1].params[2].value
		set_attr(alpha, "rawval", "Min", "0")
		set_attr(alpha, "rawval", "Max", "1")
		set_attr(alpha, "rawval", "Step", "0.1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "alpha", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartFacade"]
struct Action_SetMeshPartMaterialTexture : Action_Base {
	base(name = "SetPartMaterialTexture", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "material", value = T_PartTexture(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartPhysics"]
struct Action_SetMeshPartLineVelocity : Action_Base {
	base(name = "SetPartLineVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "lv", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartLineVelocity : Action_Base {
	base(name = "GetPartLineVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartPhysics"]
struct Action_SetMeshPartAngleVelocity : Action_Base {
	base(name = "SetPartAngleVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "av", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartAngleVelocity : Action_Base {
	base(name = "GetPartAngleVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartPhysics"]
struct Action_SetMeshPartDensity : Action_Base {
	base(name = "SetPartDensity", type = "T_Void");
	attrs_updater(function(self)
		local density = self.components[1].params[2].value
		set_attr(density, "rawval", "Min", "0.01")
		set_attr(density, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "density", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartDensity : Action_Base {
	base(name = "GetPartDensity", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartPhysics"]
struct Action_SetMeshPartRestitution : Action_Base {
	base(name = "SetPartRestitution", type = "T_Void");
	attrs_updater(function(self)
		local rst = self.components[1].params[2].value
		set_attr(rst, "rawval", "Min", "0")
		set_attr(rst, "rawval", "Max", "1")
		set_attr(rst, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "rst", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartRestitution : Action_Base {
	base(name = "GetPartRestitution", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart/MeshPartPhysics"]
struct Action_SetMeshPartFriction : Action_Base {
	base(name = "SetPartFriction", type = "T_Void");
	attrs_updater(function(self)
		local friction = self.components[1].params[2].value
		set_attr(friction, "rawval", "Min", "0")
		set_attr(friction, "rawval", "Max", "1")
		set_attr(friction, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "friction", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartFriction : Action_Base {
	base(name = "GetPartFriction", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartUseCollide : Action_Base {
	base(name = "SetPartUseCollide", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "useCollide", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartUseGravity : Action_Base {
	base(name = "SetPartUseGravity", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "useGravity", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_SetMeshPartConstraintEnable : Action_Base {
	base(name = "SetPartConstraintEnable", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "cst", value = T_Constraint(),must = true),
			ActionParam(key = "val", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart", RValue: "true"]
struct Action_GetMeshPartConstraintByName : Action_Base {
	base(name = "GetPartConstraintByName", type = "T_Constraint");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true),
			ActionParam(key = "name", value = T_String(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_CreateMeshPart : Action_Base {
	base(name = "CreatePart", type = "T_Void");
	attrs_updater(function(self)
		local size = self.components[1].params[6].value
		set_attr(size.rawval, "x", "Min", "0.01")
		set_attr(size.rawval, "y", "Min", "0.01")
		set_attr(size.rawval, "z", "Min", "0.01")
	end);
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_String(),must = true),
			ActionParam(key = "shapeId", value = T_ShapeId(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "color", value = T_Color(),must = true),
			ActionParam(key = "material", value = T_PartTexture(),must = true),
			ActionParam(key = "size", value = T_Vector3(rawval = Vector3(x = 1, y = 1, z = 1)),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "pitch", value = T_Int(),must = true),
			ActionParam(key = "yaw", value = T_Int(),must = true),
			ActionParam(key = "roll", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_MeshPart"]
struct Action_DestoryMeshPart : Action_Base {
	base(name = "DestoryPart", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_MeshPart(),must = true)
		})
	};
};

############################### Action_PartOperation #############################
[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationPosition : Action_Base {
	base(name = "SetPartPosition", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationPosition : Action_Base {
	base(name = "GetPartPosition", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationRotation : Action_Base {
	base(name = "SetPartRotation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "pitch", value = T_Int(),must = true),
			ActionParam(key = "yaw", value = T_Int(),must = true),
			ActionParam(key = "roll", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationRotation : Action_Base {
	base(name = "GetPartRotation", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationSize : Action_Base {
	base(name = "SetPartSize", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "size", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationSize : Action_Base {
	base(name = "GetPartSize", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationFacade"]
struct Action_SetPartOperationAlpha : Action_Base {
	base(name = "SetPartAlpha", type = "T_Void");

	attrs_updater(function(self)
		local alpha = self.components[1].params[2].value
		set_attr(alpha, "rawval", "Min", "0")
		set_attr(alpha, "rawval", "Max", "1")
		set_attr(alpha, "rawval", "Step", "0.1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "alpha", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationFacade"]
struct Action_SetPartOperationColor : Action_Base {
	base(name = "SetPartColor", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "color", value = T_Color(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationFacade"]
struct Action_SetPartOperationMaterialTexture : Action_Base {
	base(name = "SetPartMaterialTexture", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "material", value = T_PartTexture(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationFacade"]
struct Action_SetPartOperationMaterialOffset : Action_Base {
	base(name = "SetPartMaterialOffset", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "ux", value = T_Double(),must = true),
			ActionParam(key = "vy", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationPhysics"]
struct Action_SetPartOperationLineVelocity : Action_Base {
	base(name = "SetPartLineVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "lv", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationLineVelocity : Action_Base {
	base(name = "GetPartLineVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationPhysics"]
struct Action_SetPartOperationAngleVelocity : Action_Base {
	base(name = "SetPartAngleVelocity", type = "T_Void");
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "av", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationAngleVelocity : Action_Base {
	base(name = "GetPartAngleVelocity", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationPhysics"]
struct Action_SetPartOperationDensity : Action_Base {
	base(name = "SetPartDensity", type = "T_Void");
	attrs_updater(function(self)
		local density = self.components[1].params[2].value
		set_attr(density, "rawval", "Min", "0.01")
		set_attr(density, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "density", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationDensity : Action_Base {
	base(name = "GetPartDensity", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationPhysics"]
struct Action_SetPartOperationRestitution : Action_Base {
	base(name = "SetPartRestitution", type = "T_Void");
	attrs_updater(function(self)
		local rst = self.components[1].params[2].value
		set_attr(rst, "rawval", "Min", "0")
		set_attr(rst, "rawval", "Max", "1")
		set_attr(rst, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "rst", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationRestitution : Action_Base {
	base(name = "GetPartRestitution", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation/PartOperationPhysics"]
struct Action_SetPartOperationFriction : Action_Base {
	base(name = "SetPartFriction", type = "T_Void");
	attrs_updater(function(self)
		local friction = self.components[1].params[2].value
		set_attr(friction, "rawval", "Min", "0")
		set_attr(friction, "rawval", "Max", "1")
		set_attr(friction, "rawval", "Step", "0.01")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "friction", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationFriction : Action_Base {
	base(name = "GetPartFriction", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationUseCollide : Action_Base {
	base(name = "SetPartUseCollide", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "useCollide", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationUseGravity : Action_Base {
	base(name = "SetPartUseGravity", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "useGravity", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_SetPartOperationConstraintEnable : Action_Base {
	base(name = "SetPartConstraintEnable", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "cst", value = T_Constraint(),must = true),
			ActionParam(key = "val", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation", RValue: "true"]
struct Action_GetPartOperationConstraintByName : Action_Base {
	base(name = "GetPartConstraintByName", type = "T_Constraint");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true),
			ActionParam(key = "name", value = T_String(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_PartOperation"]
struct Action_DestoryPartOperation : Action_Base {
	base(name = "DestoryPart", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "part", value = T_PartOperation(),must = true)
		})
	};
};

############################### Action_Light #############################
[Catalog: "ActionCatalog_Light"]
struct Action_SetLight : Action_Base {
	base(name = "SetLight", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[1].value
		set_attr(value, "rawval", "Filters", "Light")
		set_attr(value, "rawval", "HideImport", "true")
		set_attr(self.components[1].params[2].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "id", value = T_ObjectTreeEntry(),must = true),
			ActionParam(key = "active", value = T_Bool()),
		})
	};
};


############################### Action_Block #############################
[Catalog: "ActionCatalog_Block"]
struct Action_CreateBlock : Action_Base {
	base(name = "CreateBlock", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_RemoveBlock : Action_Base {
	base(name = "RemoveBlock", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "block", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_CreateRandomBlocksInRegion : Action_Base {
	base(name = "CreateRandomBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "creatnum", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_CreateRandomBlocksInRegionNoRepeat : Action_Base {
	base(name = "CreateRandomBlocksInRegionNoRepeat", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true),
			ActionParam(key = "createNum", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_ReplaceBlockInRegionSingle : Action_Base {
	base(name = "ReplaceBlockInRegionSingle", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "sourceBlock", value = T_Block(),must = true),
			ActionParam(key = "destBlock", value = T_Block(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_FillBlocksInRegion : Action_Base {
	base(name = "FillBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "block", value = T_Block(),must = true),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_RemoveBlocksInRegion : Action_Base {
	base(name = "RemoveBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "blockArray", value = T_BlockArray()),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_ClearBlocksInRegion : Action_Base {
	base(name = "ClearBlocksInRegion", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "blockArray", value = T_BlockArray()),
			#ActionParam(key = "regionKey", value = T_Region()),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Block"]
#struct Action_DoDamgeToBlock : Action_Base {
#	base(name = "DoDamgeToBlock", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "pos", value = T_ScenePos()),
#			ActionParam(key = "damage", value = T_Int()),
#			ActionParam(key = "owner", value = T_Entity(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Block", RValue: "true"]
struct Action_GetBlockFullName : Action_Base {
	base(name = "GetBlockFullName", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Block"]
struct Action_AddBlockItem : Action_Base {
	base(name = "AddBlockItem", type = "T_Void");

	attrs_updater(function(self)
		local vnode = self.components[1].params[3].value
		set_attr(vnode, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "count", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Block", RValue: "true"]
struct Action_FindFrontBlock : Action_Base {
	base(name = "FindFrontBlock", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "block", value = T_Block(),must = true),
			ActionParam(key = "distance", value = T_Int(),must = true),
			ActionParam(key = "deep", value = T_Int(),must = true)
		})
	};
};

############################### Action_Item #############################

[Catalog: "ActionCatalog_Item"]
struct Action_AddItem : Action_Base {
	base(name = "AddItem", type = "T_Void");

	attrs_updater(function(self)
		local vnode = self.components[1].params[3].value
		set_attr(vnode, "rawval", "Min", "1")
		set_attr(vnode, "rawval", "Integer", "true")
		--TODO chenzhang 应该在数据升级中删除这个字段reason
		--但是这个迭代没有需要数据升级的地方,等下个迭代数据升级顺带出去
		set_attr(self.components[1].params, "4", "Hide", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_ItemEntry(),must = true),
			ActionParam(key = "count", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Item"]
struct Action_ConsumeItem2 : Action_Base {
	base(name = "ConsumeItem2", type = "T_Bool");
	attrs_updater(function(self)
		set_attr(self.components[1].params, "4", "Hide", "true")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "item", value = T_ItemEntry(),must = true),
			ActionParam(key = "num", value = T_Int(),must = true),
			ActionParam(key = "reason", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Item"]
struct Action_SpawnItemToWorld : Action_Base {
	base(name = "SpawnItemToWorld", type = "T_Void");

	attrs_updater(function(self)
		local key = self.components[1].params[6].key
		if key ~= "params_control" then
			return
		end
		local params_control = self.components[1].params[6].value.rawval
		local pitch = self.components[1].params[7].value
		local yaw = self.components[1].params[8].value
		set_attr(pitch, "rawval", "Visible", params_control and "false" or "true")
		set_attr(yaw, "rawval", "Visible", params_control and "false" or "true")
		set_attr(self.components[1].params[6].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "fullName", value = T_ItemEntry(),must = true),
			ActionParam(key = "count", value = T_Int(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "time", value = T_Time(),must = true),
			ActionParam(key = "params_control", value = T_Bool()),
			ActionParam(key = "pitch", value = T_Int()),
			ActionParam(key = "yaw", value = T_Int())
		})
	};

	monitor("components", function(self,path,oval)
		local key = self.components[1].params[6].key
		if path[4] ~= 6 or key ~= "params_control" then
			return
		end
		local params_control = self.components[1].params[6].value.rawval
		local pitch = self.components[1].params[7].value
		local yaw = self.components[1].params[8].value
		set_attr(pitch, "rawval", "Visible", params_control and "false" or "true")
		set_attr(yaw, "rawval", "Visible", params_control and "false" or "true")
	end);
};

############################### Action_Skill #############################

[Catalog: "ActionCatalog_Skill"]
struct Action_AddSkill : Action_Base {
	base(name = "AddSkill", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Skill"]
struct Action_RemoveSkill : Action_Base {
	base(name = "RemoveSkill", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Skill"]
#struct Action_LearnSkill : Action_Base {
#	base(name = "LearnSkill", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry())
#		})
#	};
#};

#[Catalog: "ActionCatalog_Skill"]
#struct Action_ForgetSkill : Action_Base {
#	base(name = "ForgetSkill", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "name", value = T_SkillEntry())
#		})
#	};
#};

[Catalog: "ActionCatalog_Skill"]
struct Action_AddSkillToAllPlayers : Action_Base {
	base(name = "AddSkillToAllPlayers", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_SkillEntry(),must = true)
		})
	};
};

############################### Action_AI #############################
[Catalog: "ActionCatalog_AI"]
struct Action_StartAI : Action_Base {
	base(name = "StartAI", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_AI"]
struct Action_StopAI : Action_Base {
	base(name = "StopAI", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_AI"]
#struct Action_EnableAITargetPos : Action_Base {
#	base(name = "EnableAITargetPos", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "enable", value = T_Bool())
#		})
#	};
#};

############################### Action_UI #############################

[Catalog: "ActionCatalog_UI"]
struct Action_SetHeadText : Action_Base {
	base(name = "SetHeadText", type = "T_Void");

	attrs_updater(function(self)
		local x_vnode = self.components[1].params[2].value
		local y_vnode = self.components[1].params[3].value
		set_attr(x_vnode, "rawval", "Min", "-2")
		set_attr(x_vnode, "rawval", "Max", "2")
		set_attr(y_vnode, "rawval", "Min", "-3")
		set_attr(y_vnode, "rawval", "Max", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "x", value = T_Int()),
			ActionParam(key = "y", value = T_Int()),
			ActionParam(key = "headText", value = T_Text())
		})
	};
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_SetDamageText : Action_Base {
#	base(name = "SetDamageText", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "text", value = T_Text())
#		})
#	};
#};

#[Catalog: "ActionCatalog_UI"]
#struct Action_ShowCountDown : Action_Base {
#	base(name = "ShowCountDown", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "entity", value = T_Entity()),
#			ActionParam(key = "time", value = T_Time()),
#			ActionParam(key = "flag", value = T_Bool())
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowTip : Action_Base {
	base(name = "ShowTip", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "tipType", value = T_TipType(),must = true),
			ActionParam(key = "textKey", value = T_Text()),
			ActionParam(key = "keepTime", value = T_Time(),must = true)
##			ActionParam(key = "textP1", value = T_Text()),
##			ActionParam(key = "textP2", value = T_Text()),
##			ActionParam(key = "textP3", value = T_Text())
		})
	};
};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowShop : Action_Base{
	base(name = "ShowShop", type = "T_Void");
	attrs_updater(function(self)
		set_attr(self.components[1].params, "2", "Hide", "true")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "showType", value = T_String( rawval = "shop"))
		})
	};
	
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_SendGameSettlement : Action_Base {
#	base(name = "SendGameSettlement", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "condition", value = T_Condition(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_ShowSystemChat : Action_Base {
	base(name = "ShowSystemChat", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "key", value = T_Text())
		})
	};
};

#[Catalog: "ActionCatalog_UI"]
#struct Action_ShowNumberEffect : Action_Base {
#	base(name = "ShowNumberEffect", type = "T_Void");

#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "player", value = T_Entity()),
#			ActionParam(key = "pos", value = T_ScenePos()),
#			ActionParam(key = "number", value = T_Int())
#		})
#	};
#};

[Catalog: "ActionCatalog_UI"]
struct Action_OpenConversation : Action_Base {
	base(name = "OpenConversation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "talkList", value = T_TalkList(),must = true),
			ActionParam(key = "optionList", value = T_OptionList()),
			ActionParam(key = "optionNpc", value = T_EntityEntry(),must = true)
		})
	};
};
##控件通用
#创建界面
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_CreateLayout : Action_Base{
	base(name = "CreateWindow", type = "T_Layout");

	attrs_updater(function(self)
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);	

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "res", value = T_Res_Layout(),must = true),
			ActionParam(key = "name", value = T_String())
		})
	};
};

#销毁界面或控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_DestoryWidget : Action_Base{
	base(name = "DestroyWidget", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
		})
	};
};

#界面是否已销毁
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsWidgetDestoryed : Action_Base{
	base(name = "IsDestoryWidget", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
		})
	};
};

#根据路径获取控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWidgetByHierarchy : Action_Base{
	base(name = "GetWidgetByHierarchy", type = "T_Widget");

	attrs_updater(function(self)
		set_attr(self.components[1].params[2].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Layout(),must = true),
			ActionParam(key = "hierarchy", value = T_Widget_Hierarchy(),must = true),	
		})
	};
};

#根据名字获取子控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetChildWidgetByName : Action_Base{
	base(name = "GetChildWidgetByName", type = "T_Widget");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "name", value = T_String(),must = true),	
		})
	};
};

#根据名字获取界面
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowByName : Action_Base{
	base(name = "GetWindowByName", type = "T_Layout");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_String(),must = true),	
		})
	};
};

#将控件或界面添加为子控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetChildWidgetForWidget : Action_Base{
	base(name = "SetChildWidgetForWidget", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "parentWidget", value = T_Widget(),must = true),	
			ActionParam(key = "childWidget", value = T_Widget(),must = true)
		})
	};
};

#获取父控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetParentWidget : Action_Base{
	base(name = "GetParentWidget", type = "T_Widget");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#判断控件或界面是否为子控件
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsChildWidget : Action_Base{
	base(name = "IsChildWidget", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "parentWidget", value = T_Widget(),must = true),	
			ActionParam(key = "childWidget", value = T_Widget(),must = true)
		})
	};
};

#获取控件所在的界面
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowByWidget : Action_Base{
	base(name = "GetWindowByWidget", type = "T_Layout");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#设置控件或界面的名字
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowName : Action_Base{
	base(name = "SetWindowName", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "name", value = T_String(),must = true)
		})
	};
};

#设置控件或界面是否显示
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowIsShow : Action_Base{
	base(name = "SetWindowIsShow", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "visible", value = T_Bool(),must = true)
		})
	};
};

#设置控件或界面的锚点
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowAnchor : Action_Base{
	base(name = "SetWindowAnchor", type = "T_Void");

	attrs_updater(function(self)
		set_attr(self.components[1].params[2].value, "rawval", "HideImport", "true")
	end);	

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "anchor", value = T_UI_Anchor(),must = true),	
		})
	};
};

#设置控件或界面的坐标
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowPos : Action_Base{
	base(name = "SetWindowPos", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "pos", value = T_UDim2(),must = true),	
		})
	};
};

#设置控件或界面的尺寸
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowSize : Action_Base{
	base(name = "SetWindowSize", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "size", value = T_UDim2(),must = true),	
		})
	};
};

#设置控件或界面的旋转
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowRotation : Action_Base{
	base(name = "SetWindowRotation", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "rotation", value = T_Vector3(),must = true),	
		})
	};
};

#设置控件或界面的透明度
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetWindowAlpha : Action_Base{
	base(name = "SetWindowAlpha", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "alpha", value = T_Double(),must = true),	
		})
	};
};

#设置控件或界面是否被父控件裁剪
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetIsClipByParentWidget : Action_Base{
	base(name = "SetIsClipByParentWidget", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "isClip", value = T_Bool(),must = true),	
		})
	};
};

#设置是否禁用控件或界面
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetIsDisableWidget : Action_Base{
	base(name = "SetIsDisableWidget", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "isDisable", value = T_Bool(),must = true),	
		})
	};
};

#设置控件或界面是否启用触摸穿透
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetIsAbleTouchThrough : Action_Base{
	base(name = "SetIsAbleTouchThrough", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "isAble", value = T_Bool(),must = true),	
		})
	};
};

#设置控件或界面是否置顶
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action"]
struct Action_SetIsTop : Action_Base{
	base(name = "SetIsTop", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),	
			ActionParam(key = "isTop", value = T_Bool(),must = true),	
		})
	};
};

#获取控件或界面是否显示
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowIsShow : Action_Base{
	base(name = "GetWindowIsShow", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的坐标
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowPos : Action_Base{
	base(name = "GetWindowPos", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的尺寸
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowSize : Action_Base{
	base(name = "GetWindowSize", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的旋转
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowRotation : Action_Base{
	base(name = "GetWindowRotation", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的透明度
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowAlpha : Action_Base{
	base(name = "GetWindowAlpha", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面是否被父控件裁剪
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetIsClipByParentWidget : Action_Base{
	base(name = "GetIsClipByParentWidget", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面是否禁用
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetIsDisableWidget : Action_Base{
	base(name = "GetIsDisableWidget", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面是否启用触摸穿透
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetIsAbleTouchThrough : Action_Base{
	base(name = "GetIsAbleTouchThrough", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的屏幕坐标X值
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowXPos : Action_Base{
	base(name = "GetWindowXPos", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面的屏幕坐标Y值
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowYPos : Action_Base{
	base(name = "GetWindowYPos", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面相对于屏幕的宽度
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowWidth : Action_Base{
	base(name = "GetWindowWidth", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取控件或界面相对于屏幕的高度
[Catalog: "ActionCatalog_UI/Common", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetWindowHeight : Action_Base{
	base(name = "GetWindowHeight", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

##文本框
#设置文本控件的文本内容
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetTextContext : Action_Base{
	base(name = "SetTextContext", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "text", value = T_Text(),must = true),	
		})
	};
};

#设置文本控件的文本字号
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetTextSize : Action_Base{
	base(name = "SetTextSize", type = "T_Void");

	attrs_updater(function(self)
		local fontSize = self.components[1].params[2].value
		set_attr(fontSize, "rawval", "Max", "72")
		set_attr(fontSize, "rawval", "Min", "8")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "size", value = T_Int(rawval = 12),must = true),	
		})
	};
};

#设置文本控件的文本颜色
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetTextColor : Action_Base{
	base(name = "SetTextColor", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "color", value = T_UIBluePrintColor(),must = true),	
		})
	};
};

#设置是否显示文本控件的背景
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetIsShowBackground : Action_Base{
	base(name = "SetIsShowBackground", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "isShow", value = T_Bool(rawval = false),must = true),	
		})
	};
};

#设置是否显示文本控件的边框
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetIsShowFrame : Action_Base{
	base(name = "SetIsShowFrame", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "isShow", value = T_Bool(rawval = false),must = true),	
		})
	};
};

#获取文本控件的文本内容
[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetTextContext : Action_Base{
	base(name = "GetTextContext", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

[Catalog: "ActionCatalog_UI/StaticTextCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsText : Action_Base{
	base(name = "IsText", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

##图片控件
#设置图片控件显示的图片
[Catalog: "ActionCatalog_UI/StaticImageCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetShowImage : Action_Base{
	base(name = "SetShowImage", type = "T_Void");

	attrs_updater(function(self)
		set_attr(self.components[1].params[2].value, "rawval", "HideImport", "true")
	end);	

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "image", value = T_Resource_Image(),must = true)		
		})
	};
};

#判断控件是否为图片控件
[Catalog: "ActionCatalog_UI/StaticImageCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsImage : Action_Base{
	base(name = "IsImage", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

##按钮控件
#设置按钮控件的普通状态图片
[Catalog: "ActionCatalog_UI/ButtonCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetButtonNormalState : Action_Base{
	base(name = "SetButtonNormalState", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "image", value = T_Resource_Image(),must = true)		
		})
	};
};

#设置按钮控件的禁用状态图片
[Catalog: "ActionCatalog_UI/ButtonCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetButtonDisableState : Action_Base{
	base(name = "SetButtonDisableState", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "image", value = T_Resource_Image(),must = true)		
		})
	};
};

#设置按钮控件的按下状态图片
[Catalog: "ActionCatalog_UI/ButtonCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetButtonPushedState : Action_Base{
	base(name = "SetButtonPushedState", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "image", value = T_Resource_Image(),must = true)		
		})
	};
};

#判断按钮控件是否被按下
[Catalog: "ActionCatalog_UI/ButtonCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsButtonPushed : Action_Base{
	base(name = "IsButtonPushed", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

#判断控件是否为按钮控件
[Catalog: "ActionCatalog_UI/ButtonCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsButton : Action_Base{
	base(name = "IsButton", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

##进度条
#设置进度条控件的当前进度
[Catalog: "ActionCatalog_UI/ProgressBarCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetProgressBarValue : Action_Base{
	base(name = "SetProgressBarValue", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Max", "1")
		set_attr(value, "rawval", "Min", "0")
		set_attr(value, "rawval", "Step", "0.01")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(),must = true)
		})
	};
};

#增加/减少进度值
[Catalog: "ActionCatalog_UI/ProgressBarCatalog", BluePrint_Action_Type: "client_action"]
struct Action_AddOrSubProgressBarValue : Action_Base{
	base(name = "AddOrSubProgressBarValue", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Max", "1")
		set_attr(value, "rawval", "Min", "-1")
		set_attr(value, "rawval", "Step", "0.01")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(rawval = 0.01),must = true)
		})
	};
};

#获取进度条控件的当前进度值
[Catalog: "ActionCatalog_UI/ProgressBarCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetProgressBarValue : Action_Base{
	base(name = "GetProgressBarValue", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

#判断控件是否为进度条控件
[Catalog: "ActionCatalog_UI/ProgressBarCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsProgressBar : Action_Base{
	base(name = "IsProgressBar", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

#输入框控件
#设置输入框控件的文本内容
[Catalog: "ActionCatalog_UI/EditBoxCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetEditBoxContext : Action_Base{
	base(name = "SetEditBoxContext", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "text", value = T_String(),must = true)
		})
	};
};

#设置输入框控件是否只读
[Catalog: "ActionCatalog_UI/EditBoxCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetEditBoxIsReadOnly : Action_Base{
	base(name = "SetEditBoxIsReadOnly", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "isReadOnly", value = T_Bool(),must = true)
		})
	};
};

#获取输入框控件的当前输入内容
[Catalog: "ActionCatalog_UI/EditBoxCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetEditBoxContext : Action_Base{
	base(name = "GetEditBoxContext", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取输入框控件是否被聚焦
[Catalog: "ActionCatalog_UI/EditBoxCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetEditBoxIsFocus : Action_Base{
	base(name = "GetEditBoxIsFocus", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

#判断控件是否为输入框控件
[Catalog: "ActionCatalog_UI/EditBoxCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsEditBox : Action_Base{
	base(name = "IsEditBox", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

##复选框
#设置复选框控件的选中状态
[Catalog: "ActionCatalog_UI/CheckBoxCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetCheckBoxIsSelected : Action_Base{
	base(name = "SetCheckBoxIsSelected", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "isSelected", value = T_Bool(rawval = false),must = true)
		})
	};
};

#获取复选框控件是否被选中
[Catalog: "ActionCatalog_UI/CheckBoxCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetCheckBoxIsSelected : Action_Base{
	base(name = "GetCheckBoxIsSelected", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

#判断控件是否为复选框控件
[Catalog: "ActionCatalog_UI/CheckBoxCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsCheckBox : Action_Base{
	base(name = "IsCheckBox", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)	
		})
	};
};

##单选框
#设置单选按钮控件的选中状态
[Catalog: "ActionCatalog_UI/RadioButtonCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetRadioButtonIsSelected : Action_Base{
	base(name = "SetRadioButtonIsSelected", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "isSelected", value = T_Bool(rawval = false),must = true)
		})
	};
};

#设置单选按钮控件的单选组ID
[Catalog: "ActionCatalog_UI/RadioButtonCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetRadioButtonGroupID : Action_Base{
	base(name = "SetRadioButtonGroupID", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Min", "0")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "groupId", value = T_Int(),must = true)
		})
	};
};

#获取单选按钮控件是否被选中
[Catalog: "ActionCatalog_UI/RadioButtonCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetRadioButtonIsSelected : Action_Base{
	base(name = "GetRadioButtonIsSelected", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};
#获取单选按钮控件的单选组ID
[Catalog: "ActionCatalog_UI/RadioButtonCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetRadioButtonGroupID : Action_Base{
	base(name = "GetRadioButtonGroupID", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#判断控件是否为单选按钮控件
[Catalog: "ActionCatalog_UI/RadioButtonCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsRadioButton : Action_Base{
	base(name = "IsRadioButton", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

##滑动条
#设置滑动条控件的当前进度值
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetSliderValue : Action_Base{
	base(name = "SetSliderValue", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Min", "0")
		set_attr(value, "rawval", "Step", "0.01")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(),must = true)
		})
	};
};

#增加/减少进度值
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action"]
struct Action_AddOrSubSliderValue : Action_Base{
	base(name = "AddOrSubSliderValue", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Step", "0.01")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(rawval = 0.01),must = true)
		})
	};
};

#设置滑动条控件的最大进度值
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetSliderMaxValue : Action_Base{
	base(name = "SetSliderMaxValue", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Min", "0")
		set_attr(value, "rawval", "Step", "0.01")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "maxValue", value = T_Double(),must = true)
		})
	};
};

#获取滑动条控件的当前进度
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetSliderValue : Action_Base{
	base(name = "GetSliderValue", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取滑动条控件的最大进度值
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetSliderMaxValue : Action_Base{
	base(name = "GetSliderMaxValue", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#判断控件是否为滑动条控件
[Catalog: "ActionCatalog_UI/SliderCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsSlider : Action_Base{
	base(name = "IsSlider", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

##滚动面板
#设置滚动面板控件的水平滚动位置
[Catalog: "ActionCatalog_UI/ScrollableViewCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetScrollableViewHorizontalPos : Action_Base{
	base(name = "SetScrollableViewHorizontalPos", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Min", "0")
		set_attr(value, "rawval", "Max", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(),must = true)
		})
	};
};

#设置滚动面板控件的垂直滚动位置
[Catalog: "ActionCatalog_UI/ScrollableViewCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetScrollableViewVerticalPos : Action_Base{
	base(name = "SetScrollableViewVerticalPos", type = "T_Void");

	attrs_updater(function(self)
		local value = self.components[1].params[2].value
		set_attr(value, "rawval", "Min", "0")
		set_attr(value, "rawval", "Max", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "value", value = T_Double(),must = true)
		})
	};
};

#获取滚动面板控件的当前水平滚动位置
[Catalog: "ActionCatalog_UI/ScrollableViewCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetScrollableViewHorizontalPos : Action_Base{
	base(name = "GetScrollableViewHorizontalPos", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#获取滚动面板控件的当前垂直滚动位置
[Catalog: "ActionCatalog_UI/ScrollableViewCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetScrollableViewVerticalPos : Action_Base{
	base(name = "GetScrollableViewVerticalPos", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#判断控件是否为滚动面板控件
[Catalog: "ActionCatalog_UI/ScrollableViewCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsScrollableView : Action_Base{
	base(name = "IsScrollableView", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

##角色窗口
#设置角色窗口显示的角色模型
[Catalog: "ActionCatalog_UI/ActorWindowCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetActorModel : Action_Base{
	base(name = "SetActorModel", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "actor", value = T_Resource_Actor(),must = true)

		})
	};
};

#设置角色窗口中角色模型播放的动作
[Catalog: "ActionCatalog_UI/ActorWindowCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetActorModelAction : Action_Base{
	base(name = "SetActorModelAction", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "action", value = T_String(rawval = "idle"),must = true)

		})
	};
};

#判断控件是否为角色窗口控件
[Catalog: "ActionCatalog_UI/ActorWindowCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsActorWindow : Action_Base{
	base(name = "IsActorWindow", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

#设置特效窗口显示的特效
[Catalog: "ActionCatalog_UI/EffectWindowCatalog", BluePrint_Action_Type: "client_action"]
struct Action_SetEffectName : Action_Base {
    base(name = "SetEffectName", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true),
			ActionParam(key = "effect", value = T_Resource_Effect(),must = true)
		})
	};
};

#判断控件是否为特效窗口控件
[Catalog: "ActionCatalog_UI/EffectWindowCatalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_IsEffectWindow : Action_Base {
    base(name = "isEffectWindow", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "instance", value = T_Widget(),must = true)
		})
	};
};

############################### Var #############################
[Catalog: "ActionCatalog_Var", RValue: "true"]
struct Action_GetObjectVar : Action_Base {
	base(name = "GetObjectVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_ObjectVar(),must = true),
			ActionParam(key = "obj", value = T_Entity(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[2] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("entity",key)
			local struct_type = var:var_struct_type("entity",key)
			if var_key_type then
				local type = "T_"..var_key_type:gsub("^%l", string.upper)
				if var_key_type == "scene_pos" then
					type = "T_ScenePos"
				end
				if var_key_type == "udim2" then
					type = "T_UDim2"
				end
				if struct_type == "array" then
					type = type.."Array"
				end
				self.type = type
			end
		end
	end);
};

[Catalog: "ActionCatalog_Var"]
struct Action_SetObjectVar : Action_Base {
	base(name = "SetObjectVar", type = "T_Bool");
	hide DataStructureType struct_type = "var";
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_ObjectVar(),must = true),
			ActionParam(key = "value", value = T_Var()),
			ActionParam(key = "obj", value = T_Entity(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[4] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("entity",key)
			local struct_type = var:var_struct_type("entity",key)
			local type = "T_Var"
			if var_key_type then
				type = "T_"..var_key_type:gsub("^%l", string.upper)
			end
			if var_key_type == "scene_pos" then
				type = "T_ScenePos"
			end
			if var_key_type == "udim2" then
				type = "T_UDim2"
			end
			self.struct_type = struct_type
			if struct_type == "array" then
				self.components[1].params[2].value = ctor(type.."Array")
				return;
			end
			self.components[1].params[2].value = ctor(type)
		end
	end);
};

#获取UI变量
[Catalog: "ActionCatalog_Var", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetUIVar : Action_Base {
	base(name = "GetUIVar", type = "T_Var");

	attrs_updater(function(self)
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);	

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_UiVar(),must = true),
			ActionParam(key = "instance", value = T_Layout(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[2] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("ui",key)
			local struct_type = var:var_struct_type("ui",key)
			if var_key_type then
				local type = "T_"..var_key_type:gsub("^%l", string.upper)
				if var_key_type == "scene_pos" then
					type = "T_ScenePos"
				end
				if var_key_type == "udim2" then
					type = "T_UDim2"
				end
				if struct_type == "array" then
					type = type.."Array"
				end
				self.type = type
			end
		end
	end);
};

#设置UI变量
[Catalog: "ActionCatalog_Var", BluePrint_Action_Type: "client_action"]
struct Action_SetUIVar : Action_Base {
	base(name = "SetUIVar", type = "T_Bool");

	attrs_updater(function(self)
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);

	hide DataStructureType struct_type = "var";
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_UiVar(),must = true),
			ActionParam(key = "instance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[4] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("ui",key)
			local struct_type = var:var_struct_type("ui",key)
			local type = "T_Var"
			if var_key_type then
				type = "T_"..var_key_type:gsub("^%l", string.upper)
			end
			if var_key_type == "scene_pos" then
				type = "T_ScenePos"
			end
			if var_key_type == "udim2" then
				type = "T_UDim2"
			end
			self.struct_type = struct_type
			if struct_type == "array" then
				self.components[1].params[3].value = ctor(type.."Array")
				return;
			end
			self.components[1].params[3].value = ctor(type)
		end
	end);
};

[Catalog: "ActionCatalog_Var", BluePrint_Action_Type: "common_action", RValue: "true"]
struct Action_GetGlobalVar : Action_Base {
	base(name = "GetGlobalVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_GlobalVar(),must = true)
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[2] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("global",key)
			local struct_type = var:var_struct_type("global",key)
			if var_key_type then
				local type = "T_"..var_key_type:gsub("^%l", string.upper)
				if var_key_type == "scene_pos" then
					type = "T_ScenePos"
				end
				if var_key_type == "udim2" then
					type = "T_UDim2"
				end
				if struct_type == "array" then
					type = type.."Array"
				end
				self.type = type
			end
		end
	end);
};

[Catalog: "ActionCatalog_Var", BluePrint_Action_Type: "common_action"]
struct Action_SetGlobalVar : Action_Base {
	base(name = "SetGlobalVar", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_GlobalVar(),must = true),
			ActionParam(key = "value", value = T_Var())
		})
	};

	monitor("components", function(self,path,oval)
		local KEYINDEX = 1
		if path[4] == KEYINDEX and path[6] == "rawval" then
			local var = require "we.gamedata.var"
			local key = self.components[1].params[1].value.rawval
			local var_key_type = var:var_type("global",key)
			local struct_type = var:var_struct_type("global",key)
			local type = "T_Var"
			if var_key_type then
				type = "T_"..var_key_type:gsub("^%l", string.upper)
			end
			if var_key_type == "scene_pos" then
				type = "T_ScenePos"
			end
			if var_key_type == "udim2" then
				type = "T_UDim2"
			end
			if struct_type == "array" then
				self.components[1].params[2].value = ctor(type.."Array")
				return;
			end
			self.components[1].params[2].value = ctor(type)
		end
	end);
};

[Catalog: "ActionCatalog_Var", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_GetUserContextVar : Action_Base {
	base(name = "GetContextVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Var",BluePrint_Action_Type: "common_action"]
struct Action_SetUserContextVar : Action_Base {
	base(name = "SetContextVar", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value
		set_attr(var_type, "rawval", "RegExp", "^[a-zA-Z][a-zA-Z0-9_]*$")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String(),must = true),
			ActionParam(key = "value", value = T_Var())
		})
	};
};

[Catalog: "ActionCatalog_Var", RValue: "true"]
struct Action_GetFuncContextVar : Action_Base {
	base(name = "GetFuncContextVar", type = "T_Var");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Var"]
struct Action_SetFuncContextVar : Action_Base {
	base(name = "SetFuncContextVar", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value
		set_attr(var_type, "rawval", "RegExp", "^[a-zA-Z][a-zA-Z0-9_]*$")
	end);
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String(),must = true),
			ActionParam(key = "value", value = T_Var())
		})
	};
};

############################### Action_Array #############################
[Nonempty : "true",EnumText : "EnumText", EnumUpdate : "true"]
enum TypeVarSelector {
	list(function()
		local Cjson = require "cjson"
		local Core = require "editor.core"
		local ref = Core.notify(Cjson.encode({
			type = "GET_IS_SERVER_BLUE"
		}))

		ref = Cjson.decode(ref)
		local is_in_server = ref.is_server
		local ret = {}
		table.insert(ret, {value = "global"})
		table.insert(ret, {value = is_in_server and "entity" or "ui"})

		return ret
	end);
};

struct TypeOfVar : T_Base{
	TypeVarSelector rawval;
};

#修改数组元素
[Catalog: "ActionCatalog_Var/Var",BluePrint_Action_Type: "common_action"]
struct Action_ArraySet : Action_Base {
	base(name = "ArraySet", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[4]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[5]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
		local index_node = self.components[1].params[3].value
		set_attr(index_node, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "index", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true),
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据选择的数组名获取数组的类型 重构参数
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if not type then
			type = "var"
		end
		local var_key_type = "T_"..type:gsub("^%l", string.upper)
		if type == "scene_pos" then
			var_key_type = "T_ScenePos"
		elseif type == "udim2" then
			var_key_type = "T_UDim2"
		end
		if var_key_type ~= self.components[1].params[6].value["__OBJ_TYPE"] then
			self.components[1].params[6].value = ctor(var_key_type)
		end
		--根据是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[4], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[5], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#数组末尾追加元素
[Catalog: "ActionCatalog_Var/Var",BluePrint_Action_Type: "common_action"]
struct Action_ArrayAppend : Action_Base {
	base(name = "ArrayAppend", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[3]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[4]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true),
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据选择的数组名获取数组的类型 重构参数
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if not type then
			type = "var"
		end
		local var_key_type = "T_"..type:gsub("^%l", string.upper)
		if type == "scene_pos" then
			var_key_type = "T_ScenePos"
		elseif type == "udim2" then
			var_key_type = "T_UDim2"
		end
		if var_key_type ~= self.components[1].params[5].value["__OBJ_TYPE"] then
			self.components[1].params[5].value = ctor(var_key_type)
		end
		--根据是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[3], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[4], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#插入数组元素
[Catalog: "ActionCatalog_Var/Var",BluePrint_Action_Type: "common_action"]
struct Action_ArrayInsert : Action_Base {
	base(name = "ArrayInsert", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[4]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[5]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
		local index_node = self.components[1].params[3].value
		set_attr(index_node, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "index", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true),
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据选择的数组名获取数组的类型 重构参数
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if not type then
			type = "var"
		end
		local var_key_type = "T_"..type:gsub("^%l", string.upper)
		if type == "scene_pos" then
			var_key_type = "T_ScenePos"
		elseif type == "udim2" then
			var_key_type = "T_UDim2"
		end
		if var_key_type ~= self.components[1].params[6].value["__OBJ_TYPE"] then
			self.components[1].params[6].value = ctor(var_key_type)
		end
		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[4], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[5], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#删除数组元素
[Catalog: "ActionCatalog_Var/Var",BluePrint_Action_Type: "common_action"]
struct Action_ArrayRemove : Action_Base {
	base(name = "ArrayRemove", type = "T_Void");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[4]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[5]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
		local index_node = self.components[1].params[3].value
		set_attr(index_node, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "index", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true)
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[4], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[5], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#获取指定下标元素
[Catalog: "ActionCatalog_Var/Var", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_NewArrayGet : Action_Base {
	base(name = "ArrayGet", type = "T_Var");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[4]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[5]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
		local index_node = self.components[1].params[3].value
		set_attr(index_node, "rawval", "Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "index", value = T_Int(rawval = 1),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true)
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end

		--根据选择的数组名获取数组的类型设置返回值
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if type then
			local var_key_type = "T_"..type:gsub("^%l", string.upper)
			if type == "scene_pos" then
				var_key_type = "T_ScenePos"
			elseif type == "udim2" then
				var_key_type = "T_UDim2"
			end
			self.type = var_key_type
		end

		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[4], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[5], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#获取数组大小
[Catalog: "ActionCatalog_Var/Var", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_NewArraySize : Action_Base {
	base(name = "ArraySize", type = "T_Int");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[3]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[4]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true)
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[3], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[4], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#获取元素在数组中的索引
[Catalog: "ActionCatalog_Var/Var", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ArrayFind : Action_Base {
	base(name = "ArrayFind", type = "T_Int");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[3]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[4]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true),
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]
		local array_node = self.components[1].params[2]

		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end

		--根据选择的数组名获取数组的类型 重构参数
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if not type then
			type = "var"
		end
		local var_key_type = "T_"..type:gsub("^%l", string.upper)
		if type == "scene_pos" then
			var_key_type = "T_ScenePos"
		elseif type == "udim2" then
			var_key_type = "T_UDim2"
		end
		if var_key_type ~= self.components[1].params[5].value["__OBJ_TYPE"] then
			self.components[1].params[5].value = ctor(var_key_type)
		end
		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[3], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[4], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

#获取元素是否在数组中
[Catalog: "ActionCatalog_Var/Var", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ArrayIsHasValue : Action_Base {
	base(name = "IsValueInArray", type = "T_Bool");
	attrs_updater(function(self)
		local var_type = self.components[1].params[1].value.rawval
		local entity_param = self.components[1].params[3]
		set_attr(entity_param, "value", "Visible", var_type == "entity" and "true" or "false")
		local layout_param = self.components[1].params[4]
		set_attr(layout_param, "value", "Visible", var_type == "ui" and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "type", value = TypeOfVar(),must = true),
			ActionParam(key = "array", value = T_ArrayGlobalVar(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "rootInstance", value = T_Layout(),must = true),
			ActionParam(key = "value", value = T_Var(),must = true),
		})
	};
	monitor("components", function(self,path,oval)
		local type_node = self.components[1].params[1]

		local array_node = self.components[1].params[2]
		local array = array_node.value["__OBJ_TYPE"]
		local type = type_node.value.rawval
		--根据是否选择单位变量来切换下拉框中的变量表
		if array ~= "T_ArrayObjectVar" and type == "entity" then
			array_node.value = ctor("T_ArrayObjectVar")
		elseif array ~= "T_ArrayGlobalVar" and type == "global" then
			array_node.value = ctor("T_ArrayGlobalVar")
		elseif array ~= "T_ArrayUiVar" and type == "ui" then
			array_node.value = ctor("T_ArrayUiVar")
		end
		--根据选择的数组名获取数组的类型 重构参数
		local var = require "we.gamedata.var"
		local var_name = array_node.value.rawval
		type = var:var_type(type,var_name)
		if not type then
			type = "var"
		end

		local var_key_type = "T_"..type:gsub("^%l", string.upper)
		if type == "scene_pos" then
			var_key_type = "T_ScenePos"
		elseif type == "udim2" then
			var_key_type = "T_UDim2"
		end
		if var_key_type ~= self.components[1].params[5].value["__OBJ_TYPE"] then
			self.components[1].params[5].value = ctor(var_key_type)
		end

		--根据变量类型是否是单位变量来显示或隐藏单位参数
		type = type_node.value.rawval
		set_attr(self.components[1].params[3], "value", "Visible", type == "entity" and "true" or "false")
		set_attr(self.components[1].params[4], "value", "Visible", type == "ui" and "true" or "false")
	end);
};

############################### Action_Map #############################
[Catalog: "ActionCatalog_Map"]
struct Action_CreateMap : Action_Base {
	base(name = "CreateMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_MapStr(),must = true)
		})
	};
};
#副本:无人时自动关闭
[Catalog: "ActionCatalog_Map"]
struct Action_CreateDuplication : Action_Base {
	base(name = "CreateDuplication", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_MapStr(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_IsPosInRegion : Action_Base {
	base(name = "IsPosInRegion", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "pos", value = T_Vector3(),must = true),
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Map"]
#struct Action_CloseMap : Action_Base {
#	base(name = "CloseMap", type = "T_Void");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "map", value = T_MapObj(),must = true)
#		})
#	};
#};

[Catalog: "ActionCatalog_Map"]
struct Action_EnterMap : Action_Base {
	base(name = "EnterMap", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetEntityMap : Action_Base {
	base(name = "GetEntityMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetPlayerMap : Action_Base {
	base(name = "GetPlayerMap", type = "T_MapObj");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "player", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct Action_GetRandomPosInArea : Action_Base {
	base(name = "GetRandomPosInArea", type = "T_ScenePos");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "region", value = T_SceneRegion(),must = true)
		})
	};
};

# 进入副本
[Catalog: "ActionCatalog_Map"]
struct Action_EnterDuplication : Action_Base {
	base(name = "EnterDuplication", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "map", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true),
			ActionParam(key = "ry", value = T_Int()),
			ActionParam(key = "rp", value = T_Int())
		})
	};
};

[Catalog: "ActionCatalog_Map"]
struct Action_LeaveDuplication : Action_Base {
	base(name = "LeaveDuplication", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map"]
struct Action_MoveMapPlayerTo : Action_Base {
	base(name = "MoveMapPlayerTo", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "map", value = T_MapObj(),must = true),
			ActionParam(key = "newmap", value = T_Map(),must = true),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Map", RValue: "true"]
struct GetStaticMap : Action_Base {
	base(name = "GetStaticMap", type = "T_MapObj");
	attrs_updater(function(self)
		local create_node = self.components[1].params[2].value
		set_attr(create_node, "rawval","Visible", "false")
		set_attr(self.components[1].params[1].value, "rawval", "HideImport", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "name", value = T_Map(),must = true),
			ActionParam(key = "create", value = T_Bool(rawval = true))
		})
	};
};

############################### Action_Game #############################

[Catalog: "ActionCatalog_Game"]
struct Action_GameOver : Action_Base {
	base(name = "GameOver", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Game"]
struct Action_GameOverToPlayer : Action_Base {
	base(name = "GameOverToPlayer", type = "T_Void");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game"]
struct Action_KickOutPlayer : Action_Base {
	base(name = "KickOutPlayer", type = "T_Void");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game"]
struct Action_AllowMidwayJoin : Action_Base {
	base(name = "SetCanJoinMidway", type = "T_Void");

	attrs_updater(function(self)
		set_attr(self.components[1].params, "1", "Hide", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "value", value = T_Int(rawval = 1),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game"]
struct Action_NotAllowMidwayJoin : Action_Base {
	base(name = "SetCanJoinMidway", type = "T_Void");

	attrs_updater(function(self)
		set_attr(self.components[1].params, "1", "Hide", "true")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "value", value = T_Int(rawval = 2),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true"]
struct Action_GetGameTime : Action_Base {
	base(name = "GetGameTime", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true", Deprecated:"true"]
struct Action_GetTime : Action_Base {
	base(name = "GetTime", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true", Deprecated:"true"]
struct Action_GetMonth : Action_Base {
	base(name = "GetMonth", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "time", value = T_Time(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Game", RValue: "true", Deprecated:"true"]
struct Action_GetYear : Action_Base {
	base(name = "GetYear", type = "T_Time");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "time", value = T_Time(),must = true)
		})
	};
};

############################### Action_Logic #############################
[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ComputeInt : Action_Base {
	base(name = "BinaryOper", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Int(),must = true),
			ActionParam(key = "op", value = T_BinaryOperCompute(),must = true),
			ActionParam(key = "right", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ComputeDouble : Action_Base {
	base(name = "BinaryOper", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Double(),must = true),
			ActionParam(key = "op", value = T_BinaryOperCompute(),must = true),
			ActionParam(key = "right", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ComputeBool : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_Double(),must = true),
			ActionParam(key = "op", value = T_BinaryOperBool(),must = true),
			ActionParam(key = "right", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/LogicOperation",RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_BinaryOper : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "op", value = T_BinaryOper(),must = true),
			ActionParam(key = "left", value = T_Bool(),must = true),
			ActionParam(key = "right", value = T_Bool(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/LogicOperation",RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_UnaryOper_Not : Action_Base {
	base(name = "UnaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "value", value = T_Bool(),must = true),
		})
	};
};

[Filter: "T_Void", Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_Parallel : Action_Base {
	base(name = "Parallel", type = "T_Void", pos = Vector2(x = 400, y = 300));
	string desc = "proto";
	Component_Base components[] = {
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_Sequence : Action_Base {
	base(name = "Sequence", type = "T_Bool");

	Component_Base components[] = {
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_Selector : Action_Base {
	base(name = "Selector", type = "T_Bool");

	Component_Base components[] = {
		Component_Sequence()
	};
};

[Filter: "T_Void", Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_If : Action_Base {
	base(name = "If", type = "T_Void");

	Component_Base components[] = {
		Component_Condition()
	};
};

[Filter: "T_IfBranch", Catalog: "ActionCatalog_Logic/Flow", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_IfBranch : Action_Base {
	base(name = "IfBranch", type = "T_IfBranch");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "condition", value = T_Bool())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_LoopTimes : Action_Base {
	base(name = "LoopTimes", type = "T_Void");
	attrs_updater(function(self)
		local times = self.components[1].params[1].value
		set_attr(times, "rawval","Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "times", value = T_Int(),must = true),
			ActionParam(key = "key", value = T_String())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_ForLoop : Action_Base {
	base(name = "ForLoop", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "from", value = T_Int(),must = true),
			ActionParam(key = "to", value = T_Int(),must = true),
			ActionParam(key = "step", value = T_Int(),must = true),
			ActionParam(key = "key", value = T_String())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_Foreach : Action_Base {
	base(name = "Foreach", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "key", value = T_String()),
			ActionParam(key = "array", value = T_Array(),must = true)
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Vector3Operation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ComputeV3 : Action_Base {
	base(name = "ComputeV3", type = "T_Vector3");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Vector3(),must = true),
			ActionParam(key = "op", value = T_Compute(),must = true),
			ActionParam(key = "p2", value = T_Vector3(),must = true)
		})
	};
};


##UDim2运算
#构建UDim2
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_BuildUDim2 : Action_Base{
	base(name = "BuildUDim2", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "x_scale", value = T_Double(),must = true),
			ActionParam(key = "x_offset", value = T_Double(),must = true),
			ActionParam(key = "y_scale", value = T_Double(),must = true),
			ActionParam(key = "y_offset", value = T_Double(),must = true)
		})
	};
};

#获取UDim2中的X比例值
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetUDim2XScale : Action_Base{
	base(name = "GetUDim2XScale", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "udim2", value = T_UDim2(),must = true)
		})
	};
};

#获取UDim2中的X绝对值
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetUDim2XOffset : Action_Base{
	base(name = "GetUDim2XOffset", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "udim2", value = T_UDim2(),must = true)
		})
	};
};

#获取UDim2中的Y比例值
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetUDim2YScale : Action_Base{
	base(name = "GetUDim2YScale", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "udim2", value = T_UDim2(),must = true)
		})
	};
};

#获取取UDim2中的Y绝对值
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_GetUDim2YOffset : Action_Base{
	base(name = "GetUDim2YOffset", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "udim2", value = T_UDim2(),must = true)
		})
	};
};

#UDim2数学运算
[Catalog: "ActionCatalog_Logic/UDim2Catalog", BluePrint_Action_Type: "client_action", RValue: "true"]
struct Action_UDim2Operation : Action_Base{
	base(name = "UDim2Operation", type = "T_UDim2");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "firstUDim2", value = T_UDim2(),must = true),
			ActionParam(key = "compute", value = T_Compute(),must = true),
			ActionParam(key = "secondUDim2", value = T_UDim2(),must = true),
		})
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_Random : Action_Base {
	base(name = "Random", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "min", value = T_Int(),must = true),
			ActionParam(key = "max", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_NumberFloor : Action_Base {
	base(name = "NumberFloor", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_NumberCeil : Action_Base {
	base(name = "NumberCeil", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic",RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ComputeString : Action_Base {
	base(name = "BinaryOper", type = "T_Bool");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "left", value = T_String(),must = true),
			ActionParam(key = "right", value = T_String(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_Concat : Action_Base {
	base(name = "Concat", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "p1", value = T_String()),
			ActionParam(key = "p2", value = T_String())
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true", Deprecated:"true"]
struct Action_ArraySize : Action_Base {
	base(name = "ArraySize", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "array", value = T_Array(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true", Deprecated:"true"]
struct Action_ArrayGet : Action_Base {
	base(name = "ArrayGet", type = "T_Any");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "array", value = T_Array(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_StartTimer2 : Action_Base {
	base(name = "StartTimer2", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "interval", value = T_Time(),must = true),
			ActionParam(key = "time", value = T_Int(),must = true),
			ActionParam(key = "timer", value = T_String()),
			ActionParam(key = "object", value = T_Entity())
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_StopTimer2 : Action_Base {
	base(name = "StopTimer2", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "timer", value = T_String())
		})
	};
};


[Catalog: "ActionCatalog_Logic", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_IsNil : Action_Base {
	base(name = "IsNil", type = "T_Bool");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "data",value = T_Base(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_ToString : Action_Base {
	base(name = "ToString", type = "T_String");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_IsValidObject : Action_Base {
	base(name = "IsValidObject", type = "T_Bool");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "object",value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_Break : Action_Base {
	base(name = "Break", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {})
	};
};

[Catalog: "ActionCatalog_Logic/Flow",BluePrint_Action_Type: "common_action"]
struct Action_WhileBranch : Action_Base {
	base(name = "WhileBranch", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "condition", value = T_Bool(),must = true)
		}),
		Component_Sequence()
	};
};

[Catalog: "ActionCatalog_Logic/MathOperation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_Trigonometry : Action_Base {
	base(name = "Trigonometry", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "operator", value = T_Operator(),must = true),
			ActionParam(key = "angle", value = T_Double(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/Vector3Operation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_GetPosDistance : Action_Base {
	base(name = "GetPosDistance", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "pos1", value = T_Vector3(),must = true),
			ActionParam(key = "pos2", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic/Vector3Operation", RValue: "true",BluePrint_Action_Type: "common_action"]
struct Action_GetPosDistanceSqr : Action_Base {
	base(name = "GetPosDistanceSqr", type = "T_Double");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "pos1", value = T_Vector3(),must = true),
			ActionParam(key = "pos2", value = T_Vector3(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Logic", RValue: "true"]
struct Action_GetContextVar : Action_Base {
	base(name = "GetContextVar", type = "T_Base");

	Component_Base components[] = {
		Component_Context()
	};
};

############################### Action_Debug #############################
[Catalog: "ActionCatalog_Debug",BluePrint_Action_Type: "common_action"]
struct Action_Test : Action_Base {
	base(name = "Test", type = "T_Void");
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "Message",value = T_Base(),must = true)
		})
	};
};

############################### Action_Object #############################

############################### Action_Pet #############################
[Catalog: "ActionCatalog_Pet"]
struct Action_CreatePet : Action_Base {
	base(name = "CreatePet", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "cfg", value = T_EntityEntry(),must = true),
			ActionParam(key = "show", value = T_Bool(),must = true),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet", RValue: "true"]
struct Action_GetPet : Action_Base {
	base(name = "GetPet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_ShowPet : Action_Base {
	base(name = "ShowPet", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true),
			ActionParam(key = "map", value = T_MapObj()),
			ActionParam(key = "pos", value = T_ScenePos(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_HidePet : Action_Base {
	base(name = "HidePet", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_ChangePet : Action_Base {
	base(name = "ChangePet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true),
			ActionParam(key = "cfgName", value = T_EntityEntry(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_AddPet : Action_Base {
	base(name = "AddPet", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "player", value = T_Entity(),must = true),
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_RelievedPet : Action_Base {
	base(name = "RelievedPet", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Pet"]
struct Action_PetFollow : Action_Base {
	base(name = "SetPetFollow", type = "T_Entity");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "index", value = T_Int(),must = true),
			ActionParam(key = "followSwitch", value = T_Bool(),must = true)
		})
	};
};

############################### Action_Player #############################

############################### Action_Rank #############################

############################### Action_Team #############################

[Catalog: "ActionCatalog_Team"]
struct Action_AddTeamBuff : Action_Base {
	base(name = "AddTeamBuff", type = "T_Void");
	attrs_updater(function(self)
		local teamId = self.components[1].params[1].value
		local limit = self.components[1].params[3].value
		local buff_time = self.components[1].params[4].value

		set_attr(teamId, "rawval","Min", "1")
		set_attr(limit, "rawval", "HideImport", "true")
		set_attr(buff_time, "rawval", "Visible", limit.rawval and "true" or "false")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamId", value = T_Int(),must = true),
			ActionParam(key = "cfg", value = T_BuffEntry(),must = true),
			ActionParam(key = "limit", value = T_Bool(rawval = true)),
			ActionParam(key = "buffTime", value = T_Time())
		})
	};
	monitor("components", function(self,path,oval)
		local limit = self.components[1].params[3].value
		local buff_time = self.components[1].params[4].value
		set_attr(buff_time, "rawval", "Visible", limit.rawval and "true" or "false")
	end);
};

[Catalog: "ActionCatalog_Team"]
struct Action_RemoveTeamBuff : Action_Base {
	base(name = "RemoveTeamBuff", type = "T_Void");
	attrs_updater(function(self)
		local teamId = self.components[1].params[1].value
		set_attr(teamId, "rawval","Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamId", value = T_Int(),must = true),
			ActionParam(key = "buff", value = T_Buff(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team", RValue: "true"]
struct Action_GetEntityTeam : Action_Base {
	base(name = "GetEntityTeam", type = "T_Int");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team"]
struct Action_SetEntityTeam : Action_Base {
	base(name = "SetEntityTeam", type = "T_Void");
	attrs_updater(function(self)
		local teamId = self.components[1].params[2].value
		set_attr(teamId, "rawval","Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "teamId", value = T_Int(rawval = 1),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team", RValue: "true"]
struct Action_IsEntityInTeam : Action_Base {
	base(name = "IsEntityInTeam", type = "T_Bool");
	attrs_updater(function(self)
		local teamId = self.components[1].params[2].value
		set_attr(teamId, "rawval","Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "entity", value = T_Entity(),must = true),
			ActionParam(key = "teamId", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team", RValue: "true"]
struct Action_GetTeamEntityArray : Action_Base {
	base(name = "GetTeamEntityArray", type = "T_EntityArray");
	attrs_updater(function(self)
		local teamId = self.components[1].params[1].value
		set_attr(teamId, "rawval","Min", "1")
	end);

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamId", value = T_Int(),must = true)
		})
	};
};

#[Catalog: "ActionCatalog_Team", RValue: "true"]
#struct Action_GetTeamEntityList : Action_Base {
#	base(name = "GetTeamEntityList", type = "T_Array");
#
#	Component_Base components[] = {
#		Component_Params(params = {
#			ActionParam(key = "teamId", value = T_Int())
#		})
#	};
#};

[HideHeader: "true", HideNameLabel: "true",BluePrint_Action_Type: "common_action"]
struct Action_ExecScript : Action_Base {
	base(name = "ExecScript", type = "T_Var");

	Component_Base components[] = {
		Component_Script()
	};
};

[Catalog: "ActionCatalog_Team", RValue: "true"]
struct Action_GetTeamName : Action_Base {
	base(name = "GetTeamName", type = "T_String");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamID", value = T_Int(),must = true)
		})
	};
};

[Catalog: "ActionCatalog_Team"]
struct Action_SetTeamName : Action_Base {
	base(name = "SetTeamName", type = "T_Void");

	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "teamID", value = T_Int(),must = true),
			ActionParam(key = "name", value = T_String(),must = true)
		})
	};
};
############################### Action_Var #############################

#################################################################
############################# Trigger ###########################
#################################################################

struct TriggerArg {
	string key;
	string type;
};


struct Trigger {
    attrs_updater(function(self)
		self.custom_trigger_data.type = self.type
	end);
	bool custom = false;
	string type;
	Action_Base actions[];
	Action_Parallel root;
    hide string func_name;
    hide string custom_trigger_name;
    Trigger_Custom_Data custom_trigger_data;
	string proto_uuid;
};

[EditorData: "true", Resettable: "false"]
struct TriggerSet {
	Trigger list[];
};

[Resettable: "false"]
struct TriggerMainScript {
};

[Resettable: "false"]
struct TriggerGlobalScript {
	string type;
};

struct Trigger_Base {
	const string name;
	TriggerArg contexts[];
};

## Block
enum BlockTriggers {
	#"Trigger_BlockDead",
	"Trigger_BlockClick",
	"Trigger_BlockTouch",
	"Trigger_BlockOn",
	"Trigger_BlockLeave",
	"Trigger_BlockBreak",
	"Trigger_BlockIn",
	"Trigger_BlockOut",
	"Trigger_BlockHitted"
};

#struct Trigger_BlockDead : Trigger_Base {
#	base(name = "BLOCK_DEAD", contexts = {
#		TriggerArg(key = "obj1", type = "T_Entity"),
#		TriggerArg(key = "pos", type = "T_ScenePos")
#	});
#};

struct Trigger_BlockHitted : Trigger_Base {
	base(name = "BLOCK_HITTED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_BlockIn : Trigger_Base {
	base(name = "BLOCK_IN", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockOut : Trigger_Base {
	base(name = "BLOCK_OUT", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockClick : Trigger_Base {
	base(name = "BLOCK_CLICK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockOn : Trigger_Base {
	base(name = "BLOCK_ON", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockLeave : Trigger_Base {
	base(name = "BLOCK_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockTouch : Trigger_Base {
	base(name = "BLOCK_TOUCH", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_BlockBreak : Trigger_Base {
	base(name = "BLOCK_BREAK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

##Entity

enum EntityTriggers {
	"Trigger_EntityEnter",
	"Trigger_EntityLeave",
	"Trigger_EntityDie",
	"Trigger_EntityRebirth",
	"Trigger_EntityDamage",
	"Trigger_EntityClick",
#	"Trigger_EntityLevelUP",
	"Trigger_ENTITY_TOUCH_ALL",
	"Trigger_GameReady_Entity",
	"Trigger_GameStart_Entity",
	"Trigger_GameGo_Entity",
	"Trigger_GameOver_Entity",
	"Trigger_EntityHitted",
	"Trigger_HitEntity",
#	"Trigger_GameExit_Entity",
	"Trigger_RemoveItem_Entity",
	"Trigger_AbandonedItem_Entity",
	"Trigger_ENTITY_GAMEOVER",
    "Trigger_Custom",
	"Trigger_RegisterServerProto"
};

struct Trigger_EntityEnter : Trigger_Base {
	base(name = "ENTITY_ENTER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityLeave : Trigger_Base {
	base(name = "ENTITY_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityDie : Trigger_Base {
	base(name = "ENTITY_DIE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityRebirth : Trigger_Base {
	base(name = "ENTITY_REBIRTH", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityDamage : Trigger_Base {
	base(name = "ENTITY_DAMAGE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj"),
		TriggerArg(key = "damage", type = "T_Int")
	});
};

struct Trigger_EntityHitted : Trigger_Base {
	base(name = "ENTITY_HITTED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_HitEntity : Trigger_Base {
	base(name = "HIT_ENTITY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_EntityClick : Trigger_Base {
	base(name = "ENTITY_CLICK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "map", type = "T_MapObj")
	});
};

struct Trigger_EntityLevelUP : Trigger_Base {
	base(name = "ENTITY_LEVELUP", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_ENTITY_TOUCH_ALL : Trigger_Base {
	base(name = "ENTITY_TOUCH_ALL", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_GameReady_Entity : Trigger_Base {
	base(name = "GAME_READY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameStart_Entity : Trigger_Base {
	base(name = "GAME_START", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameGo_Entity : Trigger_Base {
	base(name = "GAME_GO", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_GameOver_Entity : Trigger_Base {
	base(name = "GAME_OVER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

#struct Trigger_GameExit_Entity : Trigger_Base {
#	base(name = "GAME_EXIT", contexts = {
#		TriggerArg(key = "obj1", type = "T_Entity")
#	});
#};

struct Trigger_RemoveItem_Entity : Trigger_Base {
	base(name = "REMOVE_ITEM_AT_COUNT", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "fullName", type = "T_ItemEntry"),
		TriggerArg(key = "consumeCount", type = "T_Int")
	});
};

struct Trigger_AbandonedItem_Entity : Trigger_Base {
	base(name = "ITEM_ON_ABANDONED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "fullName", type = "T_ItemEntry"),
		TriggerArg(key = "count", type = "T_Int")
	});
};

struct Trigger_ENTITY_GAMEOVER : Trigger_Base {
	base(name = "ENTITY_GAMEOVER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

##Item

enum ItemTriggers {
	"Trigger_DropItemPicked",
	"Trigger_UseItem",
	"Trigger_Hand",
	"Trigger_UnHand",
	"Trigger_ItemTrap",
	"Trigger_RemoveItem",
	"Trigger_AbandonedItem",
	#"Trigger_RegisterServerProto"
};

struct Trigger_ItemTrap : Trigger_Base {
	base(name = "ITEM_TRAP", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_DropItemPicked : Trigger_Base {
	base(name = "DROPITEM_PICKED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_UseItem : Trigger_Base {
	base(name = "USE_ITEM", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item"),
		TriggerArg(key = "itemName", type = "T_ItemEntry")
	});
};

struct Trigger_Hand : Trigger_Base {
	base(name = "HAND_ITEM_CHANGED_HAND", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_UnHand : Trigger_Base {
	base(name = "HAND_ITEM_CHANGED_UNHAND", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "item", type = "T_Item")
	});
};

struct Trigger_RemoveItem : Trigger_Base {
	base(name = "REMOVE_ITEM_AT_COUNT", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "fullName", type = "T_ItemEntry"),
		TriggerArg(key = "consumeCount", type = "T_Int")
	});
};

struct Trigger_AbandonedItem : Trigger_Base {
	base(name = "ITEM_ON_ABANDONED", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "fullName", type = "T_ItemEntry"),
		TriggerArg(key = "count", type = "T_Int")
	});
};

##Skill

enum SkillTriggers{
	"Trigger_SkillCast",
	#"Trigger_RegisterServerProto"
};

struct Trigger_SkillCast : Trigger_Base {
	base(name = "SKILL_CAST", contexts = {
		TriggerArg(key = "owner", type = "T_Entity"),
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
#		TriggerArg(key = "pos", type = "T_Vector3"),
		TriggerArg(key = "fullName", type = "T_SkillEntry")
	});
};

##GameSetting

enum GameTriggers{
	"Trigger_GameInit",
	"Trigger_GameReady",
	"Trigger_GameStart",
	"Trigger_GameGo",
	"Trigger_GameOver",
##	"Trigger_GameExit"
	"Trigger_RegisterServerProto",
    "Trigger_Custom"
};

struct Trigger_GameInit : Trigger_Base {
	base(name = "GAME_INIT", contexts = {
	});
};

struct Trigger_GameReady : Trigger_Base {
	base(name = "GAME_READY", contexts = {

	});
};

struct Trigger_GameStart : Trigger_Base {
	base(name = "GAME_START", contexts = {
		
	});
};

struct Trigger_GameGo : Trigger_Base {
	base(name = "GAME_GO", contexts = {
		
	});
};

struct Trigger_GameOver : Trigger_Base {
	base(name = "GAME_OVER", contexts = {
		
	});
};

enum GameClientTriggers{
	"Trigger_ClientInitFinished",
	"Trigger_TouchScreen",
	"Trigger_DragScreen",
	"Trigger_ReleaseScreen",
	"Trigger_RegisterClientProto",
    "Trigger_Custom_Client"
};

[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_ClientInitFinished : Trigger_Base{
	base(name = "Client_Init_Finished", contexts = {
		
	});
};

[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_TouchScreen : Trigger_Base{
	base(name = "Screen_Touch_Begin", contexts = {
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double")
	});
};

[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_DragScreen : Trigger_Base{
	base(name = "Screen_Touch_Move", contexts = {
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double")		
	});
};

[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_ReleaseScreen : Trigger_Base{
	base(name = "Screen_Touch_End", contexts = {
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double")		
	});
};


##Region

enum RegionTriggers{
	"Trigger_RegionEnter",
	"Trigger_RegionLeave",
	#"Trigger_RegisterServerProto"
};

struct Trigger_RegionEnter : Trigger_Base {
	base(name = "REGION_ENTER", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

struct Trigger_RegionLeave : Trigger_Base {
	base(name = "REGION_LEAVE", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity")
	});
};

##Part

enum PartTriggers{
	"Trigger_PartClicked",
	"Trigger_PartTouchEntityBegin",
	"Trigger_PartTouchEntityEnd",
	"Trigger_PartHitted",
	"Trigger_RegisterServerProto",
    "Trigger_Custom"
};

struct Trigger_PartClicked : Trigger_Base {
	base(name = "PART_CLICKED", contexts = {
		TriggerArg(key = "part1", type = "T_Part"),
		TriggerArg(key = "from", type = "T_Entity")
	});
};

struct Trigger_PartTouchEntityBegin : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_BEGIN", contexts = {
		TriggerArg(key = "part1", type = "T_Part"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_PartTouchEntityEnd : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_END", contexts = {
		TriggerArg(key = "part1", type = "T_Part"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_PartHitted : Trigger_Base {
	base(name = "PART_HITTED", contexts = {
		TriggerArg(key = "part1", type = "T_Part"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

##MeshPart

enum MeshPartTriggers{
	"Trigger_MeshPartClicked",
	"Trigger_MeshPartTouchEntityBegin",
	"Trigger_MeshPartTouchEntityEnd",
	"Trigger_MeshPartHitted"
};

struct Trigger_MeshPartClicked : Trigger_Base {
	base(name = "PART_CLICKED", contexts = {
		TriggerArg(key = "part1", type = "T_MeshPart"),
		TriggerArg(key = "from", type = "T_Entity")
	});
};

struct Trigger_MeshPartTouchEntityBegin : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_BEGIN", contexts = {
		TriggerArg(key = "part1", type = "T_MeshPart"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_MeshPartTouchEntityEnd : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_END", contexts = {
		TriggerArg(key = "part1", type = "T_MeshPart"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_MeshPartHitted : Trigger_Base {
	base(name = "PART_HITTED", contexts = {
		TriggerArg(key = "part1", type = "T_MeshPart"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

##PartOperation

enum PartOperationTriggers{
	"Trigger_PartOperationClicked",
	"Trigger_PartOperationTouchEntityBegin",
	"Trigger_PartOperationTouchEntityEnd",
	"Trigger_PartOperationHitted"
};

struct Trigger_PartOperationClicked : Trigger_Base {
	base(name = "PART_CLICKED", contexts = {
		TriggerArg(key = "part1", type = "T_PartOperation"),
		TriggerArg(key = "from", type = "T_Entity")
	});
};

struct Trigger_PartOperationTouchEntityBegin : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_BEGIN", contexts = {
		TriggerArg(key = "part1", type = "T_PartOperation"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_PartOperationTouchEntityEnd : Trigger_Base {
	base(name = "PART_TOUCH_ENTITY_END", contexts = {
		TriggerArg(key = "part1", type = "T_PartOperation"),
		TriggerArg(key = "obj2", type = "T_Entity")
	});
};

struct Trigger_PartOperationHitted : Trigger_Base {
	base(name = "PART_HITTED", contexts = {
		TriggerArg(key = "part1", type = "T_PartOperation"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

##Missile
enum MissileTriggers{
	"Trigger_MissileHitEntity",
	"Trigger_MissileHitBlock",
	#"Trigger_RegisterServerProto"
};

struct Trigger_MissileHitEntity : Trigger_Base {
	base(name = "HIT_ENTITY", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "obj2", type = "T_Entity"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

struct Trigger_MissileHitBlock : Trigger_Base {
	base(name = "HIT_BLOCK", contexts = {
		TriggerArg(key = "obj1", type = "T_Entity"),
		TriggerArg(key = "pos", type = "T_ScenePos"),
		TriggerArg(key = "missile", type = "T_Missile")
	});
};

##UI
enum WidgetTriggers {
	"Trigger_WidgetCreate",
	"Trigger_WidgetShow",
	"Trigger_WidgetHide",
	"Trigger_WidgetClicked",
	"Trigger_WidgetHoldDown",
	"Trigger_WidgetButtonPress",
	"Trigger_WidgetButtonRelease",
	"Trigger_WidgetDrag",
	"Trigger_WidgetDragOut",
	"Trigger_WidgetDestory",
	"Trigger_WidgetEnabled",
	"Trigger_WidgetDisabled",
	"Trigger_RegisterClientProto",
    "Trigger_Custom_Client"
};

struct Trigger_Widget : Trigger_Base{

};

#当创建控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetCreate : Trigger_Widget{
	base(name = "WIDGET_CREATE", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当控件切换为显示状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetShow : Trigger_Widget{
	base(name = "WIDGET_SHOWN", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当控件切换为隐藏状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetHide : Trigger_Widget{
	base(name = "WIDGET_HIDDEN", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当点击控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetClicked : Trigger_Widget{
	base(name = "WIDGET_CLICKED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当长按控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetHoldDown : Trigger_Widget{
	base(name = "WIDGET_HOLD_DOWN", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当按下控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetButtonPress : Trigger_Widget{
	base(name = "WIDGET_TOUCH_PRESS", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当按下控件后抬起时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetButtonRelease : Trigger_Widget{
	base(name = "WIDGET_TOUCH_RELEASE", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "start_x", type = "T_Double"),
		TriggerArg(key = "start_y", type = "T_Double"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当按住控件并移动时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetDrag : Trigger_Widget{
	base(name = "WIDGET_TOUCH_MOVE", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当按住控件并移动到控件外部时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetDragOut : Trigger_Widget{
	base(name = "WIDGET_TOUCH_OUT_MOVE", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "x", type = "T_Double"),
		TriggerArg(key = "y", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当销毁控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetDestory : Trigger_Widget{
	base(name = "WIDGET_DESTORY", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#控件切换为启用状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetEnabled : Trigger_Widget{
	base(name = "WIDGET_ENABLED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当控件切换为禁用状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_WidgetDisabled : Trigger_Widget{
	base(name = "WIDGET_DISABLED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#协议注册
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_RegisterClientProto : Trigger_Base{
	base(name = "RECEIVE_UI_BTS_MESSAGE", contexts = {
		TriggerArg(key = "player", type = "T_Entity"),
		TriggerArg(key = "instance", type = "T_Var")
	});
};

struct Trigger_RegisterServerProto : Trigger_Base{
	base(name = "RECEIVE_UI_BTS_MESSAGE", contexts = {
		TriggerArg(key = "player", type = "T_Entity"),
		TriggerArg(key = "instance", type = "T_Var")
	});
};

struct Trigger_RegisterProto : Trigger_Base{
	base(name = "RECEIVE_UI_BTS_MESSAGE", contexts = {
		
	});
};

enum Trigger_DefaultWindow{
	list(function()
		local trigger = require "we.gamedata.trigger"
		return trigger.list_widget_trigger()
	end);
};

enum Trigger_StaticText{
	list(function()
		local trigger = require "we.gamedata.trigger"
		return trigger.list_widget_trigger()
	end);
};

enum Trigger_StaticImage{
	list(function()
		local trigger = require "we.gamedata.trigger"
		return trigger.list_widget_trigger()
	end);
};

enum Trigger_Button{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		return ret
	end);
};

enum Trigger_ProgressBar{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_ProgressBar_Value_Change"})
		return ret
	end);
};

#当进度条的进度改变时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_ProgressBar_Value_Change : Trigger_Base{
	base(name = "WIDGET_PROGRESSBAR_PROGRESSCHANGED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "progress", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

enum Trigger_Editbox{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_Editbox_FocusIn"})
		table.insert(ret, {value = "Trigger_Editbox_FocusOut"})
		table.insert(ret, {value = "Trigger_Editbox_TextChanged"})
		return ret
	end);
};

#当输入框获得焦点时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Editbox_FocusIn : Trigger_Base{
	base(name = "WIDGET_CAPTURE_GAINED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当输入框失去焦点时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Editbox_FocusOut : Trigger_Base{
	base(name = "WIDGET_CAPTURE_LOST", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当输入的文本改变时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Editbox_TextChanged : Trigger_Base{
	base(name = "WIDGET_EDITBOX_CHANGED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "text", type = "T_String"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

enum Trigger_Checkbox{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_Checkbox_Selected"})
		table.insert(ret, {value = "Trigger_Checkbox_Unselected"})
		return ret
	end);
};

#复选框切换为选中状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Checkbox_Selected : Trigger_Base{
	base(name = "WIDGET_TOGGLE_SELECTED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};
#复选框切换为未选中状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Checkbox_Unselected : Trigger_Base{
	base(name = "WIDGET_TOGGLE_NO_SELECTED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

enum Trigger_RadioButton{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_RadioButton_Selected"})
		table.insert(ret, {value = "Trigger_RadioButton_Unselected"})
		return ret
	end);
};

#单选框切换为选中状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_RadioButton_Selected : Trigger_Base{
	base(name = "WIDGET_TOGGLE_SELECTED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#单选框切换为未选中状态时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_RadioButton_Unselected : Trigger_Base{
	base(name = "WIDGET_TOGGLE_NO_SELECTED", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

enum Trigger_Slider{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_Slider_ValueChanged"})
		return ret
	end);
};

#当滑动条的进度改变时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Slider_ValueChanged : Trigger_Base{
	base(name = "WIDGET_SLIDER_CHANGE ", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "value", type = "T_Double"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

enum Trigger_ScrollableView{
	"Trigger_WidgetCreate",
	"Trigger_WidgetShow",
	"Trigger_WidgetHide",
	"Trigger_WidgetDestory",
	"Trigger_WidgetEnabled",
	"Trigger_WidgetDisabled",
    "Trigger_Custom_Client"
};

enum Trigger_ActorWindow{
	list(function()
		local trigger = require "we.gamedata.trigger"
		return trigger.list_widget_trigger()
	end);
};

# HorizontalLayoutContainer VerticalLayoutContainer GridView 公用trigger
enum Trigger_Container{
	list(function()
		local trigger = require "we.gamedata.trigger"
		local ret =  trigger.list_widget_trigger()
		table.insert(ret, {value = "Trigger_Container_Add_Widget"})
		table.insert(ret, {value = "Trigger_Container_Remove_Widget"})
		return ret
	end);
};

#当添加子控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Container_Add_Widget : Trigger_Base{
	base(name = "LAYOUTCONTAINER_CHILD_ADDED ", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "child", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};

#当移除子控件时
[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Container_Remove_Widget : Trigger_Base{
	base(name = "LAYOUTCONTAINER_CHILD_REMOVED ", contexts = {
		TriggerArg(key = "instance", type = "T_Widget"),
		TriggerArg(key = "child", type = "T_Widget"),
		TriggerArg(key = "rootInstance", type = "T_Layout")
	});
};


#################################################################
############################# BlockList #########################
#################################################################

struct BlockListCfg{
	[EditorData: "true"]
	Text name;
	hide number model[];
	hide Vector3i dis;
};

############################# UI #########################

enum Enum_Widget {
	list(function()
		local Widget = require "we.gamedata.widget"
		return Widget:list()
	end);
};

[Nonempty : "true"]
enum HorzAlignment{
	"LeftAligned",
	"RightAligned",
	"CentreAligned",
};

[Nonempty : "true"]
enum VertAlignment{
	"TopAligned",
	"CentreAligned",
	"BottomAligned",
}; 

enum HorzScaling{
	"LeftAligned",
	"CentreAligned",
	"RightAligned",
	"Stretched",
	"Tiled"
};

enum VertsSaling{
	"TopAligned",
	"CentreAligned",
	"BottomAligned",
	"Stretched",
	"Tiled"
};

[Nonempty : "true"]
enum FillType{
	"Horizontal",
	"Vertical",
	"With90Degree",
	"With180Degree",
	"With360Degree"
};

[Nonempty : "true"]
enum FillPosition{
	list(function(param)
		local ret = {}
		param = param or "Horizontal"
		if param == "Horizontal" then
			table.insert(ret, {value = "Left_Horizontal"})
			table.insert(ret, {value = "Right_Horizontal"})
		elseif param == "Vertical" then
			table.insert(ret, {value = "Top_Vertical"})
			table.insert(ret, {value = "Bottom_Vertical"})
		elseif param == "With90Degree" then
			table.insert(ret, {value = "LeftTop_With90Degree"})
			table.insert(ret, {value = "LeftBottom_With90Degree"})
			table.insert(ret, {value = "RightTop_With90Degree"})
			table.insert(ret, {value = "RightBottom_With90Degree"})
		elseif param == "With180Degree" then
			table.insert(ret, {value = "Left_With180Degree"})
			table.insert(ret, {value = "Right_With180Degree"})
			table.insert(ret, {value = "Top_With180Degree"})
			table.insert(ret, {value = "Bottom_With180Degree"})
		elseif param == "With360Degree" then
			table.insert(ret, {value = "Left_With360Degree"})
			table.insert(ret, {value = "Right_With360Degree"})
			table.insert(ret, {value = "Top_With360Degree"})
			table.insert(ret, {value = "Bottom_With360Degree"})
		end
		return ret
	end);
};

[Nonempty : "true"]
enum HorAlignment{
	"Left",
	"Centre",
	"Right"
};

[Nonempty : "true"]
enum VerAlignment{
	"Top",
	"Centre",
	"Bottom"
};

[Nonempty: "true", Filters:"*.ttf"]
enum Resource_Font{                                                                                         
	list(function()
		local fontMgr = require "we.logic.ui.ui_font_manager"
		return fontMgr:get_font_list()
	end);
};

[Nonempty: "true"]
enum Font_Size{
	"8",
	"10",
	"12",
	"14",
	"16",
	"18",
	"20",
	"22",
	"24",
	"26",
	"28",
	"36"
};

[Nonempty: "true",integer: "true"]
enum TextBold{
	"-1",#瘦体
	"0",#常规
	"1" #粗体
};

[Nonempty: "true",integer: "true"]
enum EAutoScale{
	"0",#固定大小
	"1",#自适应宽
	"2",#自适应高
	"3"#自适应宽高
};

[Nonempty: "true",integer: "true"]
enum EImageBlendMode{
	"0",#正常
	"1",#正片叠加
	"2"#颜色减淡
	#"3" #明度
};

[Nonempty: "true",integer: "true"]
enum EImageBlendFactor{
	"0",#GL_ZERO,
	"1",#GL_ONE,
	"2",#GL_SRC_ALPHA,
	"3",#GL_DST_ALPHA,
	"4",#GL_ONE_MINUS_SRC_ALPHA,
	"5",#GL_ONE_MINUS_DST_ALPHA,
	"6",#GL_SRC_COLOR,
	"7",#GL_DST_COLOR,
	"8",#GL_ONE_MINUS_SRC_COLOR,
	"9",#GL_ONE_MINUS_DST_COLOR,
};

[Nonempty: "true",integer: "true"]
enum EImageBlendOperation{
	"0",#GL_FUNC_ADD, 
	"1",#GL_FUNC_SUBTRACT, 
	"2",#GL_SEVWESE_FUNC_SUBTRACT, 
	"3",#GL_FUNC_MIN, 
	"4",#GL_FUNC_MAX,
};

[Nonempty: "true"]
enum CheckBoxTile{
	"LeftRight",
	"Center"
};

[Nonempty : "true"]
enum EffectPlayMode{
	"0", #"LOOP",
	"1"  #"ONCE"
}; 

[Nonempty : "true"]
enum SoundTriggerRange
{
	"None",  
    "Down",  
    "Up",    
    "Click"  
};

[Nonempty : "true"]
enum MousePassThrough{

	list(function(param)
		local ret = {}
		table.insert(ret, {value = "MousePassThroughClose"})
		table.insert(ret, {value = "MousePassThroughOpen"})
		param = param or ""
		if param ~= "EffectWindow" then
			table.insert(ret, {value = "MousePassThroughAlpha"})
		end
		return ret
	end);
};

struct UI_ScriptItem{
	string path;
};

struct ImageStretch{
	[Min : "0", Update: "true"]
	number top_left;
	[Min : "0", Update: "true"]
	number top_right;
	[Min : "0", Update: "true"]
	number bottom_left;
	[Min : "0", Update: "true"]
	number bottom_right;
	#将数值改变信号向上传递
	monitor("top_left", function(self, path, oval)
		return true
	end);
	monitor("top_right", function(self, path, oval)
		return true
	end);
	monitor("bottom_left", function(self, path, oval)
		return true
	end);
	monitor("bottom_right", function(self, path, oval)
		return true
	end);
	string image_type;

	number tailoring_top_left = 0;
	number tailoring_top_right = 0;
	number tailoring_bottom_left = 0;
	number tailoring_bottom_right = 0;
	
};

struct Anchor{
	HorAlignment HorizontalAlignment = "Left";
	VerAlignment VerticalAlignment = "Top";
};

struct Thumb {
	[Resettable: "false"]
	Resource_CEGUITexture thumb_image = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_thumb.png", asset = "asset/Texture/Gui/slider_thumb.png", name = "slider_thumb.png");
	[Resettable: "false"]
	ImageStretch thumb_stretch = ImageStretch(image_type = "thumb_image");
};

struct Resize{
	number tailoring_top_left = 0;
	number tailoring_top_right = 0;
	number tailoring_bottom_left = 0;
	number tailoring_bottom_right = 0;
};

struct Window_Base{
	hide Uuid id;
	[Resettable: "false"]
	UI_ScriptItem script;
	[TRIGGER: "WidgetTriggers", BluePrint_Trigger_Type : "client_trigger"]
	TriggerSet triggers;
	[TAB: "Base", GUIWindow_Name: "true", RegExp: "[A-Z0-9a-z_.]*", Update: "true", Resettable: "false"]
	string name;
	[Enabled: "false", Resettable:"false"]
	string gui_type;		#窗口类型
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool Visible = true;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	Anchor anchor;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	UVector2 pos;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	UVector2 size;
	[GROUP: "GUI.WINDOW_BASE.BASE/ROTATION", Alias: "MyVector3"]
	UIRotation Rotation;

	[GROUP: "GUI.WINDOW_BASE.BASE/ROTATION/ROTATIONPIVOT", Step : "0.01", Update: "true"]
	Percentage PivotX = Percentage(value = 0.5);
	[GROUP: "GUI.WINDOW_BASE.BASE/ROTATION/ROTATIONPIVOT", Step : "0.01", Update: "true"]
	Percentage PivotY = Percentage(value = 0.5);

	#Vector3 Rotation;
	[Min: "0", Max: "1",GROUP: "GUI.WINDOW_BASE.BASE", Update: "true", Step: "0.05", ShowSlider:"true"]
	number Alpha = 1;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	hide bool lock = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool ClippedByParent = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	bool Disabled = false;
	[GROUP: "GUI.WINDOW_BASE.BASE"]
	MousePassThrough WindowTouchThroughMode;
	[Min: "0", Max: "1",GROUP: "GUI.WINDOW_BASE.BASE", Step: "0.05", ShowSlider:"true"]
	number WindowTouchThroughAlpha = 1;
	[Store: "0", UndoStack: "barrier"]
	hide number ZIndex = 0;
	[GROUP: "GUI.WINDOW_BASE.BASE/SOUND"]
	SoundTriggerRange SoundTriggerRange;
	[GROUP: "GUI.WINDOW_BASE.BASE/SOUND",Min: "0", Max: "1"]
	number Volume = 1;
	[GROUP: "GUI.WINDOW_BASE.BASE/SOUND"]
	Resource_Sound SoundFile;
	#Margin MarginProperty;
};

struct Window : Window_Base
{
	attrs_updater(function(self)
		if self.WindowTouchThroughMode ~= "MousePassThroughAlpha" then
			set_attr(self, "WindowTouchThroughAlpha", "Visible", "false")
		end
	end);

	monitor("WindowTouchThroughMode", function(self, path, oval)
		if self.WindowTouchThroughMode == "MousePassThroughAlpha" then
			set_attr(self, "WindowTouchThroughAlpha", "Visible", "true")
		else
			set_attr(self, "WindowTouchThroughAlpha", "Visible", "false")
		end
	end);
	hide Window_Base children[];
};

[Catalog: "base"]
struct DefaultWindow : Window{
	base(gui_type = "DefaultWindow",name = "DefaultWindow", size = UVector2(UDim_X = UDim(Scale = 0,Offect =400), UDim_Y = UDim(Scale = 0,Offect =300)));
	attrs_updater(function(self)
		set_attr(self, "SoundTriggerRange", "Visible", "false")
		set_attr(self, "Volume", "Visible", "false")
		set_attr(self, "SoundFile", "Visible", "false")
	end);
};

[Catalog: "advance"]
struct CustomHorizontalSlider : Window{
	base(gui_type = "CustomHorizontalSlider",name = "CustomSlider", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 32)));
	[GROUP: "GUI.HORIZONTALSLIDER", Update: "true"]
	number CurrentValue;
	[GROUP: "GUI.HORIZONTALSLIDER", Update: "true"]
	number MaximumValue = 1;
};

[Catalog: "advance"]
struct CustomVerticalSlider : Window{
	base(gui_type = "CustomVerticalSlider",name = "CustomSlider", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 32), UDim_Y = UDim(Scale = 0,Offect = 256)));
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	number CurrentValue;
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	number MaximumValue = 1;
};

[Catalog: ""]
struct SliderThumb : Window{
	base(gui_type = "Thumb",name = "SliderThumb", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 32), UDim_Y = UDim(Scale = 0,Offect = 32)));
	Resource_CEGUITexture thumb_image = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_thumb.png", asset = "asset/Texture/Gui/slider_thumb.png", name = "slider_thumb.png");
	ImageStretch thumb_stretch = ImageStretch(image_type = "thumb_image");
};

[Catalog: ""]
struct VSliderThumb : Window{
	base(gui_type = "Thumb",name = "SliderThumb", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 32), UDim_Y = UDim(Scale = 0,Offect = 32)));
	Resource_CEGUITexture thumb_image = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_thumb.png", asset = "asset/Texture/Gui/slider_thumb.png", name = "slider_thumb.png");
	ImageStretch thumb_stretch = ImageStretch(image_type = "thumb_image");
};

[Catalog: "base"]
struct StaticText : Window{
	base(gui_type = "StaticText", name = "Text", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 128)));
	attrs_updater(function(self)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
		set_attr(self, "MinAutoTextScale", "Visible", self.AutoTextScale and "true" or "false")
		set_attr(self, "TextWordBreak", "Visible", self.word_warpped and "true" or "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_StaticText")
		
	end);
	
	[GROUP: "GUI.STATICTEXT", Update: "true", Long:	"true"]
	string Text = "Here is text";
	[GROUP: "GUI.STATICTEXT", Alias:"Resource_Font"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.STATICTEXT",Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.STATICTEXT"]
	EAutoScale AutoScale = "0";
	[GROUP: "GUI.STATICTEXT"]
	bool AutoTextScale = false;
	monitor("AutoTextScale", function(self, path, oval)
		set_attr(self, "MinAutoTextScale", "Visible", self.AutoTextScale and "true" or "false")
	end);
	[GROUP: "GUI.STATICTEXT",Min:"8", Max:"72",Integer: "true", Update: "true"]
	number MinAutoTextScale = 8;
	[GROUP: "GUI.STATICTEXT"]
	TextBold TextBoldWeight = "0";
	[GROUP: "GUI.STATICTEXT"]
	Color TextColours = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.STATICTEXT"]
	bool BackgroundEnabled = false;
	[GROUP: "GUI.STATICTEXT"]
	Color BackgroundColours;
	monitor("BackgroundEnabled", function(self, path, oval)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICTEXT"]
	bool FrameEnabled = false;
	[GROUP: "GUI.STATICTEXT"]
	Color FrameColours; 
	monitor("FrameEnabled", function(self, path, oval)
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICTEXT"]
	bool word_warpped = true;
	monitor("word_warpped",function(self,path,oval)
		set_attr(self, "TextWordBreak", "Visible", self.word_warpped and "true" or "false")
	end);
	[GROUP: "GUI.STATICTEXT"]
	bool TextWordBreak = false;

	[GROUP: "GUI.STATICTEXT"]
	HorzAlignment HorzFormatting = "LeftAligned";
	[GROUP: "GUI.STATICTEXT"]
	VertAlignment VertFormatting = "TopAligned";

	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.STATICTEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.STATICTEXT"]
	Color BorderColor;
};

[Catalog: "base"]
struct StaticImage : Window{
	base(gui_type = "StaticImage", name = "Image", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 128), UDim_Y = UDim(Scale = 0,Offect = 128)));
	attrs_updater(function(self)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(stretch, "top_left", "Visible", "true")
			set_attr(stretch, "bottom_left", "Visible", "true")
		else
			set_attr(stretch, "top_left","Visible", "false")
			set_attr(stretch, "bottom_left","Visible", "false")
		end
		if vert == "Stretched" then
			set_attr(stretch, "top_right", "Visible", "true")
			set_attr(stretch, "bottom_right", "Visible", "true")
		else
			set_attr(stretch, "top_right","Visible", "false")
			set_attr(stretch, "bottom_right","Visible", "false")
		end

		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_StaticImage")

		self.StaticImageStretch.tailoring_top_left = self.StaticImageCutStretch.top_left
		self.StaticImageStretch.tailoring_top_right = self.StaticImageCutStretch.top_right
		self.StaticImageStretch.tailoring_bottom_left = self.StaticImageCutStretch.bottom_left
		self.StaticImageStretch.tailoring_bottom_right = self.StaticImageCutStretch.bottom_right
		self.resize.tailoring_top_left = self.StaticImageCutStretch.top_left
		self.resize.tailoring_top_right = self.StaticImageCutStretch.top_right
		self.resize.tailoring_bottom_left = self.StaticImageCutStretch.bottom_left
		self.resize.tailoring_bottom_right = self.StaticImageCutStretch.bottom_right

		if self.FillType == "Horizontal" or self.FillType == "Vertical" then
			set_attr(self, "AntiClockwise","Visible", "false")
		else
			set_attr(self, "AntiClockwise","Visible", "true")
		end
		set_attr(self, "FillPosition", "ENUM_LIST", self.FillType)
		set_attr(self, "IsDisplayUIMask", "Visible", self.IsUIMask and "true" or "false")
	end);

	[GROUP: "GUI.STATICIMAGE"]
	HorzScaling horzFormatting = "Stretched";
	monitor("horzFormatting", function(self, path, oval)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(stretch, "top_left", "Visible", "true")
			set_attr(stretch, "bottom_left", "Visible", "true")
		else
			set_attr(stretch, "top_left","Visible", "false")
			set_attr(stretch, "bottom_left","Visible", "false")
		end
		
	end);

	[GROUP: "GUI.STATICIMAGE"]
	VertsSaling vertFormatting = "Stretched";
	monitor("vertFormatting", function(self, path, oval)
		local horz = self.horzFormatting
		local vert = self.vertFormatting
		local stretch = self.StaticImageStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "StaticImageStretch", "Visible", "false")
		else
			set_attr(self, "StaticImageStretch", "Visible", "true")
		end
		if vert == "Stretched" then
			set_attr(stretch, "top_right", "Visible", "true")
			set_attr(stretch, "bottom_right", "Visible", "true")
		else
			set_attr(stretch, "top_right","Visible", "false")
			set_attr(stretch, "bottom_right","Visible", "false")
		end
	end);

	[GROUP: "GUI.STATICIMAGE"]
	FillType FillType = "Horizontal";

	monitor("FillType", function(self, path, oval)
		if self.FillType == "Horizontal" then
			FillPosition = "Left_Horizontal"
		elseif self.FillType == "Vertical" then
			FillPosition = "Bottom_Vertical"
		elseif self.FillType == "With90Degree" then
			FillPosition = "LeftTop_With90Degree"
		elseif self.FillType == "With180Degree" then
			FillPosition = "Left_With180Degree"
		elseif self.FillType == "With360Degree" then
			FillPosition = "Top_With360Degree"
		end

		self.FillPosition = FillPosition
		set_attr(self, "FillPosition", "ENUM_LIST", self.FillType)

		if self.FillType == "Horizontal" or self.FillType == "Vertical" then
			set_attr(self, "AntiClockwise","Visible", "false")
		else
			set_attr(self, "AntiClockwise","Visible", "true")
		end
	end);

	[GROUP: "GUI.STATICIMAGE", ENUM_LIST:"", Resettable: "false"]
	FillPosition FillPosition = "Left_Horizontal";

	[GROUP: "GUI.STATICIMAGE", Min: "0.0", Max:"1.0",Step:"0.05"]
	number FillArea = 1;

	[GROUP: "GUI.STATICIMAGE",Visible: "false"]
	bool AntiClockwise = false;

	[GROUP: "GUI.STATICIMAGE", Resettable: "false"]
	Resource_CEGUITexture Image = Resource_CEGUITexture(selector = "asset/Texture/Gui/def_image.png", asset = "asset/Texture/Gui/def_image.png", name = "def_image.png");
	monitor("Image", function(self, path, oval)
		--切换图片时重置裁剪
		local stretch_node = self.StaticImageCutStretch
		stretch_node.top_left = 0
		stretch_node.bottom_left = 0
		stretch_node.top_right = 0
		stretch_node.bottom_right = 0
		--切换图片时重置裁剪
		local image_stretch_node = self.StaticImageStretch
		image_stretch_node.top_left = 0
		image_stretch_node.bottom_left = 0
		image_stretch_node.top_right = 0
		image_stretch_node.bottom_right = 0
	end);

	[GROUP: "GUI.STATICIMAGE", Resettable: "false"]
	ImageStretch StaticImageStretch = ImageStretch(image_type = "Image");
	[GROUP: "GUI.STATICIMAGE", IsCut:"true", Resettable: "false"]
	ImageStretch StaticImageCutStretch = ImageStretch(image_type = "Image");
	#新属性面板要求数据之间的影响放到配置文件中，qt只负责显示数据，不转化数据
	monitor("StaticImageCutStretch", function(self, path, oval)
		--裁剪被编辑时重置边距和resize大小
		--将裁剪的数据传到拉伸中
		self.StaticImageStretch.tailoring_top_left = self.StaticImageCutStretch.top_left
		self.StaticImageStretch.tailoring_top_right = self.StaticImageCutStretch.top_right
		self.StaticImageStretch.tailoring_bottom_left = self.StaticImageCutStretch.bottom_left
		self.StaticImageStretch.tailoring_bottom_right = self.StaticImageCutStretch.bottom_right
		--将裁剪的数据传入Resize中
		self.resize.tailoring_top_left = self.StaticImageCutStretch.top_left
		self.resize.tailoring_top_right = self.StaticImageCutStretch.top_right
		self.resize.tailoring_bottom_left = self.StaticImageCutStretch.bottom_left
		self.resize.tailoring_bottom_right = self.StaticImageCutStretch.bottom_right
		--裁剪完成之后重置边距
		self.StaticImageStretch.top_left = 0
		self.StaticImageStretch.top_right = 0
		self.StaticImageStretch.bottom_left = 0
		self.StaticImageStretch.bottom_right = 0
	end);

	[GROUP: "GUI.STATICIMAGE", Resettable: "false"]
	Resize resize;
	[GROUP: "GUI.STATICIMAGE"]
	Color ImageColours; 
	[GROUP: "GUI.STATICIMAGE"]
	bool FrameEnabled = false;
	[GROUP: "GUI.STATICIMAGE"]
	Color FrameColours;
	monitor("FrameEnabled", function(self, path, oval)
		set_attr(self, "FrameColours", "Visible", self.FrameEnabled and "true" or "false")
	end);
	[GROUP: "GUI.STATICIMAGE"]
	bool BackgroundEnabled = false;
	[GROUP: "GUI.STATICIMAGE"]
	Color BackgroundColours;
	monitor("BackgroundEnabled", function(self, path, oval)
		set_attr(self, "BackgroundColours", "Visible", self.BackgroundEnabled and "true" or "false")
	end);

	[GROUP: "GUI.STATICIMAGE"]
	EImageBlendMode ImageBlendMode = "0";

	[GROUP: "GUI.STATICIMAGE"]
	hide EImageBlendFactor ImageSrcBlend = "2";

	[GROUP: "GUI.STATICIMAGE"]
	hide EImageBlendFactor ImageDstBlend = "4";
	
	[GROUP: "GUI.STATICIMAGE"]
	hide EImageBlendOperation ImageBlendOperation = "0";

	[TAB: "Expression"]
	bool IsUIMask = false;
	[TAB: "Expression"]
	bool IsDisplayUIMask = false;
	monitor("IsUIMask", function(self, path, oval)
		set_attr(self, "IsDisplayUIMask", "Visible", self.IsUIMask and "true" or "false")
	end);
};

[Catalog: "base"]
struct Button : Window{
	base(gui_type = "Button", name = "Button", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 96), UDim_Y = UDim(Scale = 0,Offect = 32)));
	attrs_updater(function(self)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(nor_stretch, "top_left", "Visible", "true")
			set_attr(nor_stretch, "bottom_left", "Visible", "true")
			set_attr(dis_stretch, "top_left", "Visible", "true")
			set_attr(dis_stretch, "bottom_left", "Visible", "true")
			set_attr(pus_stretch, "top_left", "Visible", "true")
			set_attr(pus_stretch, "bottom_left", "Visible", "true")
		else
			set_attr(nor_stretch, "top_left", "Visible", "false")
			set_attr(nor_stretch, "bottom_left", "Visible", "false")
			set_attr(dis_stretch, "top_left", "Visible", "false")
			set_attr(dis_stretch, "bottom_left", "Visible", "false")
			set_attr(pus_stretch, "top_left", "Visible", "false")
			set_attr(pus_stretch, "bottom_left", "Visible", "false")
		end
		if vert == "Stretched" then
			set_attr(nor_stretch, "top_right", "Visible", "true")
			set_attr(nor_stretch, "bottom_right", "Visible", "true")
			set_attr(dis_stretch, "top_right", "Visible", "true")
			set_attr(dis_stretch, "bottom_right", "Visible", "true")
			set_attr(pus_stretch, "top_right", "Visible", "true")
			set_attr(pus_stretch, "bottom_right", "Visible", "true")
		else
			set_attr(nor_stretch, "top_right", "Visible", "false")
			set_attr(nor_stretch, "bottom_right", "Visible", "false")
			set_attr(dis_stretch, "top_right", "Visible", "false")
			set_attr(dis_stretch, "bottom_right", "Visible", "false")
			set_attr(pus_stretch, "top_right", "Visible", "false")
			set_attr(pus_stretch, "bottom_right", "Visible", "false")
		end
		set_attr(self, "TextWordBreak", "Visible", self.btn_word_warpped and "true" or "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_Button")
		set_attr(self.TextOffset, "x", "Step","1")
		set_attr(self.TextOffset, "y", "Step","1")
	end);

	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Update: "true"]
	string Text = "Button";
	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Alias:"Resource_Font"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	bool AutoTextScale = false;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	TextBold TextBoldWeight = "0";
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color NormalTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	hide Color HoverTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color PushedTextColour;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	bool btn_word_warpped = false;
	monitor("btn_word_warpped",function(self,path,oval)
		set_attr(self, "TextWordBreak", "Visible", self.btn_word_warpped and "true" or "false")
	end);
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	bool TextWordBreak = false;
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.BUTTON/BUTTON_TEXT"]
	Color BorderColor;

	[GROUP: "GUI.BUTTON/BUTTON_TEXT", Alias:"Vector2D",Step:"1"]
	Vector2 TextOffset = Vector2(x=0,y=0);

	[GROUP: "GUI.BUTTON/BUTTON_IMAGE"]
	HorzScaling HorzImageFormatting = "Stretched";
	monitor("HorzImageFormatting", function(self, path, oval, op)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if horz == "Stretched" then
			set_attr(nor_stretch, "top_left", "Visible", "true")
			set_attr(nor_stretch, "bottom_left", "Visible", "true")
			set_attr(dis_stretch, "top_left", "Visible", "true")
			set_attr(dis_stretch, "bottom_left", "Visible", "true")
			set_attr(pus_stretch, "top_left", "Visible", "true")
			set_attr(pus_stretch, "bottom_left", "Visible", "true")
		else
			set_attr(nor_stretch, "top_left", "Visible", "false")
			set_attr(nor_stretch, "bottom_left", "Visible", "false")
			set_attr(dis_stretch, "top_left", "Visible", "false")
			set_attr(dis_stretch, "bottom_left", "Visible", "false")
			set_attr(pus_stretch, "top_left", "Visible", "false")
			set_attr(pus_stretch, "bottom_left", "Visible", "false")
		end
	end);

	[GROUP: "GUI.BUTTON/BUTTON_IMAGE"]
	VertsSaling VertImageFormatting = "Stretched";
	monitor("VertImageFormatting", function(self, path, oval, op)
		local horz = self.HorzImageFormatting
		local vert = self.VertImageFormatting
		local nor_stretch = self.NormalStretch
		local dis_stretch = self.DisabledStretch
		local pus_stretch = self.PushedStretch
		if horz ~= "Stretched" and vert ~= "Stretched" then
			set_attr(self, "NormalStretch","Visible", "false")
			set_attr(self, "DisabledStretch","Visible", "false")
			set_attr(self, "PushedStretch","Visible", "false")
		else
			set_attr(self, "NormalStretch","Visible", "true")
			set_attr(self, "DisabledStretch","Visible", "true")
			set_attr(self, "PushedStretch","Visible", "true")
		end
		if vert == "Stretched" then
			set_attr(nor_stretch, "top_right", "Visible", "true")
			set_attr(nor_stretch, "bottom_right", "Visible", "true")
			set_attr(dis_stretch, "top_right", "Visible", "true")
			set_attr(dis_stretch, "bottom_right", "Visible", "true")
			set_attr(pus_stretch, "top_right", "Visible", "true")
			set_attr(pus_stretch, "bottom_right", "Visible", "true")
		else
			set_attr(nor_stretch, "top_right", "Visible", "false")
			set_attr(nor_stretch, "bottom_right", "Visible", "false")
			set_attr(dis_stretch, "top_right", "Visible", "false")
			set_attr(dis_stretch, "bottom_right", "Visible", "false")
			set_attr(pus_stretch, "top_right", "Visible", "false")
			set_attr(pus_stretch, "bottom_right", "Visible", "false")
		end
	end);

	[GROUP: "GUI.BUTTON/BUTTON_NORMALIMAGE", Resettable: "false"]
	Resource_CEGUITexture NormalImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/button_green_nor.png", asset = "asset/Texture/Gui/button_green_nor.png", name = "button_green_nor.png");
	[GROUP: "GUI.BUTTON/BUTTON_NORMALIMAGE", Resettable: "false"]
	ImageStretch NormalStretch = ImageStretch(image_type = "NormalImage");
	hide Resource_CEGUITexture HoverImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/button_green_nor.png", asset = "asset/Texture/Gui/button_green_nor.png", name = "button_green_nor.png");
	hide ImageStretch HoverStretch = ImageStretch(image_type = "HoverImage");
	[GROUP: "GUI.BUTTON/BUTTON_DISABLEDIMAGE", Resettable: "false"]
	Resource_CEGUITexture DisabledImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/button_green_disable.png", asset = "asset/Texture/Gui/button_green_disable.png", name = "button_green_disable.png");
	[GROUP: "GUI.BUTTON/BUTTON_DISABLEDIMAGE", Resettable: "false"]
	ImageStretch DisabledStretch = ImageStretch(image_type = "DisabledImage");
	[GROUP: "GUI.BUTTON/BUTTON_PUSHEDIMAGE", Resettable: "false"]
	Resource_CEGUITexture PushedImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/button_green_act.png", asset = "asset/Texture/Gui/button_green_act.png", name = "button_green_act.png");
	[GROUP: "GUI.BUTTON/BUTTON_PUSHEDIMAGE", Resettable: "false"]
	ImageStretch PushedStretch = ImageStretch(image_type = "PushedImage");
	

	monitor("NormalImage", function(self, path, oval, op)
		self.HoverImage.selector = self.NormalImage.selector
		self.HoverImage.asset = self.NormalImage.asset
		self.HoverImage.imageset_key = self.NormalImage.imageset_key
	end);

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);

	monitor("NormalStretch",function(self, path, oval, op)
		self.HoverStretch.top_left = self.NormalStretch.top_left
		self.HoverStretch.top_right = self.NormalStretch.top_right
		self.HoverStretch.bottom_left = self.NormalStretch.bottom_left
		self.HoverStretch.bottom_right = self.NormalStretch.bottom_right
	end);
};

[Catalog: "base"]
struct ProgressBar : Window{
	base(gui_type = "ProgressBar", name = "ProgressBar", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 32)));
	
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_ProgressBar")
	end);

	[Min : "0", Max : "1", Step : "0.01", GROUP: "GUI.PROGRESSBAR", Update: "true"]
	Percentage CurrentProgress;
	[GROUP: "GUI.PROGRESSBAR"]
	bool VerticalProgress = false;
	[GROUP: "GUI.PROGRESSBAR"]
	bool ReversedProgress = false;
	[GROUP: "GUI.PROGRESSBAR", Resettable: "false"]
	Resource_CEGUITexture progress_lights_image = Resource_CEGUITexture(selector = "asset/Texture/Gui/progressbar_top.png", asset = "asset/Texture/Gui/progressbar_top.png", name = "progressbar_top.png");
	[GROUP: "GUI.PROGRESSBAR", Resettable: "false"]
	ImageStretch ProgressLightsStretch = ImageStretch(image_type = "progress_lights_image");
	[GROUP: "GUI.PROGRESSBAR", Resettable: "false"]
	Resource_CEGUITexture progress_background_image = Resource_CEGUITexture(selector = "asset/Texture/Gui/progressbar_bg.png", asset = "asset/Texture/Gui/progressbar_bg.png", name = "progressbar_bg.png");
	[GROUP: "GUI.PROGRESSBAR", Resettable: "false"]
	ImageStretch ProgressBgStretch = ImageStretch(image_type = "progress_background_image");
};

[Catalog: "base"]
struct Editbox : Window{
	base(gui_type = "Editbox", name = "Editbox", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 32)));
	
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_Editbox")
	end);
	
	[GROUP: "GUI.EDITBOX", Update: "true"]
	string Text;
	[GROUP: "GUI.EDITBOX", Alias:"Resource_Font"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.EDITBOX", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.EDITBOX"]
	TextBold TextBoldWeight = "0";
	[GROUP: "GUI.EDITBOX"]
	Color NormalTextColour = Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.EDITBOX"]
	Color SelectedTextColour = Color( r = 255, g = 255, b = 255, a = 255);
	[GROUP: "GUI.EDITBOX"]
	Color ReadOnlyBGColour = Color( r = 223, g = 223, b = 223, a = 255);
	[GROUP: "GUI.EDITBOX"]
	bool MaskText;
	[Integer: "true",GROUP: "GUI.EDITBOX",Min:"0",Max:"10000"]
	number MaxTextLength = 10000;
	[GROUP: "GUI.EDITBOX"]
	bool ReadOnly = false;
	[GROUP: "GUI.EDITBOX", Resettable: "false"]
	Resource_CEGUITexture BackGroundImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/editorbox_bg.png", asset = "asset/Texture/Gui/editorbox_bg.png", name = "editorbox_bg.png");
	[GROUP: "GUI.EDITBOX", Resettable: "false"]
	ImageStretch BackGroundStretch = ImageStretch(image_type = "BackGroundImage");
	[GROUP: "GUI.EDITBOX"]
	Color ActiveSelectionColour = Color( r = 96, g = 127, b = 255, a = 255);
};

[Catalog: "base"]
struct Checkbox : Window{
	base(gui_type = "Checkbox", name = "Checkbox", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 36)));
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_Checkbox")
	end);
	[GROUP: "GUI.CHECKBOX"]
	bool Selected;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT", Update: "true"]
	string Text = "Checkbox";
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT", Alias:"Resource_Font"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT", Min:"8", Max:"72", Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	TextBold TextBoldWeight = "0";
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color NormalTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	hide Color HoverTextColour;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color PushedTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_TEXT"]
	Color BorderColor;
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE", Resettable: "false"]
	Resource_CEGUITexture unselectableImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/checkbox_unselectable.png", asset = "asset/Texture/Gui/checkbox_unselectable.png", name = "checkbox_unselectable.png");
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE", Resettable: "false"]
	ImageStretch UnselectableStretch = ImageStretch(image_type = "unselectableImage");
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE", Resettable: "false"]
	Resource_CEGUITexture selectableImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/checkbox_selectable.png", asset = "asset/Texture/Gui/checkbox_selectable.png", name = "checkbox_selectable.png");
	[GROUP: "GUI.CHECKBOX/CHECKBOX_IMAGE", Resettable: "false"]
	ImageStretch SelectableStretch = ImageStretch(image_type = "selectableImage");

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);
};

[Catalog: "base"]
struct RadioButton : Window{
	base(gui_type = "RadioButton", name = "RadioButton", size = UVector2(UDim_X = UDim(Scale = 0,Offect = 256), UDim_Y = UDim(Scale = 0,Offect = 36)));
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_RadioButton")
		if self.TextXPos == "1" and self.HorzLabelFormatting == "LeftAligned" and self.ImageXSizeImcress == "0" then
			self.check_box_tile = "LeftRight"
		else
			self.check_box_tile = "Center"
		end
	end);
	[GROUP: "GUI.RADIOBUTTON"]
	bool Selected;
	[Min: "0", Max: "10000000", Integer: "true", GROUP: "GUI.RADIOBUTTON"]
	number GroupID = 0;

	[GROUP: "GUI.RADIOBUTTON"]
	CheckBoxTile check_box_tile = "LeftRight";
	hide string TextXPos = "1";
	hide string HorzLabelFormatting = "LeftAligned";
	hide string ImageXSizeImcress = "0";
	monitor("check_box_tile",function(self,path,oval)
		local is_left_right = self.check_box_tile == "LeftRight"
		self.TextXPos = is_left_right and "1" or "0"
		self.HorzLabelFormatting = is_left_right and "LeftAligned" or "CentreAligned"
		self.ImageXSizeImcress = is_left_right and "0" or "1"
	end);
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT", Update: "true"]
	string Text = "Radiobutton";
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT", Alias:"Resource_Font"]
	Resource_Font Font = "DroidSans";
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT", Min:"8", Max:"72",Integer: "true", Update: "true"]
	number Font_size = 12;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	TextBold TextBoldWeight = "0";
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color NormalTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	hide Color HoverTextColour;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color DisabledTextColour = Color( r = 136, g = 136, b = 136, a = 255);
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color PushedTextColour =  Color( r = 0, g = 0, b = 0, a = 255);
	
	[Integer: "true",Min: "0", Max: "10", Update: "true", GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	number BorderWidth = 0;
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_TEXT"]
	Color BorderColor;

	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE", Resettable: "false"]
	Resource_CEGUITexture unselectableImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/radio_button_unselectable.png", asset = "asset/Texture/Gui/radio_button_unselectable.png", name = "radio_button_unselectable.png");
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE", Resettable: "false"]
	ImageStretch UnselectableStretch = ImageStretch(image_type = "unselectableImage");
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE", Resettable: "false"]
	Resource_CEGUITexture selectableImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/radio_button_selectable.png", asset = "asset/Texture/Gui/radio_button_selectable.png", name = "radio_button_selectable.png");
	[GROUP: "GUI.RADIOBUTTON/RADIOBUTTON_IMAGE", Resettable: "false"]
	ImageStretch SelectableStretch = ImageStretch(image_type = "selectableImage");

	monitor("NormalTextColour",function(self, path, oval, op)
		self.HoverTextColour.r = self.NormalTextColour.r
		self.HoverTextColour.g = self.NormalTextColour.g
		self.HoverTextColour.b = self.NormalTextColour.b
		self.HoverTextColour.a = self.NormalTextColour.a
	end);
};

## 通过结构体动态更新double_editor的最大最小值
[Max:"1000000",Min:"-1000000"]
struct Double_Update_MaxMinStep{
	number value = 0;
	number min = -1000000;
	number max = 1000000;
	number step = 1;
};

[Catalog: "base"]
struct HorizontalSlider : Window{
	base(gui_type = "HorizontalSlider", name = "Slider",size = UVector2(UDim_X = UDim(Scale = 0,Offect =254), UDim_Y = UDim(Scale = 0,Offect = 30)));
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_Slider")
		set_attr(self, "CurrentValue_Control", "Max", "100000")
		set_attr(self, "CurrentValue_Control", "Min", "-100000")
		self.MinValue_Control.max = self.MaximumValue
		self.MaximumValue_Control.min = self.MinValue
	end);

	monitor("CurrentValue_Control", function(self, path, oval)
		self.CurrentValue = self.CurrentValue_Control.value
	end);

	monitor("MaximumValue_Control", function(self, path, oval)
		local maximum = self.MaximumValue_Control.value
		if maximum < self.CurrentValue_Control.value then
			 self.CurrentValue_Control.value = maximum
		end
		self.ClickStep_Control.max = maximum
		self.MaximumValue = maximum
		self.CurrentValue_Control.max = maximum
		self.MinValue_Control.max = maximum
	end);

	monitor("MinValue_Control", function(self, path, oval)
		local minimum = self.MinValue_Control.value
		if minimum > self.CurrentValue_Control.value then
			 self.CurrentValue_Control.value = minimum
		end
		self.MinValue = minimum
		self.CurrentValue_Control.min = minimum
		self.MaximumValue_Control.min = minimum
	end);

	monitor("ClickStep_Control", function(self, path, oval)
		self.ClickStep = self.ClickStep_Control.value
	end);

	[GROUP: "GUI.HORIZONTALSLIDER",Update: "true"]
	Double_Update_MaxMinStep CurrentValue_Control;
	[GROUP: "GUI.HORIZONTALSLIDER",Update: "true"]
	Double_Update_MaxMinStep MinValue_Control;
	[GROUP: "GUI.HORIZONTALSLIDER",Update: "true"]
	Double_Update_MaxMinStep MaximumValue_Control = Double_Update_MaxMinStep(value = 1);
	[GROUP: "GUI.HORIZONTALSLIDER"]
	Double_Update_MaxMinStep ClickStep_Control = Double_Update_MaxMinStep(value = 1);
	[GROUP: "GUI.HORIZONTALSLIDER"]
	hide number CurrentValue;
	[GROUP: "GUI.HORIZONTALSLIDER",Update: "true"]
	hide number MinValue = 0;
	[GROUP: "GUI.HORIZONTALSLIDER",Update: "true"]
	hide number MaximumValue = 1;
	[GROUP: "GUI.HORIZONTALSLIDER", Min: "0"]
	hide number ClickStep = 1;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	bool WholeNumbers = false;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	bool MoveByStep = false;
	[GROUP: "GUI.HORIZONTALSLIDER"]
	hide bool ReversedDirection = false;
	[GROUP: "GUI.HORIZONTALSLIDER", Resettable: "false"]
	Resource_CEGUITexture slider_top = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_top_h.png", asset = "asset/Texture/Gui/slider_top_h.png", name = "slider_top_h.png");
	[GROUP: "GUI.HORIZONTALSLIDER", Resettable: "false"]
	ImageStretch TopImageStretch = ImageStretch(image_type = "slider_top");
	[GROUP: "GUI.HORIZONTALSLIDER", Resettable: "false"]
	Resource_CEGUITexture slider_bg = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_bg.png", asset = "asset/Texture/Gui/slider_bg.png", name = "slider_bg.png");
	[GROUP: "GUI.HORIZONTALSLIDER", Resettable: "false"]
	ImageStretch BgImageStretch = ImageStretch(image_type = "slider_bg");
	[GROUP: "GUI.HORIZONTALSLIDER"]
	Thumb thumb;
};

[Catalog: "base"]
struct VerticalSlider : Window{
	base(gui_type = "VerticalSlider", name = "Slider",size = UVector2(UDim_X = UDim(Scale = 0,Offect = 30), UDim_Y = UDim(Scale = 0,Offect = 254)));
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_Slider")
		set_attr(self, "CurrentValue_Control", "Max", "100000")
		set_attr(self, "CurrentValue_Control", "Min", "-100000")
		self.MinValue_Control.max = self.MaximumValue
		self.MaximumValue_Control.min = self.MinValue
	end);

	monitor("CurrentValue_Control", function(self, path, oval)
		self.CurrentValue = self.CurrentValue_Control.value
	end);

	monitor("MaximumValue_Control", function(self, path, oval)
		local maximum = self.MaximumValue_Control.value
		if maximum < self.CurrentValue_Control.value then
			 self.CurrentValue_Control.value = maximum
		end
		self.ClickStep_Control.max = maximum
		self.MaximumValue = maximum
		self.CurrentValue_Control.max = maximum
		self.MinValue_Control.max = maximum
	end);

	monitor("MinValue_Control", function(self, path, oval)
		local minimum = self.MinValue_Control.value
		if minimum > self.CurrentValue_Control.value then
			 self.CurrentValue_Control.value = minimum
		end
		self.MinValue = minimum
		self.CurrentValue_Control.min = minimum
		self.MaximumValue_Control.min = minimum
	end);

	monitor("ClickStep_Control", function(self, path, oval)
		self.ClickStep = self.ClickStep_Control.value
	end);
	
	[GROUP: "GUI.VERTICALSLIDER",Update: "true"]
	Double_Update_MaxMinStep CurrentValue_Control;
	[GROUP: "GUI.VERTICALSLIDER",Update: "true"]
	Double_Update_MaxMinStep MinValue_Control;
	[GROUP: "GUI.VERTICALSLIDER",Update: "true"]
	Double_Update_MaxMinStep MaximumValue_Control = Double_Update_MaxMinStep(value = 1);
	[GROUP: "GUI.VERTICALSLIDER"]
	Double_Update_MaxMinStep ClickStep_Control = Double_Update_MaxMinStep(value = 1);
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	hide number CurrentValue;
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	hide number MinValue = 0;
	[GROUP: "GUI.VERTICALSLIDER", Update: "true"]
	hide number MaximumValue = 1;
	[GROUP: "GUI.VERTICALSLIDER", Min: "0"]
	hide number ClickStep = 1;
	[GROUP: "GUI.VERTICALSLIDER"]
	bool WholeNumbers = false;
	[GROUP: "GUI.VERTICALSLIDER"]
	bool MoveByStep = false;
	[GROUP: "GUI.VERTICALSLIDER"]
	hide bool ReversedDirection = false;
	[GROUP: "GUI.VERTICALSLIDER", Resettable: "false"]
	Resource_CEGUITexture slider_top = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_top_v.png", asset = "asset/Texture/Gui/slider_top_v.png", name = "slider_top_v.png");
	[GROUP: "GUI.VERTICALSLIDER", Resettable: "false"]
	ImageStretch TopImageStretch = ImageStretch(image_type = "slider_top");
	[GROUP: "GUI.VERTICALSLIDER", Resettable: "false"]
	Resource_CEGUITexture slider_bg = Resource_CEGUITexture(selector = "asset/Texture/Gui/slider_bg.png", asset = "asset/Texture/Gui/slider_bg.png", name = "slider_bg.png");
	[GROUP: "GUI.VERTICALSLIDER", Resettable: "false"]
	ImageStretch BgImageStretch = ImageStretch(image_type = "slider_bg");
	[GROUP: "GUI.VERTICALSLIDER"]
	Thumb thumb;
};

[Nonempty : "true"]
enum ScrollRestrictType{
	"Elastic",
	"Clamped",
	"Unrestricted"
};

[Catalog: "base"]
struct ScrollableView : Window{
	base(gui_type = "ScrollableView", name = "ScrollableView",size = UVector2(UDim_X = UDim(Scale = 0,Offect =200), UDim_Y = UDim(Scale = 0,Offect = 200)));
	
	attrs_updater(function(self)
		set_attr(self, "triggers", "TRIGGER", "Trigger_ScrollableView")
		set_attr(self, "ReboundTime", "Visible", self.ScrollRestrictType == "Elastic" and "true" or "false")
	end);

	monitor("ScrollRestrictType",function(self, path, oval, op)
		set_attr(self, "ReboundTime", "Visible", self.ScrollRestrictType == "Elastic" and "true" or "false")
	end);
	
	[GROUP: "GUI.SCROLLABLEVIEW",Max:"1",Min:"0"]
	number Resistance = 1;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	ScrollRestrictType ScrollRestrictType = "Clamped";
	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool HorizontalMovable = true;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool VerticalMovable = true;
	[GROUP: "GUI.SCROLLABLEVIEW",Max:"10",Min:"0"]
	number ReboundTime = 0.5;
	[GROUP: "GUI.SCROLLABLEVIEW"]
	hide bool moveAble = true;
	[GROUP: "GUI.SCROLLABLEVIEW", Resettable: "false"]
	Resource_CEGUITexture BackGroundImage = Resource_CEGUITexture(selector = "asset/Texture/Gui/scrollable_pane_bg.png", asset = "asset/Texture/Gui/scrollable_pane_bg.png", name = "scrollable_pane_bg.png");
	[GROUP: "GUI.SCROLLABLEVIEW", Resettable: "false"]
	ImageStretch BgImageStretch = ImageStretch(image_type = "BackGroundImage");
	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool ForceHorzScrollbar = true;
	[Min: "0", Max: "1",GROUP: "GUI.SCROLLABLEVIEW", Update: "true", Step: "0.01", ShowSlider:"true"]
	number HorzScrollPosition = 0;

	[GROUP: "GUI.SCROLLABLEVIEW"]
	bool ForceVertScrollbar = true;
	[Min: "0", Max: "1",GROUP: "GUI.SCROLLABLEVIEW", Update: "true", Step: "0.01", ShowSlider:"true"]
	number VertScrollPosition = 0;
};

[Catalog: "base"]
struct ActorWindow : Window{
	base(gui_type = "ActorWindow", name = "ActorWindow",size = UVector2(UDim_X = UDim(Scale = 0,Offect =200), UDim_Y = UDim(Scale = 0,Offect = 200)));
	
	attrs_updater(function(self)
		set_attr(self, "Alpha", "Visible", "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_ActorWindow")
	end);

	#模型
	[GROUP: "GUI.ACTORWINDOW", Resettable: "false"]
	Resource_Actor ActorName;

	#动作
	[GROUP: "GUI.ACTORWINDOW", Editable: "true",Alias:"ActionType"]
	ActionType SkillName = "idle";

	#旋转
	[GROUP: "GUI.ACTORWINDOW/ROTATION", Update: "true"]
	number RotateX;
	[GROUP: "GUI.ACTORWINDOW/ROTATION", Update: "true"]
	number RotateY;
	[GROUP: "GUI.ACTORWINDOW/ROTATION", Update: "true"]
	number RotateZ;

	[GROUP: "GUI.ACTORWINDOW/POSITION", Update: "true"]
	number PositionX;
	[GROUP: "GUI.ACTORWINDOW/POSITION", Update: "true"]
	number PositionY;

	#缩放
	[GROUP: "GUI.ACTORWINDOW", Min:"0", Max:"20" , Step: "0.1" , Update: "true"]
	number ActorScale = 1;

};

[Nonempty : "true"]
enum HorizontalLayoutContainerDir
{
	"Left",
	"Right"
};
[Catalog: "base"]
struct EffectWindow : Window{
	base(gui_type = "EffectWindow", name = "EffectWindow",size = UVector2(UDim_X = UDim(Scale = 0,Offect =200), UDim_Y = UDim(Scale = 0,Offect = 200)));
	
	attrs_updater(function(self)
		set_attr(self, "Alpha", "Visible", "false")
		set_attr(self, "WindowTouchThroughMode", "ENUM_LIST","EffectWindow")
		if self.EffectRotation.x ~= self.effectXRotate  or  self.EffectRotation.y ~= self.effectYRotate or  self.EffectRotation.z ~= self.effectZRotate then
			self.EffectRotation = {x = self.effectXRotate, y = self.effectYRotate, z = self.effectZRotate};
		end
		
		if self.EffectPosition.x ~= self.effectXPosition or self.EffectPosition.y ~= self.effectYPosition then
			self.EffectPosition = { x = self.effectXPosition, y = self.effectYPosition};
		end
	end);

	#模型
	[GROUP: "GUI.EFFECTWINDOW"]
	Resource_Effect effectName;

	#旋转
	hide number effectXRotate;
	hide number effectYRotate;
	hide number effectZRotate;
	[GROUP: "GUI.EFFECTWINDOW", Alias:"MyVector3", Update: "true"]
	Vector3 EffectRotation;

	monitor("EffectRotation",function(self, path, oval, op)
		if self.EffectRotation.x ~= self.effectXRotate then
			self.effectXRotate = self.EffectRotation.x
		end
		if self.EffectRotation.y ~= self.effectYRotate then
			self.effectYRotate = self.EffectRotation.y
		end
		if self.EffectRotation.z ~= self.effectZRotate then
			self.effectZRotate = self.EffectRotation.z
		end
	end);

	#坐标
	[GROUP: "GUI.EFFECTWINDOW", Alias:"Vector2D", Update: "true"]
	Vector2 EffectPosition;
	hide number effectXPosition;
	hide number effectYPosition;
	
	monitor("EffectPosition",function(self, path, oval, op)
		if self.EffectPosition.x ~= self.effectXPosition then
			self.effectXPosition = self.EffectPosition.x
		end
		if self.EffectPosition.y ~= self.effectYPosition then
			self.effectYPosition = self.EffectPosition.y
		end
	end);

	#缩放
	[GROUP: "GUI.EFFECTWINDOW", Min:"0", Max:"20" , Step: "0.1" , Update: "true"]
	number effectScale = 1;
};

[Catalog: "layout"]
struct HorizontalLayoutContainer : Window{
	base(gui_type = "HorizontalLayoutContainer", name = "HorizontalLayoutContainer", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		set_attr(self.size, "UDim_X", "Enabled", "false")
		set_attr(self.size, "UDim_Y", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Visible", "false")
		set_attr(self, "SoundTriggerRange", "Visible", "false")
		set_attr(self, "Volume", "Visible", "false")
		set_attr(self, "SoundFile", "Visible", "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_Container")
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
		set_attr(self.ChildrenSize, "y", "Min", "0")
		set_attr(self.ChildrenSize, "x", "Min", "0")
		set_attr(self, "space", "Min", "0")
	end);
	[GROUP: "GUI.HORIZONTALLAYOUTCONTAINER", Min: "0", Max: "10000", Update: "true"]
	number space = 0;
	[GROUP: "GUI.HORIZONTALLAYOUTCONTAINER"]
	HorizontalLayoutContainerDir dir = "Left";
	[GROUP: "GUI.HORIZONTALLAYOUTCONTAINER"]
	bool ControlChildrenSize = false;
	monitor("ControlChildrenSize",function(self,path,oval)
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
	end);

	[GROUP: "GUI.HORIZONTALLAYOUTCONTAINER", Alias:"Vector2D", Update:"true"]
	Vector2 ChildrenSize = Vector2(x = 128, y = 128);
};
[Nonempty : "true"]
enum VerticalLayoutContainerDir
{
	"Top",
	"Bottom"
};

[Catalog: "layout"]
struct VerticalLayoutContainer : Window{
	base(gui_type = "VerticalLayoutContainer", name = "VerticalLayoutContainer", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		set_attr(self.size, "UDim_X", "Enabled", "false")
		set_attr(self.size, "UDim_Y", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Visible", "false")
		set_attr(self, "SoundTriggerRange", "Visible", "false")
		set_attr(self, "Volume", "Visible", "false")
		set_attr(self, "SoundFile", "Visible", "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_Container")
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
		set_attr(self.ChildrenSize, "y", "Min", "0")
		set_attr(self, "space", "Min", "0")
	end);
	[GROUP: "GUI.VERTICALLAYOUTCONTAINER", Min: "0", Max: "10000", Update: "true"]
	number space = 0;
	[GROUP: "GUI.VERTICALLAYOUTCONTAINER"]
	VerticalLayoutContainerDir dir = "Top";
	[GROUP: "GUI.VERTICALLAYOUTCONTAINER"]
	bool ControlChildrenSize = false;
	monitor("ControlChildrenSize",function(self,path,oval)
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
	end);

	[GROUP: "GUI.VERTICALLAYOUTCONTAINER", Alias:"Vector2D", Update:"true"]
	Vector2 ChildrenSize = Vector2(x = 128, y = 128);
};

[Nonempty : "true"]
enum GridViewDir
{
	"LeftTop",
	"LeftBottom",
	"RightTop",
	"RightBottom"
};
[Catalog: "layout"]
struct GridView : Window {
	base(gui_type = "GridView", name = "GridView", size = UVector2(UDim_X = UDim(Scale = 0,Offect =100), UDim_Y = UDim(Scale = 0,Offect =100)));
	attrs_updater(function(self)
		set_attr(self.size, "UDim_X", "Enabled", "false")
		set_attr(self.size, "UDim_Y", "Enabled", "false")
		set_attr(self, "ClippedByParent", "Enabled", "false")
		set_attr(self, "SoundTriggerRange", "Visible", "false")
		set_attr(self, "Volume", "Visible", "false")
		set_attr(self, "SoundFile", "Visible", "false")
		set_attr(self, "triggers", "TRIGGER", "Trigger_Container")
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
		set_attr(self.ChildrenSize, "y", "Min", "0")
		set_attr(self.Space, "x", "Step","1")
		set_attr(self.Space, "y", "Step","1")
		set_attr(self.Space, "x", "Min", "0")
		set_attr(self.Space, "y", "Min", "0")
	end);
	[GROUP: "GUI.GRIDVIEW", Min: "0", Alias:"Vector2D", Update: "true"]
	Vector2 Space;
	[GROUP: "GUI.GRIDVIEW", Min: "1", Update: "true", Integer: "true"]
	number rowSize;
	[GROUP: "GUI.GRIDVIEW"]
	GridViewDir dir = "LeftTop";
	[GROUP: "GUI.GRIDVIEW"]
	bool ControlChildrenSize = false;
	monitor("ControlChildrenSize",function(self,path,oval)
		set_attr(self, "ChildrenSize", "Visible", self.ControlChildrenSize and "true" or "false")
	end);

	[GROUP: "GUI.GRIDVIEW", Alias:"Vector2D",Update: "true"]
	Vector2 ChildrenSize = Vector2(x = 128, y = 128);
};

struct LayoutCfg{
	attrs_updater(function(self)
		local window_attrs = require "we.logic.ui.window_attrs"
		window_attrs:init(self.root)
	end);
	[Property_Show_Root: "true"]
	UI_ScriptItem script;
	[Property_Show_Root: "true",TRIGGER: "WidgetTriggers",BluePrint_Trigger_Type : "client_trigger"]
	TriggerSet triggers;
	[UndoStack: "fork"]
	hide DefaultWindow root = DefaultWindow(name = "Root");
	hide string md5;
	hide string path;
};

####################################### part 系统 ####################################

struct PartCfg{
	[TRIGGER: "PartTriggers"]
	TriggerSet triggers;
};

struct MeshPartCfg{
	[TRIGGER: "MeshPartTriggers"]
	TriggerSet triggers;
};

struct PartOperationCfg{
	[TRIGGER: "PartOperationTriggers"]
	TriggerSet triggers;
};

struct CustomAttribute{
	string key;
	T_Base val;
};

#自定义属性
struct AddCustomAttribute
{
	#按钮
	AddAttribute btn;
	#自定义属性
	[TAB: "Base"]
	CustomAttribute attrs[];
};

struct Instance {
	hide bool isLockedInEditor = false;
	hide bool isVisibleInEditor = true;

	[TAB: "Base", Sync: "true"]
	string name;
	[TAB: "Base", Enabled: "false", Resettable:"false"]
	string class;
	[TAB: "Base",Enabled: "false",UndoStack: "barrier",Visible: "false"]
	string id;
	[Store: "0", UndoStack: "barrier"]
	hide bool selected;
	[Store: "0"]
	hide number selected_count = 0;
	hide Instance children[];
};

[Nonempty : "true"]
enum BatchType {
	"Static",
	"Dynamic",
	"None"
};

struct Instance_Spatial : Instance {
	attrs_updater(function(self)
		set_attr(self.size, "x", "Min", "0.01")
		set_attr(self.size, "y", "Min", "0.01")
		set_attr(self.size, "z", "Min", "0.01")
		
		set_attr(self.size, "x", "Decimal", "3")
		set_attr(self.size, "y", "Decimal", "3")
		set_attr(self.size, "z", "Decimal", "3")

		set_attr(self.position, "x", "Decimal", "3")
		set_attr(self.position, "y", "Decimal", "3")
		set_attr(self.position, "z", "Decimal", "3")

		set_attr(self.rotation, "x", "Decimal", "3")
		set_attr(self.rotation, "y", "Decimal", "3")
		set_attr(self.rotation, "z", "Decimal", "3")

		set_attr(self.scale, "x", "Min", "0.01")
		set_attr(self.scale, "y", "Min", "0.01")
		set_attr(self.scale, "z", "Min", "0.01")
		set_attr(self,"size","Resettable","false")
	end);

	[TAB: "Base", Alias:"MyVector3", Resettable:"false"]
	Vector3 position;
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 rotation;
	[TAB: "Base", Alias:"MyVector3", Min: "0.01", Max: "1000000", Step: "1"]
	Vector3 size = Vector3(x = 1, y = 1, z = 1);

	[TAB: "Base", Alias:"MyVector3", Visible: "false", Min: "0.01", Max: "1000000", Step: "1"]
	Vector3 scale = Vector3(x = 1, y = 1, z = 1);

	[TAB: "Base"]
	hide bool selectable = true;
	[TAB: "Base"]
	hide bool needSync = true;
	
	[TAB: "Base", Visible: "false"]
	bool useAnchor = true;
	[TAB: "Base", Visible: "false", WarningMsg:""]
	BatchType batchType = "Static";

	#	monitor("useAnchor", function(self, path, oval, op)	
	#		if not self.useAnchor and self.batchType == "Static" then
	#			set_attr(self, "batchType", "WarningMsg", "只有对锚定的物体才能使用静态合批")
	#		else
	#			set_attr(self, "batchType", "WarningMsg", "")
	#		end
	#	end);
	#	monitor("batchType", function(self, path, oval, op)	
	#		if not self.useAnchor and self.batchType == "Static" then
	#			self.useAnchor = true
	#		else 
	#			set_attr(self, "batchType", "WarningMsg", "")
	#		end 
	#	end);
};

struct Instance_VoxelTerrain : Instance {
	base(class = "VoxelTerrain", name = "VoxelTerrain");
	
	[TAB: "Base", Visible: "false"]
	string uniqueKey;
};

struct Instance_Folder : Instance{
	base(class = "Folder", name = "Folder");
	attrs_updater(function(self)
		set_attr(self, "isDataSet", "Visible", self.isDataSet and "true" or "false")
	end);
	[TAB: "Base", Sync: "true"]
	bool isDataSet = false;
	monitor("isDataSet", function(self, path, oval, op)
		set_attr(self, "isDataSet", "Visible", self.isDataSet and "true" or "false")
	end);
};

struct Instance_Decal : Instance {
	base(class = "Decal", name = "Decal");
	attrs_updater(function(self)
		local imageType = self.decalImageType
		local decalTilingVisible = imageType == "2"
		local decalOffsetVisible = imageType == "2"
		set_attr(self, "decalTiling", "Visible", decalTilingVisible and "true" or "false")
		set_attr(self, "decalOffset", "Visible", decalOffsetVisible and "true" or "false")
		set_attr(self.decalOffset, "x", "Step", "0.1")
		set_attr(self.decalOffset, "y", "Step", "0.1")
	end);
	
	[TAB: "Base"]
	Resource_EntityTexture decalTexture;
	[TAB: "Base"]
	Color decalColor = Color(r = 255, g = 255, b = 255);
	[TAB: "Base"]
	Surface decalSurface = "0";
	[TAB: "Base", ShowSlider: "true", Step: "0.1", Min: "0.01", Max: "1"]
	number decalAlpha = 1;
	[TAB: "Base"]
	ImageType decalImageType = "0";
	[TAB: "Base"]
	Vector2 decalOffset;
	[TAB: "Base"]
	Vector2 decalTiling;
	monitor("decalImageType", function(self, path, oval, op)
		local imageType = self.decalImageType
		local decalTilingVisible = imageType == "2"
		local decalOffsetVisible = imageType == "2"
		set_attr(self, "decalTiling", "Visible", decalTilingVisible and "true" or "false")
		set_attr(self, "decalOffset", "Visible", decalOffsetVisible and "true" or "false")
	end);
};

#
[Nonempty : "true"]
enum EUIScaleMode {
	"0",
	"1",
	"2"
};

struct Instance_SceneUI : Instance {
	base(class = "SceneUI", name = "SceneUI");
	attrs_updater(function(self)
		set_attr(self, "rotation", "Enabled", (self.isFaceCamera or self.isLock) and "false" or "true")
		set_attr(self.size, "z", "Visible", "false")
		set_attr(self.position, "x", "Step", "0.01")
		set_attr(self.position, "y", "Step", "0.01")
		set_attr(self.position, "z", "Step", "0.01")
		set_attr(self.size, "x", "Step", "0.01")
		set_attr(self.size, "y", "Step", "0.01")
		set_attr(self.size, "z", "Step", "0.01")
		set_attr(self.size, "x", "Min", "0.01")
		set_attr(self.size, "y", "Min", "0.01")
		set_attr(self.size, "z", "Min", "0.01")
		set_attr(self, "size", "Enabled", self.stretch and "true" or "false")
	end);
	[TAB: "Base"]
	bool isTop = true;
	[TAB: "Base"]
	bool isFaceCamera = true;
	monitor("isFaceCamera", function(self, path, oval, op)
		set_attr(self, "rotation", "Enabled", (self.isFaceCamera or self.isLock) and "false" or "true")
	end);
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 position;
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 rotation;
	[TAB: "Base", Alias:"Vector2D"]
	Vector3 size = Vector3(x = 1, y = 1);
	[TAB: "Base",Min: "0"]
	number rangeDistance = 128;
	[TAB: "Base"]
	Resource_Layout layoutFile;
	[TAB: "Base"]
	bool uiScaleMode = true;
	[TAB: "Base"]
	bool stretch = false;
	monitor("stretch",function(self,path,oval,op)
		set_attr(self, "size", "Enabled", self.stretch and "true" or "false")
	end);
	[TAB: "Base"]
	bool isLock = true;
	monitor("isLock", function(self, path, oval, op)
		set_attr(self, "rotation", "Enabled", (self.isLock or self.isFaceCamera) and "false" or "true")
	end);
};

struct Instance_EffectPart : Instance_Spatial {
	base(class = "EffectPart", name = "EffectPart");
	attrs_updater(function(self)
		set_attr(self, "position", "Visible", self.is_relative and "false" or "true")
		set_attr(self, "rotation", "Visible", self.is_relative and "false" or "true")
		set_attr(self, "size", "Visible", "false")
		set_attr(self, "transform", "Visible", self.is_relative and "true" or "false")
	end);

	hide bool is_relative = true;

	# 是否可见
	[TAB: "Base"]
	bool csgShapeVisible = true;

	[TAB: "Base"]
	Transform2 transform;

	[TAB: "Base"]
	Resource_Effect  csgShapeEffect;

	# 循环
	[TAB: "Base"]
	EffectLoop loop;
};

# 衰减方式
enum AttenuationType{
	"0",	# 线性滚降
	"1",	# 线性平方滚降
	"2",	# 倒锥形滚降
	"3",	# 逆向滚降
};

struct Instance_AudioNode : Instance_Spatial {
	base(class = "AudioNode", name = "AudioNode");
	attrs_updater(function(self)
		set_attr(self, "id", "Visible", "true")
		set_attr(self, "selectable", "Visible", "false")
		set_attr(self, "needSync", "Visible", "false")
		set_attr(self, "size", "Visible", "false")
		set_attr(self, "rotation", "Visible", "false")
		set_attr(self, "position", "Visible", self.is_relative and "false" or "true")
		set_attr(self, "relative_pos", "Visible", self.is_relative and "true" or "false")
	end);

	hide bool is_relative = true;
	monitor("is_relative", function(self, path, oval, op)
		set_attr(self, "position", "Visible", self.is_relative and "false" or "true")
		set_attr(self, "relative_pos", "Visible", self.is_relative and "true" or "false")
	end);

	# 相对位置
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 relative_pos;

	# 音效文件
	[TAB: "Base"]
	Resource_Sound sound;

	# 自动播放
	[TAB: "Base"]
	bool autoState = true;

	# 循环播放
	[TAB: "Base"]
	bool loopState = true;

	# 播放倍率
	[TAB: "Base", Min: "0.01", Step: "0.01"]
	number playRate = 1.0;

	# 无损距离
	[TAB: "Base", Min: "0.01", Step: "1"]
	number losslessDistance = 5.0;

	# 最大距离
	[TAB: "Base", Min: "0.01", Step: "1"]
	number maxDistance = 20.0;

	# 衰减方式
	[TAB: "Base"]
	AttenuationType attenuationType = "0";

	# 音量
	[TAB: "Base", Min: "0", Max: "1", Step: "1", ShowSlider: "true"]
	number volume = 1.0;
};

struct Instance_Object : Instance_Spatial {
	[TAB: "Base", Alias : "TemplateEntry", UndoStack: "barrier", Resettable:"false"]
	string config;
};

struct Instance_Entity : Instance_Object {
	base(class = "Entity", name = "Entity");
	attrs_updater(function(self)
		set_attr(self, "position", "Resettable", "false")
	end);
};

struct Instance_DropItem : Instance_Object {
	base(class = "DropItem", name = "DropItem");
	[TAB: "Base"]
	bool fixRotation  = true;
};

# 零件的烘培 0 non没 1 AsTerrain:零件成地形烘培 2 Obstacle:障碍物
[Nonempty : "true"]
enum PartNavMeshType{
	"0",
	"1",
	"2",
};

struct Instance_BasePart : Instance_Spatial {
	attrs_updater(function(self)
		local val = self.canEditPhy and "true" or "false"
		set_attr(self, "density", "Visible", val)
		set_attr(self, "restitution", "Visible", val)
		set_attr(self, "friction", "Visible", val)
	end);

	[TAB: "Base"]
	bool canEditPhy = false;
	monitor("canEditPhy", function(self, path, oval, op)
		local val = self.canEditPhy and "true" or "false"
		set_attr(self, "density", "Visible", val)
		set_attr(self, "restitution", "Visible", val)
		set_attr(self, "friction", "Visible", val)
	end);

	# 密度
	[TAB: "Base", Min: "0.01", Step: "0.01"]
	number density;

	hide string collisionUniqueKey;

	# 弹性
	[TAB: "Base", Min: "0", Max: "1", Step: "0.01"]
	number restitution;

	# 摩擦系数
	[TAB: "Base", Min: "0", Max: "1", Step: "0.01"]
	number friction;
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 lineVelocity;
	[TAB: "Base", Alias:"MyVector3"]
	Vector3 angleVelocity;

	# 批次
	[TAB: "Base", RegExp: "^[A-Za-z0-9_]+$", Visible: "false"]
	string staticBatchNo;

	[TAB: "Base"]
	bool useGravity = true;
	[TAB: "Base"]
	bool useCollide = true;
	[TAB: "Base", Visible: "false"]
	bool staticObject = false;
	[TAB: "Base", Visible: "true"]
	bool cameraCollideEnable = true;

	# 烘培是否障碍物
	[TAB: "Base"]
	PartNavMeshType partNavMeshType = "1";
}; 

struct Instance_CSGShape : Instance_BasePart{
	attrs_updater(function(self)
		set_attr(self.massCenter, "x", "Enabled", "false")
		set_attr(self.massCenter, "y", "Enabled", "false")
		set_attr(self.massCenter, "z", "Enabled", "false")
		set_attr(self, "id","Visible", "true")
	    set_attr(self, "useAnchor", "Visible", "true")
	    -- set_attr(self, "batchType", "Visible", "true")
	end);
	[TAB: "Base", Resettable: "false"]
	PartMaterial material = PartMaterial(texture = "part_suliao.tga");

	[Visible: "false"]
	number booleanOperation;
	[TAB: "Base", Enabled: "false",UndoStack: "barrier", Decimal:"3", Store:"0"]
	number mass;
	[TAB: "Base", Enabled: "false",UndoStack: "barrier", Store:"0"]
	number volume;
	[TAB: "Base", Enabled: "true"]
	Vector3 massCenter;
	[Visible: "false"]
	number customThreshold = 1;
	[TAB: "Base"]
	hide bool bloom = false;
	
	[Visible:"false"]
	bool enableEeffectDragDrog = true;
	
	[TAB: "Base"]
	CollisionFidelity collisionFidelity = "0";

	monitor("density", function(self, path, oval, op)
		self.mass = self.density * self.volume
	end);

	monitor("material", function(self, path, oval, op)
		if self.canEditPhy then
			return
		end

		if path[#path] == "texture" then
			local Part = require "we.view.scene.logic.part"
			local props = Part:material_property(self.material.texture)
			self.density, self.restitution, self.friction = props[1], props[2], props[3]
		end
	end);

	monitor("canEditPhy", function(self, path, oval, op)
		callbase()

		if self.canEditPhy then
			return
		end

		local Part = require "we.view.scene.logic.part"
		local props = Part:material_property(self.material.texture)
		self.density, self.restitution, self.friction = props[1], props[2], props[3]
	end);
};

struct Instance_MeshPart : Instance_CSGShape{
	base(class = "MeshPart", name = "MeshPart");
	attrs_updater(function(self)
		set_attr(self.material, "color", "Visible", "false")
		set_attr(self.material, "offset", "Visible", "false")
		set_attr(self.material, "useTextureAlpha", "Visible", "true")
		set_attr(self.material, "discardAlpha", "Visible", self.material.useTextureAlpha and "true" or "false")	
	end);
	[Visible: "false"]
	string mesh;
	[TAB: "Base"]
	Resource_Mesh mesh_selector;
	[TAB: "Base", Min: "0", Max: "1",Step: "0.1" ,ShowSlider: "true", Visible: "false"]
	number metalness;
	[TAB: "Base", Min: "0", Max: "1",Step: "0.1" ,ShowSlider: "true", Visible: "false"]
	number roughness = 0.9;
	[TAB: "Base", Visible: "true"]
	bool autoAnchor = true;
	#若蓝图可以摆脱对module,item的依赖，可以删掉这个改用TriggerSet
	[TAB: "Trigger", Alias: "BtsKey", Module: "meshpart", UndoStack: "barrier", Resettable: "false"]
	string btsKey;
	
	monitor("mesh_selector", function(self, path, oval, op)
		self.mesh = self.mesh_selector.asset
	end);
};

struct Instance_Block {
	[Alias:"MyVector3", Enabled: "false"]
	Vector3 position;
	[Alias : "TemplateEntry", UndoStack: "barrier", Resettable:"false"]
	string config;
};

enum Surface {
	"0",	# FRONT
	"1",	# BACK
	"2",	# LEFT
	"3",	# RIGHT
	"4",	# TOP
	"5"		# BOTTOM
};

enum ImageType {
	"0",	# FILLED
	"2"		# TILED
};

[Nonempty : "true"]
enum GeometrySharp {
	"1",	# cube
	"2",	# sphere
	"3",	# sylinder
	"4"		# cone
};

[Nonempty : "true"]
enum PartTexture {
	list(function()
		local Part = require "we.view.scene.logic.part"
		return Part:material_list()
	end);
};

struct PartMaterial {
	attrs_updater(function(self)
		set_attr(self.offset, "x", "Min", "0.01")
		set_attr(self.offset, "y", "Min", "0.01")

		set_attr(self.offset, "x", "Max", "1000")
		set_attr(self.offset, "y", "Max", "1000")
	end);
	
	Color color;
	[Resettable: "false"]
	PartTexture texture;
	Vector2 offset = Vector2(x = 1, y = 1);

	#透明度
	[Min: "0", Max: "1",Step: "0.01",ShowSlider: "true"]
	number alpha = 1.0;

	#启用Alpha 阈值
	[TAB: "Base", Visible: "false"]
	bool useTextureAlpha = false;

	#Alpha 阈值丢弃范围
	[Min: "0", Max: "1",Step: "0.01",ShowSlider: "true",  Visible: "false"]
	number discardAlpha = 0.0;

	monitor("useTextureAlpha",function(self,path,oval)
		set_attr(self, "discardAlpha", "Visible", self.useTextureAlpha and "true" or "false")
	end);
};
	[Nonempty : "true"]
	enum CollisionFidelity
	{
		"0",	# DEFAULT 
		"1",	# BOX,
		"2",	# HULL,
		"4",	# EMPTY,
		"5"		# SPHERE
	};

struct Instance_Part : Instance_CSGShape {
	base(class = "Part", name = "Part");
	attrs_updater(function(self)
	set_attr(self, "position", "Resettable", "false")
	set_attr(self, "material", "Resettable", "false")
	end);
	[TAB: "Base", Resettable: "false"]
	GeometrySharp shape;

	monitor("shape", function(self, path, oval, op)
		local Map = require "we.view.scene.map"
		local IInstance = require "we.engine.engine_instance"
		local instance = Map:query_instance(self.id)
		self.volume = IInstance:get_volume(instance:node())
		self.mass = self.density * self.volume
	end);

	#若蓝图可以摆脱对module,item的依赖，可以删掉这个改用TriggerSet
	[TAB: "Trigger", Alias: "BtsKey", Module: "part", UndoStack: "barrier", Resettable: "false"]
	string btsKey;
	#[TAB: "Base"]
	#AddCustomAttribute AddCustom;
};

struct Instance_PartOperation: Instance_CSGShape {
	base(class = "PartOperation", name = "Union");
	[TAB: "Base", Visible: "false"]
	bool useOriginalColor = true;
	[Visible: "false"]
	string mergeShapesDataKey = "";
	[Visible: "false"]
	bool isNeedMergeChildren = true;
	#若蓝图可以摆脱对module,item的依赖，可以删掉这个改用TriggerSet
	[TAB: "Trigger", Alias: "BtsKey", Module: "part_operation", UndoStack: "barrier", Resettable: "false"]
	string btsKey;
};

struct Instance_Model: Instance_Spatial {
	base(class = "Model", name = "Model");
	attrs_updater(function(self)
		set_attr(self, "size", "Visible", "false")
		set_attr(self, "id", "Visible", "true")
		set_attr(self, "scale", "Visible", "true")
	end);
};

struct Instance_RegionPart: Instance_Spatial {
	base(class = "RegionPart", name = "Region");
	
	attrs_updater(function(self)
		set_attr(self, "rotation", "Visible", "false")
	end);
	[TAB: "Base", Alias: "BtsKey", Module: "region", UndoStack: "barrier", Resettable: "false"]
	string cfgName;
};

struct Instance_TickBase : Instance {

};

struct Instance_Force : Instance_TickBase {
	base(class = "Force", name = "Force");

	[TAB: "Base"]
	Vector3 force;
	[TAB: "Base"]
	bool useRelativeForce;
};

struct Instance_Torque : Instance_TickBase {
	base(class = "Torque", name = "Torque");

	[TAB: "Base"]
	Vector3 torque;
	[TAB: "Base"]
	bool useRelativeTorque;
};

struct Instance_ConstraintBase : Instance {
	[TAB: "Base"]
	Vector3 masterLocalPos;
	[TAB: "Base", UndoStack: "barrier"]
	Vector3 masterWorldPos;
	[TAB: "Base"]
	Vector3 slaveLocalPos;
	[TAB: "Base", UndoStack: "barrier"]
	Vector3 slaveWorldPos;
	[Visible: "false"]
	string masterPartID;	#弃用
	[TAB: "Base", Alias: "MasterPartName", Resettable: "false"]
	string masterPartName;
	[Visible: "false"]
	string slavePartID;
	[TAB: "Base", Alias: "SlavePartName", Resettable: "false"]
	string slavePartName;
	[TAB: "Base"]
	bool collision = false;
};

struct Instance_FixedConstraint : Instance_ConstraintBase {
	base(class = "FixedConstraint", name = "FixedConstraint");
	attrs_updater(function(self)
		set_attr(self, "masterLocalPos", "Visible", "false")
		set_attr(self, "masterWorldPos", "Visible", "false")
		set_attr(self, "slaveLocalPos", "Visible", "false")
		set_attr(self, "slaveWorldPos", "Visible", "false")
		set_attr(self, "collision", "Visible", "false")
	end);

	hide bool visible = false;
};       

struct Instance_HingeConstraint : Instance_ConstraintBase {
	base(class = "HingeConstraint", name = "HingeConstraint");
	attrs_updater(function(self)
		set_attr(self, "motorTargetAngleVelocity", "Visible", self.useMotor and "true" or "false")
		set_attr(self, "motorForce", "Visible", self.useMotor and "true" or "false")
		set_attr(self, "stiffness", "Visible", self.useSpring and "true" or "false")
		set_attr(self, "damping", "Visible", self.useSpring and "true" or "false")
		set_attr(self, "springTargetAngle", "Visible", self.useSpring and "true" or "false")
		set_attr(self, "angleUpperLimit", "Visible", self.useAngleLimit and "true" or "false")
		set_attr(self, "angleLowerLimit", "Visible", self.useAngleLimit and "true" or "false")
	end);

	hide bool visible = false;
	#开启发动机
	[TAB: "Base"]
	bool useMotor;
	#角速度
	[TAB: "Base", Min: "-1450", Max: "1450", Step: "1"]
	number motorTargetAngleVelocity;
	#作用力
	[TAB: "Base", Min: "0", Max: "1000000", Step: "1"]
	number motorForce;
	#开启弹簧
	[TAB: "Base"]
	bool useSpring;
	[TAB: "Base", Min: "0"]
	number stiffness;
	#阻尼
	[TAB: "Base", Min: "0"]
	number damping;
	#标准角度
	[TAB: "Base", Min: "0",Max: "360"]
	number springTargetAngle;
	#开启角度限制
	[TAB: "Base"]
	bool useAngleLimit;
	#旋转角度上限
	[TAB: "Base", Min: "-360", Max: "360", Step: "1"]
	number angleUpperLimit = 360;
	#旋转角度下限
	[TAB: "Base", Min: "-360", Max: "360", Step: "1"]
	number angleLowerLimit = -360;

	monitor("useMotor",function(self,path,oval)
		set_attr(self, "motorTargetAngleVelocity", "Visible", self.useMotor and "true" or "false")
		set_attr(self, "motorForce", "Visible", self.useMotor and "true" or "false")
	end);
	monitor("useSpring",function(self,path,oval)
		set_attr(self, "stiffness", "Visible", self.useSpring and "true" or "false")
		set_attr(self, "damping", "Visible", self.useSpring and "true" or "false")
		set_attr(self, "springTargetAngle", "Visible", self.useSpring and "true" or "false")
	end);
	monitor("useAngleLimit",function(self,path,oval)
		set_attr(self, "angleUpperLimit", "Visible", self.useAngleLimit and "true" or "false")
		set_attr(self, "angleLowerLimit", "Visible", self.useAngleLimit and "true" or "false")
	end);
	
}; 

struct Instance_RodConstraint : Instance_ConstraintBase {
	base(class = "RodConstraint", name = "RodConstraint");
	
	[TAB: "Base"]
	bool visible = true;
	[TAB: "Base"]
	Color color = Color(r = 255, g = 255, b = 255);
	
	[TAB: "Base", Min: "0.01"]
	number radius = 0.05;
	[TAB: "Base", UndoStack: "barrier",Enabled: "false"]
	string anchorSpace;
	[TAB: "Base", Min: "0.01"]
	number length = 1;
	#两端固定
	[TAB: "Base"]
	bool fixedJustify;
}; 

struct Instance_SpringConstraint : Instance_ConstraintBase {
	base(class = "SpringConstraint", name = "SpringConstraint");
	attrs_updater(function(self)
		local max_coil = self.length/self.thickness
		max_coil = math.min(8,max_coil)
		set_attr(self, "coil", "Max", tostring(max_coil))

		local min_radius = tostring(self.thickness + 0.01)
		set_attr(self, "radius", "Min", min_radius)
		set_attr(self, "thickness", "Max", tostring(self.radius - 0.01))
	end);

	[TAB: "Base"]
	bool visible = true;
	[TAB: "Base"]
	Color color = Color(r = 255, g = 255, b = 255);
	#匝数
	[TAB: "Base", Min: "1"]
	number coil = 5;
	#粗度
	[TAB: "Base", Min: "0.01"]
	number thickness = 0.02;
	#半径
	[TAB: "Base"]
	number radius = 0.25;
	#两端固定
	[TAB: "Base"]
	bool fixedJustify = false;
	#弹性系数
	[TAB: "Base", Min: "0"]
	number stiffness = 50;
	#阻尼
	[TAB: "Base", Min: "0"]
	number damping = 0.01;
	[TAB: "Base", UndoStack: "barrier",Enabled: "false"]
	string anchorSpace;
	#标准长度
	[TAB: "Base", Min: "0.01"]
	number length = 5;

	monitor("radius",function(self,path,oval)
		set_attr(self, "radius", "Min", tostring(self.thickness + 0.01))
		if self.radius <= self.thickness then
			return
		end
		set_attr(self, "thickness", "Max", tostring(self.radius - 0.01))
	end);

	monitor("length",function(self,path,oval)
		local max_coil = self.length/self.thickness
		max_coil = math.min(8,max_coil)
		set_attr(self, "coil", "Max", tostring(max_coil))
	end);

	monitor("thickness",function(self,path,oval)
		local max_coil = self.length/self.thickness
		max_coil = math.min(8,max_coil)
		set_attr(self, "coil", "Max", tostring(max_coil))

		set_attr(self, "thickness", "Max", tostring(self.radius - 0.01))
		if self.thickness >= self.radius then
			return
		end
		set_attr(self, "radius", "Min", tostring(self.thickness + 0.01))
	end);
}; 

struct Instance_RopeConstraint : Instance_ConstraintBase {
	base(class = "RopeConstraint", name = "RopeConstraint");
	
	[TAB: "Base"]
	bool visible = true;
	[TAB: "Base"]
	Color color = Color(r = 255, g = 255, b = 255);
	[TAB: "Base", UndoStack: "barrier",Enabled: "false"]
	string anchorSpace;
	[TAB: "Base", Min: "0.01"]
	number length = 1;
	[TAB: "Base", Min: "0.01"]
	number radius = 0.02;
	
	
}; 

struct Instance_SliderConstraint : Instance_ConstraintBase {
	base(class = "SliderConstraint", name = "SliderConstraint");
	
	hide bool visible = false;
	[TAB: "Base", UndoStack: "barrier",Enabled: "false"]
	string anchorSpace;
	#距离下限
	[TAB: "Base"]
	number lowerLimit = -5;
	#距离上限
	[TAB: "Base"]
	number upperLimit = 5;
	
	monitor("lowerLimit",function(self,path,oval)
		set_attr(self, "lowerLimit", "Max", tostring(self.upperLimit))
		if self.lowerLimit > self.upperLimit then
			return
		end
		set_attr(self, "upperLimit", "Min", tostring(self.lowerLimit))
	end);
	monitor("upperLimit",function(self,path,oval)
		set_attr(self, "upperLimit", "Min", tostring(self.lowerLimit))
		if self.upperLimit < self.lowerLimit then
			return
		end
		set_attr(self, "lowerLimit", "Max", tostring(self.upperLimit))
	end);
}; 

#################################################################
########################### Storage ###############################
#################################################################

struct Instance_Part_Storage : Instance_Part {
	attrs_updater(function(self)
		set_attr(self, "btsKey", "Module", "storage_part")
	end);
};

struct Instance_MeshPart_Storage : Instance_MeshPart {
	attrs_updater(function(self)
		set_attr(self, "btsKey", "Module", "storage_meshpart")
	end);
};

struct Instance_PartOperation_Storage : Instance_PartOperation {
	attrs_updater(function(self)
		set_attr(self, "btsKey", "Module", "storage_part_operation")
	end);
};

struct StorageCfg {
	hide Instance instances[];
};
####################################### 光照系统 ####################################

#光源类型
[Nonempty : "true"]
enum LightType{
	"PointLight",
	"SpotLight",
	"DirectionalLight",
	"AreaLight"
};

#阴影类型
[Nonempty : "true"]
enum ShadowsType{
	"null",
	"soft",
	"hard"
};

#阴影精度
[Nonempty : "true"]
enum ShadowsPresicion{
	"512",
	"1024",
	"2048"
};

#阴影
struct Shadows{
	attrs_updater(function(self)
		set_attr(self, "shadowsIntensity", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsOffset", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsPresicion", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsDistance", "Enabled", self.shadowsType ~= "null" and "true" or "false")
	end);
	#类型
	ShadowsType shadowsType = "null";
	
	#强度
	[Min: "0", Max: "1", Step: "0.01", ShowSlider: "true"]
	number shadowsIntensity = 1.0;
	
	#偏移
	[Min: "0", Max: "2", Step: "0.01", ShowSlider: "true"]
	number shadowsOffset = 0.02;
	
	#精度
	ShadowsPresicion shadowsPresicion = "1024";
	
	#距离
	[Min: "1", Max: "512", Step: "0.01"]
	number shadowsDistance = 20.0;
	
	monitor("shadowsType", function(self, path, oval)
		set_attr(self, "shadowsIntensity", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsOffset", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsPresicion", "Enabled", self.shadowsType ~= "null" and "true" or "false")
		set_attr(self, "shadowsDistance", "Enabled", self.shadowsType ~= "null" and "true" or "false")
	end);
};

#光源
struct Instance_Light : Instance_Spatial {
	base(class = "Light", name = "Light");
	attrs_updater(function(self)
		set_attr(self, "position", "Visible", self.lightType ~= "GlobalLight" and "true" or "false")
		set_attr(self, "rotation", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "PointLight") and "true" or "false")
		set_attr(self, "size", "Visible", "false")
		set_attr(self, "scale", "Visible", "false")
		set_attr(self, "selectable", "Visible", "false")
		set_attr(self, "needSync", "Visible", "false")
		set_attr(self, "skyColor", "Visible", self.lightType == "GlobalLight" and "true" or "false")
		set_attr(self, "lightColor", "Visible", self.lightType ~= "GlobalLight" and "true" or "false")
		set_attr(self, "skyLineColor", "Visible", self.lightType == "GlobalLight" and "true" or "false")
		set_attr(self, "lightLength", "Visible", self.lightType == "AreaLight" and "true" or "false")
		set_attr(self, "lightWidth", "Visible", self.lightType == "AreaLight" and "true" or "false")
		set_attr(self, "lightAngle", "Visible", (self.lightType == "SpotLight" or self.lightType == "AreaLight") and "true" or "false")
		set_attr(self, "lightActived", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "DirectionalLight") and "true" or "false")
		set_attr(self, "lightRange", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "DirectionalLight") and "true" or "false")
		set_attr(self, "shadows", "Visible", self.lightType == "DirectionalLight" and "true" or "false")
		set_attr(self, "lightType", "Visible", self.lightType ~= "GlobalLight" and "true" or "false")
		set_attr(self, "lightAngle", "Max", self.lightType ~= "AreaLight" and "179" or "89")
	end);
	#光源下标
	[TAB:"Base", Visible:"false"]
	number ID;

	#光源类型
	[TAB: "Base", Sync:"true"]
	LightType lightType;
	
	#环境天光颜色
	[TAB: "Base"]
	Color skyColor = Color(r = 127,g = 131, b = 139, a = 255);
	
	#环境地平线颜色
	[TAB: "Base"]
	Color skyLineColor = Color(r = 61,g = 58, b = 53, a = 255);
	
	#亮度
	[TAB: "Base", Min:"0", Max:"10", Step: "0.01"]
	number lightBrightness = 1.0;
	
	#光源颜色
	[TAB: "Base"]
	Color lightColor;
	
	#光源范围
	[TAB: "Base", Min:"0", Max:"60", Step: "0.1"]
	number lightRange = 8.00;
	
	#光源角度
	[TAB: "Base", Min:"1", Max:"179", Step: "0.1"]
	number lightAngle = 30.0;
	
	#面光源长度
	[TAB: "Base", Min: "0", Step: "1"]
	number lightLength = 1.00;
	
	#面光源宽度
	[TAB: "Base", Min: "0", Step: "1"]
	number lightWidth = 1.00;

	#激活
	[TAB: "Base"]
	bool lightActived = true;
	
	#阴影
	[TAB: "Base"]
	Shadows shadows;

	monitor("lightType", function(self, path, oval)
		if self.name == oval then
			self.name = self.lightType
		end
		set_attr(self, "position", "Visible", self.lightType ~= "GlobalLight" and "true" or "false")
		set_attr(self, "rotation", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "PointLight") and "true" or "false")
		set_attr(self, "size", "Visible", "false")
		set_attr(self, "scale", "Visible", "false")
		set_attr(self, "selectable", "Visible", "false")
		set_attr(self, "needSync", "Visible", "false")
		set_attr(self, "skyColor", "Visible", self.lightType == "GlobalLight" and "true" or "false")
		set_attr(self, "skyLineColor", "Visible", self.lightType == "GlobalLight" and "true" or "false")
		set_attr(self, "lightLength", "Visible", self.lightType == "AreaLight" and "true" or "false")
		set_attr(self, "lightWidth", "Visible", self.lightType == "AreaLight" and "true" or "false")
		set_attr(self, "lightAngle", "Visible", (self.lightType == "SpotLight" or self.lightType == "AreaLight") and "true" or "false")
		set_attr(self, "lightActived", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "DirectionalLight") and "true" or "false")
		set_attr(self, "lightRange", "Visible", (self.lightType ~= "GlobalLight" and self.lightType ~= "DirectionalLight") and "true" or "false")
		set_attr(self, "shadows", "Visible", self.lightType == "DirectionalLight" and "true" or "false")
		set_attr(self, "lightType", "Visible", self.lightType ~= "GlobalLight" and "true" or "false")
	end);
};
#####################################################################
# 编辑状态(不保存)
struct EDIT_STATE_SCENE {
	EDIT_STATE_SCENE_PLACER placer;
	EDIT_STATE_SCENE_PICKER picker;
	EDIT_STATE_SCENE_SELECTOR selector;

	# gizmo
	EDIT_GIZMO gizmo;

	# 区域选择状态
	bool rect_pick_enable = true;
	bool rect_pick_state = false;
	Rect rect_pick_region;

	# 点选状态
	bool selector_state = false;

	# 一键拼接
	bool instantfixed_state = false;

	# 零件是否对齐
	bool part_align = false;

	# 是否显示场景全部约束
	bool constraint_normally_on = false;

	INSTANCE_ALIGN_SETTING instance_align_setting;

	# 当前选中的结点
	EDIT_VNODE_ID focus;
	string pb_type;		# propertybrowser type

	string active_map;

	EDIT_OPERATOR operator;

	PART_PLACE_SETTING part_place_settings[] = {
		PART_PLACE_SETTING(key = "cube", color = Color(r = 255, g = 255, b = 255), texture = "part_suliao.tga"),
		PART_PLACE_SETTING(key = "sphere", color =  Color(r = 255, g = 255, b = 255), texture = "part_suliao.tga"),
		PART_PLACE_SETTING(key = "cylinder", color =  Color(r = 255, g = 255, b = 255), texture = "part_suliao.tga"),
		PART_PLACE_SETTING(key = "cone", color =  Color(r = 255, g = 255, b = 255), texture = "part_suliao.tga")
	};

	# 是否允许编辑零件
	bool enable = true;
};

struct EDIT_STATE_SCENE_PLACER {
	string mode;	# block/grass、part/sphere
	string data;
};

struct EDIT_STATE_SCENE_PICKER {
	number mode = 1;	# 0:none, 1:rect, 2: box
};

struct EDIT_STATE_SCENE_SELECTOR {
	string mode;
	string data;
};

struct EDIT_GIZMO {
	number type;		# 0:none, 1:translate, 2: rotate, 3: scale
	number mode=0; 		# 0:local, 1:global

	# 平移
	bool step_move_enable = false;
	number step_move = 0.01;
	
	# 旋转
	bool step_rotate_enable = false;
	number step_rotate = 1;
};

struct EDIT_OPERATOR {
	EDIT_OPERATOR_ITEM items[] = {
		EDIT_OPERATOR_ITEM(name = "move",		icon = "union.icon",		code = "MOVE",		enable = false),
		EDIT_OPERATOR_ITEM(name = "rotate",		icon = "union.icon",		code = "ROTATE",	enable = false),
		EDIT_OPERATOR_ITEM(name = "scale",		icon = "union.icon",		code = "SCALE",		enable = false),
		EDIT_OPERATOR_ITEM(name = "union",		icon = "union.icon",		code = "UNION",		enable = false),
		EDIT_OPERATOR_ITEM(name = "intersect",	icon = "intersect.icon",	code = "INTERSECT", enable = false),
		EDIT_OPERATOR_ITEM(name = "reverse",	icon = "reverse.icon",		code = "REVERSE",	enable = false),
		EDIT_OPERATOR_ITEM(name = "split",		icon = "split.icon",		code = "SPLIT",		enable = false),
		EDIT_OPERATOR_ITEM(name = "group",		icon = "reverse.icon",		code = "GROUP",		enable = false),
		EDIT_OPERATOR_ITEM(name = "unGroup",	icon = "split.icon",		code = "UNGROUP",	enable = false),
		EDIT_OPERATOR_ITEM(name = "align",		icon = "split.icon",		code = "ALIGN",		enable = false),
		EDIT_OPERATOR_ITEM(name = "replace",	icon = "replace.icon",		code = "REPLACE",	enable = false),
		EDIT_OPERATOR_ITEM(name = "fill",		icon = "fill.icon",			code = "FILL",		enable = 
		false),
		EDIT_OPERATOR_ITEM(name = "delete",		icon = "delete.icon",		code = "DELETE",	enable = 
		false),
		EDIT_OPERATOR_ITEM(code = "CONFIRM"),
		EDIT_OPERATOR_ITEM(code = "COPY"),
		EDIT_OPERATOR_ITEM(code = "CUT"),
		EDIT_OPERATOR_ITEM(code = "REPETITION"),
		EDIT_OPERATOR_ITEM(code = "STORAGE"),
		EDIT_OPERATOR_ITEM(code = "MIRROR"),
		EDIT_OPERATOR_ITEM(code = "COPY2PLACER"),
		EDIT_OPERATOR_ITEM(code = "GET_CFG"),
		EDIT_OPERATOR_ITEM(code = "SPIN"),
		EDIT_OPERATOR_ITEM(code = "CHANGELIGHTANGLE")
	};
};

struct EDIT_OPERATOR_ITEM {
	string name = "";
	string icon = "";
	string code = "";
	bool enable = true;
};

struct EDIT_VNODE_ID {
	string tree;
	string path;
	bool clear;
};

struct PART_PLACE_SETTING {
	string key;
	Color color;
	PartTexture texture;
};

struct INSTANCE_ALIGN_SETTING {
	number align_style = 2;  #对齐方式 ，最小/中间/最大
	number align_coord = 1;  #对齐坐标 ，世界坐标还是本地坐标
	Vector3 align_axis ;	#对齐坐标轴，X/Y/Z
	number align_target = 1; #对齐目标，范围/对象
	string align_target_id;  #对齐对象的ID，align_target是对象的时候使用
	number show_effect ;	#预显示对齐的位置(对齐面线点)和包围盒
	number is_open_align ;  #是否已经打开了对齐功能的面板
	bool activate_align ;   #是否激活了对齐按钮，就是可以对齐了
	number current_align_obj_count ; #当前选中对齐的物体的数量
};
######################################################################

######################################################################
# 游戏配置，无须保存（只读）
struct GameConfig {
	bool disable_block = false;
	bool disable_storage = false;
	string template_id = "invalid";
};

######################################################################

enum BluePrintFunc {
	"Function_Called",
};

struct Function_Called : Trigger_Base {
	
};

[Nonempty : "true"]
enum BlueFunctionType {
    [Type:"T_Int"]
	"T_Int",
	[Type:"T_Double"]
	"T_Double",
	[Type:"T_Bool"]
	"T_Bool",
	[Type:"T_Entity"]
	"T_Entity",
	[Type:"T_Vector3"]
	"T_Vector3",
	[Type:"T_ScenePos"]
	"T_ScenePos",
	[Type:"T_String"]
	"T_String",
	[Type:"T_Var"]
	"T_Var",
    [Type:"T_IntArray"]
    "T_IntArray",
    [Type:"T_DoubleArray"]
    "T_DoubleArray",
    [Type:"T_BoolArray"]
    "T_BoolArray",
    [Type:"T_EntityArray"]
    "T_EntityArray",
    [Type:"T_Vector3Array"]
    "T_Vector3Array",
    [Type:"T_ScenePosArray"]
    "T_ScenePosArray",
    [Type:"T_StringArray"]
    "T_StringArray",
    [Type:"T_Part"]
	"T_Part",
	[Type:"T_MeshPart"]
	"T_MeshPart",
	[Type:"T_PartOperation"]
	"T_PartOperation",
    [Type:"T_Map"]
    "T_Map",
    [Type:"T_MapStr"]
    "T_MapStr",
    [Type:"T_BinaryOperCompute"]
    "T_BinaryOperCompute",
    [Type:"T_Color"]
    "T_Color",
    [Type:"T_SkillEntry"]
    "T_SkillEntry",
    [Type:"T_ItemEntry"]
    "T_ItemEntry",
    [Type:"T_BuffEntry"]
    "T_BuffEntry"
};

[Nonempty : "true"]
enum BlueFunctionReturnType {
    [Type:"T_Int"]
	"T_Int",
	[Type:"T_Double"]
	"T_Double",
	[Type:"T_Bool"]
	"T_Bool",
	[Type:"T_Entity"]
	"T_Entity",
	[Type:"T_Vector3"]
	"T_Vector3",
	[Type:"T_ScenePos"]
	"T_ScenePos",
	[Type:"T_String"]
	"T_String",
	[Type:"T_Void"]
	"T_Void",
    [Type:"T_IntArray"]
    "T_IntArray",
    [Type:"T_DoubleArray"]
    "T_DoubleArray",
    [Type:"T_BoolArray"]
    "T_BoolArray",
    [Type:"T_EntityArray"]
    "T_EntityArray",
    [Type:"T_Vector3Array"]
    "T_Vector3Array",
    [Type:"T_ScenePosArray"]
    "T_ScenePosArray",
    [Type:"T_StringArray"]
    "T_StringArray",
    [Type:"T_Part"]
	"T_Part",
	[Type:"T_MeshPart"]
	"T_MeshPart",
	[Type:"T_PartOperation"]
	"T_PartOperation",
    [Type:"T_Map"]
    "T_Map",
    [Type:"T_MapStr"]
    "T_MapStr",
    [Type:"T_BinaryOperCompute"]
    "T_BinaryOperCompute",
    [Type:"T_Color"]
    "T_Color",
    [Type:"T_SkillEntry"]
    "T_SkillEntry",
    [Type:"T_ItemEntry"]
    "T_ItemEntry",
    [Type:"T_BuffEntry"]
    "T_BuffEntry"
};

[Nonempty : "true"]
enum TriggerCustomParamsType {
	list(function(param)
		local custom_trigger = require "we.logic.trigger_action.custom_trigger"
		return custom_trigger:params(param)
	end);
};

enum TriggerCustomParamsType1 {
	[Type:"T_Int"]
	"T_Int",
	[Type:"T_Double"]
	"T_Double",
	[Type:"T_Bool"]
	"T_Bool",
	[Type:"T_Entity"]
	"T_Entity",
	[Type:"T_Vector3"]
	"T_Vector3",
	[Type:"T_ScenePos"]
	"T_ScenePos",
	[Type:"T_String"]
	"T_String",
	[Type:"T_Var"]
	"T_Var",
	[Type:"T_IntArray"]
	"T_IntArray",
	[Type:"T_DoubleArray"]
	"T_DoubleArray",
	[Type:"T_BoolArray"]
	"T_BoolArray",
	[Type:"T_EntityArray"]
	"T_EntityArray",
	[Type:"T_Vector3Array"]
	"T_Vector3Array",
	[Type:"T_ScenePosArray"]
	"T_ScenePosArray",
	[Type:"T_StringArray"]
	"T_StringArray",
	[Type:"T_Part"]
	"T_Part",
	[Type:"T_MeshPart"]
	"T_MeshPart",
	[Type:"T_PartOperation"]
	"T_PartOperation",
	[Type:"T_Map"]
	"T_Map",
	[Type:"T_MapStr"]
	"T_MapStr",
	[Type:"T_BinaryOperCompute"]
	"T_BinaryOperCompute",
	[Type:"T_Condition"]
	"T_Condition",
	[Type:"T_Color"]
	"T_Color",
	[Type:"T_SkillEntry"]
	"T_SkillEntry",
	[Type:"T_ItemEntry"]
	"T_ItemEntry",
	[Type:"T_BuffEntry"]
	"T_BuffEntry"
};

[Nonempty : "true"]
enum TriggerCustomClientParamsType {
	[Type:"T_Bool"]
	"T_Bool",
	[Type:"T_BoolArray"]
	"T_BoolArray",
	[Type:"T_Color"]
	"T_Color",
	[Type:"T_Double"]
	"T_Double",
	[Type:"T_DoubleArray"]
	"T_DoubleArray",
	[Type:"T_Int"]
	"T_Int",
	[Type:"T_String"]
	"T_String",
	[Type:"T_StringArray"]
	"T_StringArray",
	[Type:"T_Var"]
	"T_Vary",
	[Type:"UDim2"]
	"T_UDim2",
	[Type:"T_UDim2Array"]
	"T_UDim2Array",
	[Type:"T_Widget"]
	"T_Widget",
	[Type:"T_WidgetArray"]
	"T_WidgetArray",
	[Type:"T_Layout"]
	"T_Layout",
	[Type:"T_LayoutArray"]
	"T_LayoutArray"
};

struct FuncParam{
    attrs_updater(function(self)
		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false") 
		set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false") 
	end);
	
	monitor("param_type", function(self, path, oval)
		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false")
        set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false")

        local VNode = require "we.gamedata.vnode"
        local GameRequest = require "we.proto.request_game"

        local params = VNode.parent(self)
        local func = VNode.parent(params)
        GameRequest.request_function_param_change(VNode.path(self), self.param_type, oval, func.name.value)

        return true
	end);

    monitor("param_name", function(self, path, oval)
        local VNode = require "we.gamedata.vnode"
        local GameRequest = require "we.proto.request_game"

        GameRequest.request_function_param_name_change(VNode.path(self), self.param_name, oval)
    end);
    

	[RegExp: "FunctionParamName"]
    string  param_name;    #参数名称
	BlueFunctionType param_type = "T_Int";	#参数类型
	
	[Integer: "true"]
	number  default_value_int = 0;  

	number  default_value_double = 0;  
	bool  default_value_bool = false;  
	string  default_value_string;
    [Alias:"MyVector3"]
    Vector3 default_value_vector3 = Vector3(x = 0, y = 0, z = 0);
};

struct BluefuncCfg {
#################################################################
## 基础属性 BASE

	#名字
	[TAB: "Base", EditorData: "true", RegExp: "FunctionParamName"]
	Text name;
	
	#参数列表
	[TAB: "Base", EditorData: "true"]
	FuncParam params[];
	
	#返回值
	[TAB: "Base", EditorData: "true"]
	BlueFunctionReturnType ret_type = "T_Void";

    [TRIGGER: "Function_Called"]
	hide TriggerSet triggers;

};



[Catalog: "Function"]
struct Action_Function : Action_Base {
	base(name = "ExecFunction", type = "T_Var");
	attrs_updater(function(self)
		set_attr(self.components[1].params[1], "value", "Visible", "false")		
	end);
	string func_name;
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "func_name", value = T_String(rawval = "test"), must = true),			
		})
	};
    string func_declare_id;
};

[Catalog: "GetFunctionParam", RValue: "true"]
struct Action_GetFuncsParamsVar : Action_Base {
	base(name = "GetFuncsParamsVar", type = "T_Var");
	string function_name;
	Component_Base components[] = {
		Component_Function_Param(key = "test")
	};
};

struct Action_ReturnFuncs : Action_Base {
	base(name = "ReturnFuncs", type = "T_Void");
    string function_name;
    Component_Base components[] = {
		Component_Params(params = {
			
		})
	};
};

######################################################################

struct EDIT_STATE_LAYOUT{
	# 当前选中的结点
	EDIT_VNODE_ID focus;
};

[Nonempty : "true"]
enum BlueProtocolParmType {
	[Type:"T_Int"]
	"T_Int",
	[Type:"T_Double"]
	"T_Double",
	[Type:"T_Bool"]
	"T_Bool",
	[Type:"T_Vector3"]
	"T_Vector3",
	[Type:"T_String"]
	"T_String"
};

struct BlueProtocolParam{  
	 attrs_updater(function(self)
		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false")
		set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false") 
		self.param_type_old = self.param_type
	end);

	monitor("param_type", function(self, path, oval)
		local Meta = require "we.gamedata.meta.meta"
		local meta = Meta:meta("VarType")
		local param_type = meta:attribute("Type", self.param_type)
		self.value = ctor(self.param_type)

		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false")
		set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false") 
	end);

	[RegExp: "FunctionParamName"]
    string  param_name;    #参数名称

	BlueProtocolParmType param_type = "T_Int";	#参数类型
	hide BlueProtocolParmType param_type_old = "T_Int";	#参数类型

	hide T_Int value;

	[Integer: "true"]
	number  default_value_int = 0;  
	number  default_value_double = 0;  
	bool  default_value_bool = false;  
	string  default_value_string;
	[Alias:"MyVector3"]
	Vector3 default_value_vector3;

};

struct BlueProtocolCfg{
	#名字
	[TAB: "Base", EditorData: "true", RegExp: "FunctionParamName", Resettable: "false"]
	string name;
	
	#参数列表
	[TAB: "Base", EditorData: "true"]
	BlueProtocolParam params[];

	hide TriggerSet triggers;

	hide Uuid id;

	hide string type = "server";

	# json文件中记录的save = true 时，才是用户保存的
	hide bool save = false;


	hide string register_object;
};

#################################################################

struct Trigger_Custom : Trigger_Base {
    base(name = "TRIGGER_CUSTOM");
};

[BluePrint_Trigger_Type : "client_trigger"]
struct Trigger_Custom_Client : Trigger_Base {
    base(name = "TRIGGER_CUSTOM_CLIENT");
};

struct CustomTriggerParam {
    attrs_updater(function(self)
		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false") 
        set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false") 
	end);
	
	monitor("param_type", function(self, path, oval)
		set_attr(self, "default_value_int", "Visible", self.param_type == "T_Int" and "true" or "false") 
		set_attr(self, "default_value_double", "Visible", self.param_type == "T_Double" and "true" or "false") 
		set_attr(self, "default_value_bool", "Visible", self.param_type == "T_Bool" and "true" or "false") 
		set_attr(self, "default_value_string", "Visible", self.param_type == "T_String" and "true" or "false")
        set_attr(self, "default_value_vector3", "Visible", self.param_type == "T_Vector3" and "true" or "false")

		local VNode = require "we.gamedata.vnode"
        local GameRequest = require "we.proto.request_game"

        local params = VNode.parent(self)
        local custom_trigger_data = VNode.parent(params)
        GameRequest.request_custom_trigger_param_change(VNode.path(self), self.param_type, oval, custom_trigger_data.register_id)
	end);
    
	[RegExp: "FunctionParamName"]
    string  param_name;    #参数名称


	[Resettable: "false"]
	TriggerCustomParamsType param_type = "T_Int";	#参数类型
	
	[Integer: "true"]
	number  default_value_int = 0;  

	number  default_value_double = 0;  
	bool  default_value_bool = false;  
	string  default_value_string;
    [Alias:"MyVector3"]
    Vector3 default_value_vector3 = Vector3(x = 0, y = 0, z = 0);
};

struct Trigger_Custom_Data {
    #名字
	[TAB: "Base", EditorData: "true", RegExp: "FunctionParamName"]
	Text name;

    #参数列表
	[TAB: "Base", EditorData: "true"]
	CustomTriggerParam params[];

	monitor("params", function(self, path, oval, cbs)
		if cbs == "INSERT" then
			local index = path[2]
			set_attr(self.params[index], "param_type", "ENUM_LIST", self.type)
		end

		if cbs == "INSERT" or cbs == "ASSIGN" then
			local name_tb = {}
			local index = path[2]
			for k,v in ipairs(self.params) do
				if k ~= index then
					name_tb[v.param_name] = v.param_name
				end
			end

			local current_name = self.params[index].param_name
			local orgin = current_name == "" and "parameter" or current_name

			local next_index = 1
			local next_name = orgin .. "_" .. tostring(next_index)
			while name_tb[next_name] do
				next_index = next_index + 1
				next_name = orgin .. "_" .. tostring(next_index)
			end

			if current_name == "" or name_tb[current_name] then
				self.params[index].param_name = next_name
			end
		end
	end);

    hide string register_id;
	hide string type;
};

[Catalog: "CustomTrigger"]
struct Action_TriggerCustom : Action_Base {
	base(name = "DoCustomTriggerCfg", type = "T_Void");
	attrs_updater(function(self)
		set_attr(self.components[1].params[1], "value", "Visible", "false")
		set_attr(self.components[1].params[1], "value", "RegExp", "^[a-zA-Z][a-zA-Z0-9_]*$")
	end);
	
	Component_Base components[] = {
		Component_Params(params = {
			ActionParam(key = "custom_trigger_name", value = T_String(rawval = "test"), must = true)		
		})
	};

    string custom_trigger_name;
    string register_id;
    string path;
    bool is_server = true;
    bool is_valid = true;
    bool is_global = false;
};

[Catalog: "GetProtocolParam", RValue: "true"]
struct Action_GetProtocolParam : Action_Base {
	base(name = "GetContextParam", type = "T_Var");
	hide string proto_id = "";
	Component_Base components[] = {
		Component_Proto_Param(key = "")
	};
};

[Catalog: "GetProtocolParam", RValue: "true", BluePrint_Action_Type: "common_action"]
struct Action_GetCustomTriggerParams : Action_Base {
	base(name = "GetCustomTriggerParams", type = "T_Var");
	Component_Base components[] = {
		Component_Context()
	};
};

[Catalog: "GetCustomTriggerInstance", RValue: "true", BluePrint_Action_Type: "common_action"]
struct Action_GetCustomTriggerInstance : Action_Base {
	base(name = "GetCustomTriggerInstance", type = "T_Var");
	Component_Base components[] = {
		Component_Context(key = "")
	};
};
