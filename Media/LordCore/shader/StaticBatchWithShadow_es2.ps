#version 100

#define USE_SHADOW_PCF 
#define USE_SHADOW

uniform mediump vec3 uViewPosition; 
uniform mediump vec3 uLightDirection;
uniform mediump vec3 uLightStrength;

varying mediump vec3 ourPosition;           
varying mediump vec4 ourTexcoord;                   // xy纹理坐标:  zw:图集上的图层
varying mediump vec3 ourNormal;             
varying mediump vec4 ourColor;     
varying mediump vec4 ourLightSpacePos;         

uniform mediump vec2 uInvTextureSize;            // 1.f / 图集大小   
uniform mediump vec2 uMaterilaLayerScale;        // 一个图集的大小
uniform sampler2D uMaterialLayerTexture;         // 图集

uniform mediump float uShadowBias;              
uniform sampler2D uDepthMap;     
uniform mediump vec2 uInvDepthMapSize;

mediump vec3 SamplerMaterialLayerTexture(mediump vec4 texcoord) {
    mediump vec2 uv = fract(texcoord.xy) * uMaterilaLayerScale;     
    uv = clamp(uv - 2.0 * uInvTextureSize, vec2(0.0, 0.0), uMaterilaLayerScale);
    uv += texcoord.zw;
    uv += uInvTextureSize;
    return texture2D(uMaterialLayerTexture, uv).xyz;   
}

mediump float getPCFShadow(mediump float NdotL) {
    mediump vec3 lightPosition = ourLightSpacePos.xyz / ourLightSpacePos.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    mediump vec2 invTextureSize = uInvDepthMapSize;

    // 越界判断
    lowp int flag = int(lightPosition.x < invTextureSize.x);
    flag += int(lightPosition.x > (1.0 - invTextureSize.x));
    flag += int(lightPosition.y < invTextureSize.y);
    flag += int(lightPosition.y > (1.0 - invTextureSize.y));
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;


    mediump float shadowWeights[9];
    shadowWeights[0] = shadowWeights[2] = shadowWeights[6] = shadowWeights[8] = 0.0947416;
    shadowWeights[1] = shadowWeights[3] = shadowWeights[5] = shadowWeights[7] = 0.118318;
    shadowWeights[4] = 0.1477616;

    mediump float shadow = 0.0;    
    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    for (lowp int y = -1; y <= 1; ++y) {
        for (lowp int x = -1; x <= 1; ++x) {
            mediump vec2 offset = vec2(x, y) * invTextureSize;
            mediump float closestDepth = texture2D(uDepthMap, lightPosition.xy + offset).r;
            mediump float weight = currentDepth <= closestDepth ? 1.0 : 0.0;
            lowp int index = ((y + 1) * 3) + (x + 1);
            weight *= shadowWeights[index];
            shadow += weight;
        }
    }
    return shadow;
}

mediump float getShadow(mediump float NdotL) {
#ifdef USE_SHADOW_PCF
    return getPCFShadow(NdotL);
#else
    mediump vec3 lightPosition = ourLightSpacePos.xyz / ourLightSpacePos.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    // 越界判断
    lowp int flag = int(lightPosition.x < 0.0);
    flag += int(lightPosition.x > 1.0);
    flag += int(lightPosition.y < 0.0);
    flag += int(lightPosition.y > 1.0);
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;

    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    mediump float closestDepth = texture2D(uDepthMap, lightPosition.xy).r;
    return currentDepth <= closestDepth ? 1.0 : 0.0;
#endif
}

const mediump vec3 kAmbientStrength = vec3(0.6, 0.6, 0.6);
void main() {
    mediump vec3 L = uLightDirection;
    mediump vec3 N = normalize(ourNormal);
    mediump vec3 V = normalize(uViewPosition - ourPosition);
    mediump vec3 H = normalize(V + L);
    mediump vec3 albedo = SamplerMaterialLayerTexture(ourTexcoord) * ourColor.rgb;
    
    mediump vec3 ambient = kAmbientStrength * albedo;
	
    mediump float NdotL  = max(dot(N, L), 0.0);
    mediump vec3 diffuse = albedo * NdotL * uLightStrength;
    
    mediump float NdotH   = max(dot(N, H), 0.0);
    mediump vec3 specular = albedo * uLightStrength * pow(NdotH, 32.0);

    mediump float shadow = 1.0;
#ifdef USE_SHADOW 
    shadow = getShadow(NdotL);
#endif
    mediump vec3 result = ambient + ((diffuse + specular) * shadow); 
    gl_FragColor = vec4(result, ourColor.a);
}
