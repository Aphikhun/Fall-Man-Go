#version 100
#ifdef GL_FRAGMENT_PRECISION_HIGH
	precision highp float;
#else
	precision mediump float;
#endif

#define PI 3.1415926
#define SM_SMAP_SIZE 1024.0
#define SM_DX 0.0009765625	//1.0f / DSM_SMAP_SIZE
#define SHADOW_EPSILON 0.0002

uniform sampler2D texSampler;
uniform sampler2D texSampler1;
uniform sampler2D texSampler2;
uniform sampler2D texSampler3;
uniform sampler2D LMSampler;

uniform vec4 UVScale[2];
uniform vec4 LMParam[2];
uniform vec3 camPos;

uniform vec3 mainLightDir;
uniform vec4 mainLightColor;
uniform vec4 ambientColor;

varying vec4 blendines;
varying vec2 texCoord;
varying vec2 texCoord1;
//varying vec2 texCoord2;
varying vec3 oWPos;
varying vec4 oShadowPosSM;
varying vec3 tangentX;
varying vec3 tangentY;
varying vec3 tangentZ;

#ifndef NEW_FOG
varying vec4 ofogColor;
#else
uniform vec4 fogParam[3];

float LinearizeDepth(float depth, float near, float far) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

float ComputeFog(float z, float w, float density, float near, float far, float min, vec4 notUse)
{
	const float LOG2 = 1.442695;
	float fogFactor = exp2(-density * density * (z / w) * (z / w) * LOG2);
	fogFactor = clamp(fogFactor, 0.0, 1.0) + 1.0 - LinearizeDepth(z, near, far) / far;
	return clamp(fogFactor, min, 1.0);
}
#endif

vec4 ColorToLinear(vec4 color)
{
	vec4 linearColor = vec4(color.r*color.r,color.g*color.g,color.b*color.b,color.a);
	return linearColor;
}

vec3 ColorToLinearV3(vec3 color)
{
	vec3 linearColor = vec3(color.r*color.r,color.g*color.g,color.b*color.b);
	return linearColor;
}

vec4 LinearToTarget(vec4 color)
{
	vec4 c = vec4(sqrt(color.r),sqrt(color.g),sqrt(color.b),color.a);
	return c;
}

mediump float Pow5( mediump float x )
{
	mediump float xx = x*x;
	return xx * xx * x;
}

mediump float rcp(mediump float x)
{
    return 1.0 / x;
}

mediump float Square( mediump float x )
{
	return x*x;
}

mediump vec3 SquareV3( mediump vec3 val )
{
	return vec3(val.x*val.x, val.y*val.y, val.z*val.z);
}

mediump vec3 linear_to_srgb(mediump vec3 rgb)
{
	const mediump float ALPHA = 0.055;
	if(rgb.x < 0.0031308 && rgb.y < 0.0031308 && rgb.z < 0.0031308)
	{
		return 12.92 * rgb;
	}
	else
	{
		mediump vec3 ret;
		ret.x = (1.0 + ALPHA) * pow(abs(rgb.x), 1.0 / 2.4) - ALPHA;
		ret.y = (1.0 + ALPHA) * pow(abs(rgb.y), 1.0 / 2.4) - ALPHA;
		ret.z = (1.0 + ALPHA) * pow(abs(rgb.z), 1.0 / 2.4) - ALPHA;
		return ret;
	}
}

mediump vec3 srgb_to_linear(mediump vec3 srgb)
{
	const mediump float ALPHA = 0.055;
	if(srgb.r < 0.04045 && srgb.g < 0.04045 && srgb.b < 0.04045)
	{
		return srgb / 12.92;
	}
	else
	{
		mediump vec3 ret;
		ret.x = pow(abs((srgb.x + ALPHA) / (1.0 + ALPHA)), 2.4);
		ret.y = pow(abs((srgb.y + ALPHA) / (1.0 + ALPHA)), 2.4);
		ret.z = pow(abs((srgb.z + ALPHA) / (1.0 + ALPHA)), 2.4);
		return ret;
	}
}

// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
mediump float D_GGX( mediump float Roughness, mediump float NoH )
{
	mediump float a = Roughness * Roughness;
	mediump float a2 = a * a;
	mediump float d = ( NoH * a2 - NoH ) * NoH + 1.0;	// 2 mad
	return a2 / ( PI*d*d );					// 4 mul, 1 rcp
}

// Appoximation of joint Smith term for GGX
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
mediump float Vis_SmithJointApprox( mediump float Roughness, mediump float NoV, mediump float NoL )
{
	mediump float a = Square( Roughness );
	mediump float Vis_SmithV = NoL * ( NoV * ( 1.0 - a ) + a );
	mediump float Vis_SmithL = NoV * ( NoL * ( 1.0 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
mediump vec3 F_Schlick( mediump vec3 SpecularColor, mediump float VoH )
{
	mediump float Fc = Pow5( 1.0 - VoH );					// 1 sub, 3 mul
	//return Fc + (1.0 - Fc) * SpecularColor;		// 1 add, 3 mad
	
	// Anything less than 2% is physically impossible and is instead considered to be shadowing
	return clamp( 50.0 * SpecularColor.g, 0.0, 1.0 ) * Fc + (1.0 - Fc) * SpecularColor;
}

mediump vec3 Diffuse_Lambert( mediump vec3 DiffuseColor )
{
	return DiffuseColor * (1.0 / PI);
}

void getAlbedo_Reflectance(mediump vec3 BaseColor, mediump float Metallic, out mediump vec3 Albedo, out mediump vec3 Reflectance)
{
	const mediump float DielectricSpecular = 0.04;// Specular; // 0.08f 0.04f 
	Albedo = BaseColor - BaseColor * Metallic;	// 1 mad
	Albedo = srgb_to_linear(Albedo);
	Reflectance = (DielectricSpecular - DielectricSpecular * Metallic) + BaseColor * Metallic;	// 2 mad
	Reflectance = srgb_to_linear(Reflectance);
}

void StandardShading(mediump vec3 DiffuseColor, mediump vec3 SpecularColor, mediump vec3 LobeRoughness, mediump vec3 LobeEnergy,
	mediump vec3 L, mediump vec3 V, mediump vec3 N, mediump vec2 DiffSpecMask,
	out mediump vec3 diffuse, out mediump vec3 specular)
{
	mediump vec3 H = normalize(V + L);
	mediump float NoL = clamp(dot(N, L), 0.0, 1.0);
	mediump float NoV = clamp(abs(dot(N, V)) + 1e-5, 0.0, 1.0);
	mediump float NoH = clamp(dot(N, H), 0.0, 1.0);
	mediump float VoH = clamp(dot(V, H), 0.0, 1.0);

	// Generalized microfacet specular
	mediump float D = D_GGX(LobeRoughness[1], NoH) * LobeEnergy[1];
	mediump float Vis = Vis_SmithJointApprox(LobeRoughness[1], NoV, NoL);
	mediump vec3 F = F_Schlick(SpecularColor, VoH);

	diffuse = Diffuse_Lambert(DiffuseColor);
	diffuse = (diffuse * (LobeEnergy[2] * DiffSpecMask.r)) * NoL;
	specular = ((D * Vis * DiffSpecMask.g) * F) * NoL;

	diffuse = max(diffuse, 0.0);
	specular = max(specular, 0.0);
}

float conv_CalcK(float RecvDistance)
{
	float ret = 150.0 / RecvDistance;
	ret = min(ret, 1250.0);
	ret = max(ret, 75.0);
	return ret;
}

mediump float ComputeShadowRecv_EsmLinearSimple(sampler2D texSM, vec4 ShadowPos, float dx, float smap_size, float depthEpsScale)
{
	vec4 mapDepth;
	vec4 offset = vec4(dx, 0.0, dx, 0.0);
	vec2 factor = fract(ShadowPos.xy * smap_size);

	ShadowPos.xy += (-factor + 0.001) * dx;

	vec2 texcoord = ShadowPos.xy;
	mapDepth.x = (texcoord.x<0.0 || texcoord.x>1.0 || texcoord.y<0.0 || texcoord.y>1.0)?1.0:texture2D(texSM, texcoord).x * 0.5 + 0.5; texcoord = ShadowPos.xy + offset.xy;
	mapDepth.y = (texcoord.x<0.0 || texcoord.x>1.0 || texcoord.y<0.0 || texcoord.y>1.0)?1.0:texture2D(texSM, texcoord).x * 0.5 + 0.5; texcoord = ShadowPos.xy + offset.wz;
	mapDepth.w = (texcoord.x<0.0 || texcoord.x>1.0 || texcoord.y<0.0 || texcoord.y>1.0)?1.0:texture2D(texSM, texcoord).x * 0.5 + 0.5; texcoord = ShadowPos.xy + offset.zx;
	mapDepth.z = (texcoord.x<0.0 || texcoord.x>1.0 || texcoord.y<0.0 || texcoord.y>1.0)?1.0:texture2D(texSM, texcoord).x * 0.5 + 0.5; 
	
	float k = conv_CalcK(ShadowPos.z);
	
	vec4 t4 = min(exp(k * (mapDepth - ShadowPos.z * depthEpsScale)), 1.0);
	vec2 t2 = mix(t4.xy, t4.wz, factor.y);
	float ret = mix(t2.x, t2.y, factor.x);
	return max(1.0 - (1.0 - ret) * 0.6, 0.0);
}

mediump float ComputeShadowRecv_Linear_All(sampler2D texSM, vec4 ShadowPosSM, vec3 WorldPos, vec3 camPos)
{
	// 静态阴影接收考虑距离
	float ret = ComputeShadowRecv_EsmLinearSimple(texSM, ShadowPosSM, SM_DX, SM_SMAP_SIZE, 0.999);
	
	// 0至32，纯阴影(dist = 1)；40至64，过渡到无阴影，大于48没有阴影(dist = 0)
	float dist = distance(WorldPos.xyz, camPos);
	dist = clamp((64.0 - dist) / 24.0, 0.0, 1.0);

	// 实际阴影值
	return 1.0 - dist * (1.0 - ret);
}

void main()
{
	vec4 finalColor =  texture2D(texSampler,  texCoord  * UVScale[0].xy) * (1.0 - blendines.r - blendines.g - blendines.b);
	finalColor += texture2D(texSampler1, texCoord  * UVScale[0].zw) * blendines.r;
	finalColor += texture2D(texSampler2, texCoord  * UVScale[1].xy) * blendines.g;
	finalColor += texture2D(texSampler3, texCoord  * UVScale[1].zw) * blendines.b;
	//finalColor = mix(finalColor, texture2D(texSampler4, texCoord2), blendines.a);

	//vec3 normalTex = vec3(0.5, 0.5, 1.0);
	//vec3 tbn = normalTex * (1.0 - blendines.r - blendines.g - blendines.b);
    //tbn += normalTex * blendines.r;
    //tbn += normalTex * blendines.g;
    //tbn += normalTex * blendines.b;
    //tbn = tbn * 2.0 - 1.0;

    //vec3 Normal = normalize(tbn.x * normalize(tangentY) +
    //    tbn.y * normalize(tangentX) +
    //    tbn.z * normalize(tangentZ));
	
	//vec3 Normal = Normal * 0.00001 + tangentZ;
    //vec3 viewDir = normalize(camPos - oWPos.xyz);
    //vec3 TLitDir = mainLightDir;
	
    //vec3 LobeEnergy = vec3(1.0, 1.0, 1.0);
    //vec2 DiffSpecMask = vec2(1.0, 1.0);
	
    //float Metallic = 0.0;
    //vec3 LobeRoughness = finalColor.aaa;
    //vec3 L = TLitDir.xyz;
    //vec3 Albedo, Reflectance;
    //getAlbedo_Reflectance(finalColor.rgb, Metallic, Albedo, Reflectance);
	
	//vec3 Diffuse_, Specular_;
    //StandardShading(Albedo.rgb * 5.0 * ambientColor.a, Reflectance.rgb, LobeRoughness, LobeEnergy, L, viewDir, Normal, DiffSpecMask, Diffuse_, Specular_);
   	
    //vec3 Diffuse = Albedo.rgb * 5.0*ambientColor.rgb*ambientColor.a;
    //finalColor.rgb = linear_to_srgb(Diffuse + Diffuse_ + Specular_ * mainLightColor.rgb) * (1.0 -blendines.a) * 2.0;

	//finalColor.rgb = ColorToLinearV3(finalColor.rgb);
	//float Shadow = ComputeShadowRecv_Linear_All(LMSampler, oShadowPosSM, oWPos, camPos);
	//vec3 LMColor = texture2D(LMSampler, texCoord1*LMParam[0].zw + LMParam[0].xy).rgb * LMParam[1].rgb;
	//finalColor.rgb = finalColor.rgb * LMColor * max(Shadow, 0.0996);
	
	float lStrength = max(dot(normalize(tangentZ), mainLightDir), 0.0);
	vec3 lColor = lStrength * mainLightColor.rgb + ambientColor.rgb;
	finalColor.rgb = finalColor.rgb * lColor;

#ifdef NEW_FOG
	vec4 ofogColor =  vec4(fogParam[1].rgb, ComputeFog(gl_FragCoord.z, gl_FragCoord.w, fogParam[0].z, fogParam[0].x, fogParam[0].y, fogParam[0].w, fogParam[2]));
#endif
	
	gl_FragColor = vec4(mix(ofogColor.rgb, finalColor.rgb, ofogColor.a), 1.0);
	//gl_FragColor = LinearToTarget(gl_FragColor);
}

