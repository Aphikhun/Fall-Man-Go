#version 100

precision mediump float;
precision mediump int;

uniform sampler2D texSampler;
uniform sampler2D depthSampler;

uniform vec2 texelSize;
uniform float nearClip;
uniform float farClip;

varying mediump vec2 texCoord;

mediump vec2 ClampAndScaleUVForBilinear(mediump vec2 UV, mediump vec2 size)
{
    mediump vec2 maxCoord = 1.0 - 0.5 * size;
    return min(UV, maxCoord) ;//* size;
}

mediump vec2 ClampAndScaleUVForPoint(mediump vec2 UV)
{
    return min(UV, 1.0);
}

float LinearEyeDepth(float depth, mediump vec4 zBufferParam)
{
    return 1.0 / (zBufferParam.z * depth + zBufferParam.w);
}


mediump vec4 calculateColor(int type)
{
    float x = (1.0 - farClip / nearClip) / 2.0;
    float y = (1.0 + farClip / nearClip) / 2.0;
    mediump vec4 _ZBufferParams = vec4(x, y, x/farClip, y/farClip);

    mediump vec2 halfResTexelSize = 2.0 * texelSize;

    mediump vec4 lowResDepths = vec4(1.0, 1.0, 1.0, 1.0);
    mediump vec2 downLeftUV = ClampAndScaleUVForBilinear(texCoord, halfResTexelSize);

    lowResDepths[0] = LinearEyeDepth(texture2D(depthSampler, downLeftUV).r, _ZBufferParams);
    lowResDepths[1] = LinearEyeDepth(texture2D(depthSampler, downLeftUV + vec2(halfResTexelSize.x, 0.0)).r, _ZBufferParams);
    lowResDepths[2] = LinearEyeDepth(texture2D(depthSampler, downLeftUV + vec2(0.0, halfResTexelSize.y)).r, _ZBufferParams);
    lowResDepths[3] = LinearEyeDepth(texture2D(depthSampler, downLeftUV + halfResTexelSize).r, _ZBufferParams);

    mediump vec2 UVs[4];
    UVs[0] = downLeftUV;
    UVs[1] = downLeftUV + vec2(halfResTexelSize.x, 0.0);
    UVs[2] = downLeftUV + vec2(0.0, halfResTexelSize.y);
    UVs[3] = downLeftUV + halfResTexelSize;

    if(type == 1)
    {
        if(lowResDepths[0] == lowResDepths[1])
        {
            mediump vec4 outColor = texture2D(texSampler,UVs[0]);
            return outColor;
        }
        float totalDepth = lowResDepths[0] + lowResDepths[1];
        mediump vec4 outColor = (texture2D(texSampler,UVs[0])*lowResDepths[0] + texture2D(texSampler,UVs[1])*lowResDepths[1])/totalDepth;
        return outColor;
    }

    if(type == 2)
    {
        if(lowResDepths[0] == lowResDepths[2])
        {
            mediump vec4 outColor = texture2D(texSampler,UVs[0]);
            return outColor;
        }
        float totalDepth = lowResDepths[0] + lowResDepths[2];
        mediump vec4 outColor = (texture2D(texSampler,UVs[0])*lowResDepths[0] + texture2D(texSampler,UVs[2])*lowResDepths[2])/totalDepth;
        return outColor;
    }

    if(lowResDepths[0] == lowResDepths[3])
    {
        mediump vec4 outColor = texture2D(texSampler,UVs[0]);
        return outColor;
    }
    float totalDepth = lowResDepths[0] + lowResDepths[1] + lowResDepths[2] + lowResDepths[3];
    mediump vec4 outColor = (texture2D(texSampler,UVs[0])*lowResDepths[0] + texture2D(texSampler,UVs[1])*lowResDepths[1] + texture2D(texSampler,UVs[2])*lowResDepths[2] + texture2D(texSampler,UVs[3])*lowResDepths[3])/totalDepth;
    return outColor;
}

void main(void)
{
    mediump vec2 tempTexelSize = 2.0 * texelSize;
    if(mod(texCoord.x, tempTexelSize.x) <= texelSize.x && mod(texCoord.y, tempTexelSize.y) <= texelSize.y)
    {
        gl_FragColor = texture2D(texSampler, texCoord);
        return;
    }
    
    if(mod(texCoord.x, tempTexelSize.x) > texelSize.x && mod(texCoord.y, tempTexelSize.y) > texelSize.y)
    {
        gl_FragColor = calculateColor(3);
        return;
    }

    if(mod(texCoord.x, tempTexelSize.x) <= texelSize.x)
    {
        gl_FragColor = calculateColor(2);
        return;
    }

    if(mod(texCoord.y, tempTexelSize.y) <= texelSize.y)
    {
        gl_FragColor = calculateColor(1);
    }
}