#version 100

uniform mediump float 		AB_mix_offset;  // : hint_range(-11., 2.5) = -6.187;
uniform mediump float 		AB_mix_normal;  // : hint_range(0., 20.) = 8.253;
uniform mediump float 		AB_mix_blend;  // : hint_range(0., 10.) = 2.;

uniform mediump vec4 		A_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);
uniform mediump vec4 		B_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);

// 光照、阴影相关
uniform mediump float       useShadow;
uniform mediump float       textureSize;

uniform sampler2D			voxelTex;
uniform sampler2D			depthMap;
uniform mediump vec4        textureId0;
uniform mediump vec4        textureId1;
uniform mediump float       voxelTexSize;
uniform mediump float       border;
uniform mediump float       cellPerRow;
uniform mediump float       KB;

uniform mediump float       materialCount;  // 0: Grass, 1: Single material, 2: Multi materials
uniform sampler2D           grassTexA;
uniform sampler2D           grassTexB;

uniform lowp int            materialTexA0;
uniform lowp int            materialTexA1;
uniform lowp int            materialTexA2;
uniform lowp int            materialTexA3;
uniform lowp int            materialTexA4;
uniform lowp int            materialTexA5;
uniform lowp int            materialTexA6;
uniform lowp int            materialTexB0;
uniform lowp int            materialTexB1;
uniform lowp int            materialTexB2;
uniform lowp int            materialTexB3;
uniform lowp int            materialTexB4;
uniform lowp int            materialTexB5;
uniform lowp int            materialTexB6;

varying mediump vec3 		A_uv_triplanar_pos;
varying mediump vec3 		A_uv_power_normal;
varying mediump vec3 		B_uv_triplanar_pos;
varying mediump vec3 		B_uv_power_normal;
varying mediump vec3 		vertex_normal;
varying mediump vec4		blend_weights;
varying mediump vec4		blend_weights2;
varying mediump vec3        lightFactor;

mediump vec4 triplanar_texture(mediump float texId, mediump vec3 p_weights, mediump vec3 p_triplanar_pos) 
{
    mediump float one2b = 1.0 + 2.0 * border;
    mediump float j = floor(texId / cellPerRow);
    mediump float i = texId - j * cellPerRow;
    mediump vec2 iPos = vec2(i, j);
    mediump vec3 flip = 2.0 * step(vec3(0.0), vertex_normal) - 1.0;
    mediump vec2 posX = fract(p_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posY = fract(p_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posZ = fract(p_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec2 uvX = (iPos * one2b + border + posX) / KB;
    mediump vec2 uvY = (iPos * one2b + border + posY) / KB;
    mediump vec2 uvZ = (iPos * one2b + border + posZ) / KB;
    // mediump float fix = 1.0 / voxelTexSize;
    // mediump vec2 minUV = (iPos * one2b + border) / KB + vec2(fix, fix);
    // mediump vec2 maxUV = (iPos * one2b + border + vec2(1.0, 1.0)) / KB - vec2(fix, fix);
    // uvX = clamp(uvX, minUV, maxUV);
    // uvY = clamp(uvY, minUV, maxUV);
    // uvZ = clamp(uvZ, minUV, maxUV);
    mediump vec4 samp = texture2D(voxelTex, uvX) * p_weights.x;
    samp       = samp + texture2D(voxelTex, uvY) * p_weights.y;
    samp       = samp + texture2D(voxelTex, uvZ) * p_weights.z;
    return samp;
}

mediump int    material_tex_ids[16];
mediump float  indices2TexIds[8];

void init_arrays()
{
    material_tex_ids[0] = materialTexA0;
    material_tex_ids[1] = materialTexA1;
    material_tex_ids[2] = materialTexA2;
    material_tex_ids[3] = materialTexA3;
    material_tex_ids[4] = materialTexA4;
    material_tex_ids[5] = materialTexA5;
    material_tex_ids[6] = materialTexA6;
    material_tex_ids[7] = materialTexB0;
    material_tex_ids[8] = materialTexB1;
    material_tex_ids[9] = materialTexB2;
    material_tex_ids[10] = materialTexB3;
    material_tex_ids[11] = materialTexB4;
    material_tex_ids[12] = materialTexB5;
    material_tex_ids[13] = materialTexB6;

    indices2TexIds[0] = textureId0[0];
    indices2TexIds[1] = textureId0[1];
    indices2TexIds[2] = textureId0[2];
    indices2TexIds[3] = textureId0[3];
    indices2TexIds[4] = textureId1[0];
    indices2TexIds[5] = textureId1[1];
    indices2TexIds[6] = textureId1[2];
    indices2TexIds[7] = textureId1[3];
}

mediump vec4 getMaterialColor(mediump int idxA, mediump int idxB)
{
    mediump float texIdA = 0.0;
    mediump float texIdB = 0.0;
    for (lowp int i = 0; i < 8; ++i)
    {
        if (i == idxA) texIdA = indices2TexIds[i];
        if (i == idxB) texIdB = indices2TexIds[i];
    }
    mediump vec4 color = A_albedo_tint * triplanar_texture(texIdA, A_uv_power_normal, A_uv_triplanar_pos);
    mediump float enabledB = step(float(idxB), 6.5);
    mediump vec4 colorB = B_albedo_tint * triplanar_texture(texIdB, B_uv_power_normal, B_uv_triplanar_pos);
    mediump float mix_factor = clamp(AB_mix_normal * vertex_normal.y + AB_mix_offset + AB_mix_blend * color.g, 0., 1.);
    mix_factor = 1.0 - enabledB + enabledB * mix_factor;
    color = mix(colorB, color, mix_factor);
    return color;
}

mediump vec4 getMultiMaterialColor()
{
    mediump vec4 albedo = vec4(0.);
    mediump vec4 weight0 = blend_weights;
    mediump vec4 weight1 = blend_weights2;
    // mediump vec4 weight0 = blend_weights * blend_weights * blend_weights;
    // mediump vec4 weight1 = blend_weights2 * blend_weights2 * blend_weights2;
    // weight0 *= weight0;
    // weight1 *= weight1;
    // mediump float total = dot(vec4(1.0), weight0) + dot(vec4(1.0), weight1);
    // weight0 /= total;
    // weight1 /= total;

    for (lowp int i = 0; i < 4; ++i)
    {
        if (weight0[i] > 0.0) albedo = albedo + weight0[i] * getMaterialColor(material_tex_ids[i], material_tex_ids[i + 7]);    
        if (weight1[i] > 0.0) albedo = albedo + weight1[i] * getMaterialColor(material_tex_ids[i + 4], material_tex_ids[i + 11]);
    }

    return albedo;
}

mediump vec4 getSingleMaterialColor()
{
    mediump vec3 flip = 2.0 * step(vec3(0.0), vertex_normal) - 1.0;
    mediump vec2 posAX = fract(A_uv_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posAY = fract(A_uv_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posAZ = fract(A_uv_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec4 sampA = texture2D(grassTexA, posAX) * A_uv_power_normal.x;
    sampA      = sampA + texture2D(grassTexA, posAY) * A_uv_power_normal.y;
    sampA      = sampA + texture2D(grassTexA, posAZ) * A_uv_power_normal.z;
    mediump vec2 posBX = fract(B_uv_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posBY = fract(B_uv_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posBZ = fract(B_uv_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec4 sampB = texture2D(grassTexB, posBX) * B_uv_power_normal.x;
    sampB      = sampB + texture2D(grassTexB, posBY) * B_uv_power_normal.y;
    sampB      = sampB + texture2D(grassTexB, posBZ) * B_uv_power_normal.z;
    mediump float mix_factor = clamp(AB_mix_normal * dot(vec3(0., 1., 0.), vertex_normal) + AB_mix_offset + AB_mix_blend * sampA.g, 0., 1.);
    mediump float B_weight = step(materialCount, 0.5);
    mix_factor = B_weight * mix_factor + (1.0 - B_weight);
    return mix(sampB, sampA, mix_factor);
}

void main() 
{
    init_arrays();
    // Calculate Albedo 
    mediump vec4 albedo;
    // if (materialCount > 1.0)
    // {
        albedo = getMultiMaterialColor();
    // }
    // else
    // {
    //     albedo = getSingleMaterialColor();
    // }

    mediump vec3 result = lightFactor * albedo.rgb;
    gl_FragColor = vec4(result, 1.0);
}
