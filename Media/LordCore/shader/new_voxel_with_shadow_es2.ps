#version 100

#define USE_SHADOW_PCF
#define USE_SHADOW

// 光照、阴影相关
uniform mediump float useShadow;
uniform mediump vec3  lightDir;
uniform mediump vec3  viewPos;
uniform mediump vec4  lightColor;
uniform mediump sampler2D uDepthMap;
uniform mediump vec2 uInvDepthMapSize;
varying mediump vec4  fragPosLightSpace;

mediump float getPCFShadow(mediump float NdotL) {
    mediump vec3 lightPosition = fragPosLightSpace.xyz / fragPosLightSpace.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    mediump vec2 invTextureSize = uInvDepthMapSize;

    // 越界判断
    lowp int flag = int(lightPosition.x < invTextureSize.x);
    flag += int(lightPosition.x > (1.0 - invTextureSize.x));
    flag += int(lightPosition.y < invTextureSize.y);
    flag += int(lightPosition.y > (1.0 - invTextureSize.y));
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;


    mediump float shadowWeights[9];
    shadowWeights[0] = shadowWeights[2] = shadowWeights[6] = shadowWeights[8] = 0.0947416;
    shadowWeights[1] = shadowWeights[3] = shadowWeights[5] = shadowWeights[7] = 0.118318;
    shadowWeights[4] = 0.1477616;

    mediump float shadow = 0.0;    
    mediump float bias = mix(0.02, useShadow, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    for (lowp int y = -1; y <= 1; ++y) {
        for (lowp int x = -1; x <= 1; ++x) {
            mediump vec2 offset = vec2(x, y) * invTextureSize;
            mediump float closestDepth = texture2D(uDepthMap, lightPosition.xy + offset).r;
            mediump float weight = currentDepth <= closestDepth ? 1.0 : 0.0;
            lowp int index = ((y + 1) * 3) + (x + 1);
            weight *= shadowWeights[index];
            shadow += weight;
        }
    }
    return shadow;
}

mediump float getShadow(mediump float NdotL) {
#ifdef USE_SHADOW_PCF
    return getPCFShadow(NdotL);
#else
    mediump vec3 lightPosition = fragPosLightSpace.xyz / fragPosLightSpace.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    // 越界判断
    lowp int flag = int(lightPosition.x < 0.0);
    flag += int(lightPosition.x > 1.0);
    flag += int(lightPosition.y < 0.0);
    flag += int(lightPosition.y > 1.0);
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;

    mediump float bias = mix(0.02, useShadow, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    mediump float closestDepth = texture2D(uDepthMap, lightPosition.xy).r;
    return currentDepth <= closestDepth ? 1.0 : 0.0;
#endif
}

uniform mediump vec4 uMaterialLayer[24];            // x纹理坐标的缩放; y随机化纹理控制值; zw 图集上对应材质的初始纹理位置
varying mediump vec4 texcoord0;
varying mediump vec4 texcoord1;
varying mediump vec4 texcoord2;
varying mediump vec3 wpos;
varying mediump vec3 wnrm;
varying mediump vec3 barycentric;                   // barycentric-coordinate
uniform mediump vec2 uLayerScale;                   // 图集上一张图的大小
uniform mediump sampler2D gDiffuseMap;
uniform mediump vec2 uInvTextureSize;

mediump vec3 SamplerAlbedo(mediump vec4 uv)
{
    mediump vec2 texcoord = fract(uv.xy) * uLayerScale;
    texcoord = clamp(texcoord - 2.0 * uInvTextureSize, vec2(0.0, 0.0), uLayerScale);
    texcoord += uv.zw;
    texcoord += uInvTextureSize;
    mediump vec3 albedo = texture2D(gDiffuseMap, texcoord).xyz;
    return albedo;
}

mediump vec3 CalcDiffuseAlbedo()
{
    // https://hal.inria.fr/hal-01824773/file/HPN2018.pdf
    mediump vec3 albedo0 = SamplerAlbedo(texcoord0) * barycentric.x;
    mediump vec3 albedo1 = SamplerAlbedo(texcoord1) * barycentric.y;
    mediump vec3 albedo2 = SamplerAlbedo(texcoord2) * barycentric.z;
    mediump vec3 albedo = albedo0 + albedo1 + albedo2;
    mediump vec3 w = barycentric;
    return albedo;
}

const mediump vec3 kAmbientStrength = vec3(0.1, 0.1, 0.1);
void main() {
    mediump vec3 L = normalize(lightDir);
    mediump vec3 N = normalize(wnrm);
    mediump float NdotL = dot(N, L);
    mediump vec3 diffAlbedo = CalcDiffuseAlbedo();
    mediump vec3 ambient = kAmbientStrength * diffAlbedo;
    mediump vec3 result = vec3(0.0, 0.0, 0.0);
#ifdef USE_SHADOW   // 阴影是在半兰伯特和兰伯特中插值; 没有任何模型,单纯是看上去对
    mediump float cosine = max(NdotL, 0.0);                                           
    mediump float shadow = getShadow(cosine);
    mediump float diff = mix(cosine, NdotL * 0.5 + 0.5, shadow);
    result = diffAlbedo * diff * lightColor.rgb;
#else               // 半兰伯特
    result = diffAlbedo * (NdotL * 0.5 + 0.5) * lightColor.rgb;        
#endif
    result = result + ambient;
    gl_FragColor = vec4(result, 1.0);
}