#version 300 es

// 光照、阴影相关
uniform mediump float useShadow;
uniform mediump vec3  lightDir;
uniform mediump vec3  viewPos;
uniform mediump vec4  lightColor;
uniform mediump sampler2DArray gDiffuseMap;
uniform mediump sampler2D uDepthMap;

uniform mediump vec4 uMaterialLayer[24];            // x纹理坐标的缩放; y随机化纹理控制值; zw 图集上对应材质的初始纹理位置
uniform mediump vec2 uLayerScale;                   // 图集上一张图的大小
in mediump vec3 texcoord0;
in mediump vec3 texcoord1;
in mediump vec3 texcoord2;
in mediump vec3 wpos;
in mediump vec3 wnrm;
in mediump vec3 barycentric;                   // barycentric-coordinate
in mediump vec4 fragPosLightSpace;

const mediump float shadowWeights[9] = float[9](
    0.0947416,  0.118318,   0.0947416,
    0.118318,   0.1477616,  0.118318,
    0.0947416,  0.118318,   0.0947416
);

mediump float getPCFShadow(mediump float NdotL) {
    mediump vec3 lightPosition = fragPosLightSpace.xyz / fragPosLightSpace.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    mediump vec2 invTextureSize = vec2(1.0, 1.0) / vec2(textureSize(uDepthMap, 0));

    // 越界判断
    bool b0 = lightPosition.x < invTextureSize.x;
    bool b1 = lightPosition.x > (1.0 - invTextureSize.x);
    bool b2 = lightPosition.y < invTextureSize.y;
    bool b3 = lightPosition.y > (1.0 - invTextureSize.y);
    if (b0 || b1 || b2 || b3)
        return 1.0;

    mediump float shadow = 0.0;    
    mediump float bias = mix(0.02, useShadow, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    for (lowp int y = -1; y <= 1; ++y) {
        for (lowp int x = -1; x <= 1; ++x) {
            mediump vec2 offset = vec2(x, y) * invTextureSize;
            mediump float closestDepth = texture(uDepthMap, lightPosition.xy + offset).r;
            mediump float weight = currentDepth <= closestDepth ? 1.0 : 0.0;
            lowp int index = ((y + 1) * 3) + (x + 1);
            weight *= shadowWeights[index];
            shadow += weight;
        }
    }
    return shadow;
}

mediump float getShadow(mediump float NdotL) {
#ifdef USE_SHADOW_PCF
    return getPCFShadow(NdotL);
#else
    mediump vec3 lightPosition = fragPosLightSpace.xyz / fragPosLightSpace.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    // 越界判断
    if (lightPosition.x < 0.0 || lightPosition.x > 1.0 || lightPosition.y < 0.0 || lightPosition.y > 1.0)
        return 1.0;

    mediump float bias = mix(0.02, useShadow, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    mediump float closestDepth = texture(uDepthMap, lightPosition.xy).r;
    return currentDepth <= closestDepth ? 1.0 : 0.0;
#endif
}

mediump vec3 SamplerAlbedo(mediump vec3 uv)
{   
    mediump vec3 albedo = textureGrad(gDiffuseMap, vec3(uv.xy, int(uv.z)), dFdx(uv.xy), dFdy(uv.xy)).xyz;
    return albedo;
}

mediump vec3 CalcDiffuseAlbedo()
{
    // https://hal.inria.fr/hal-01824773/file/HPN2018.pdf
    mediump vec3 albedo0 = SamplerAlbedo(texcoord0) * barycentric.x;
    mediump vec3 albedo1 = SamplerAlbedo(texcoord1) * barycentric.y;
    mediump vec3 albedo2 = SamplerAlbedo(texcoord2) * barycentric.z;
    mediump vec3 albedo = albedo0 + albedo1 + albedo2;
    return albedo;
}

out mediump vec4 outFragColor;
const mediump vec3 kAmbientStrength = vec3(0.1, 0.1, 0.1);
void main() 
{
    mediump vec3 L = normalize(lightDir);
    mediump vec3 N = normalize(wnrm);
    mediump float NdotL = dot(N, L);
    mediump vec3 diffAlbedo = CalcDiffuseAlbedo();
    mediump vec3 ambient = kAmbientStrength * diffAlbedo;
    mediump vec3 result = vec3(0.0, 0.0, 0.0);

#ifdef USE_SHADOW   // 阴影是在半兰伯特和兰伯特中插值; 没有任何模型,单纯是看上去对
    mediump float cosine = max(NdotL, 0.0);                                           
    mediump float shadow = getShadow(cosine);
    mediump float diff = mix(cosine, NdotL * 0.5 + 0.5, shadow);
    result = diffAlbedo * diff * lightColor.rgb;
#else               // 半兰伯特
    result = diffAlbedo * (NdotL * 0.5 + 0.5) * lightColor.rgb;        
#endif
    result += ambient;
    outFragColor = vec4(result, 1.0);
    
}