#version 100

uniform mediump float 		AB_mix_offset;  // : hint_range(-11., 2.5) = -6.187;
uniform mediump float 		AB_mix_normal;  // : hint_range(0., 20.) = 8.253;
uniform mediump float 		AB_mix_blend;  // : hint_range(0., 10.) = 2.;

uniform lowp int	        A_albedo_enabled;  // = true;
uniform mediump vec4 		A_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);
uniform sampler2D 	        A_albedo_map;  // : hint_albedo;

// uniform int		A_normal_enabled;  // = true;
// uniform sampler2D 	A_normal_map;  // : hint_normal;

uniform lowp int	        B_albedo_enabled;  // = true;
uniform mediump vec4 		B_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);
uniform sampler2D 	        B_albedo_map;  // : hint_albedo;

// uniform int		B_normal_enabled;  // = true;
// uniform sampler2D 	B_normal_map;  // : hint_normal;

uniform sampler2D			top_texA;
uniform sampler2D			top_texB;
uniform sampler2D			bottom_texA;
uniform sampler2D			bottom_texB;
uniform sampler2D			head_texA;
uniform sampler2D			head_texB;
uniform sampler2D			rear_texA;
uniform sampler2D			rear_texB;
uniform sampler2D			left_texA;
uniform sampler2D			left_texB;
uniform sampler2D			right_texA;
uniform sampler2D			right_texB;

uniform lowp int            blend_neighbour;

uniform mediump float	    blend_top;
uniform mediump float	    blend_bottom;
uniform mediump float	    blend_head;
uniform mediump float	    blend_rear;
uniform mediump float	    blend_left;
uniform mediump float	    blend_right;

uniform mediump float 		blend_distance;
uniform mediump vec3	    block_size;

varying mediump vec3 		A_uv_triplanar_pos;
varying mediump vec3 		A_uv_power_normal;
varying mediump vec3 		B_uv_triplanar_pos;
varying mediump vec3 		B_uv_power_normal;
varying mediump vec3 		vertex_normal;
varying mediump vec3		vertex_model_pos;
varying mediump vec4        light_intensity;


mediump vec4 triplanar_texture(sampler2D p_sampler, mediump vec3 p_weights, mediump vec3 p_triplanar_pos) {
        mediump vec4 samp=vec4(0.0);
        samp+= texture2D(p_sampler,p_triplanar_pos.xy) * p_weights.z;
        samp+= texture2D(p_sampler,p_triplanar_pos.xz) * p_weights.y;
        samp+= texture2D(p_sampler,p_triplanar_pos.zy * vec2(-1.0,1.0)) * p_weights.x;
        return samp;
}

mediump vec3 get_triplaner_color(lowp int enabledA, sampler2D texA, lowp int enabledB, sampler2D texB)
{
    mediump vec3 color;
    mediump vec3 colorA;
    mediump vec3 colorB;
    mediump float mix_factor;
    if (enabledA > 0)
    {
        color = colorA = A_albedo_tint.rgb * triplanar_texture(texA, A_uv_power_normal, A_uv_triplanar_pos).rgb;
        mix_factor = clamp(AB_mix_normal * dot(vec3(0., 1., 0.), vertex_normal) + AB_mix_offset + AB_mix_blend * colorA.g, 0., 1.);
    }
    if (enabledB > 0)
    {
        color = colorB = B_albedo_tint.rgb * triplanar_texture(texB, B_uv_power_normal, B_uv_triplanar_pos).rgb;
    }
    if (enabledA > 0 && enabledB > 0)
    {
        color = mix(colorB, colorA, mix_factor);
    }
    return color;
}

mediump float easeInOutSine(mediump float t)
{
    const mediump float PI = 3.14159265;
    return 0.5 * (1.0 - cos(PI * t));
}

mediump float easeInOutCubic(mediump float x)
{
    return x < 0.5 ? 4. * x * x * x : 1.0 - pow(-2. * x + 2., 3.) / 2.;
}

const lowp int TOP = 2;
const lowp int HEAD = 3;
const lowp int LEFT = 4;
const lowp int RIGHT = 5;
const lowp int REAR = 6;
const lowp int BOTTOM = 7;

mediump float getDistance(lowp int direction)
{
    if (TOP == direction) return block_size.y - vertex_model_pos.y;
    if (BOTTOM == direction) return vertex_model_pos.y;
    if (HEAD == direction) return vertex_model_pos.z;
    if (REAR == direction) return block_size.z - vertex_model_pos.z;
    if (LEFT == direction) return block_size.x - vertex_model_pos.x;
    if (RIGHT == direction) return vertex_model_pos.x;
}

void main() 
{
    
    // Calculate Albedo 
    mediump vec3 A_albedo;
    mediump vec3 B_albedo;
    mediump vec3 albedo;

    if (blend_neighbour == 0)
    {
        albedo = get_triplaner_color(A_albedo_enabled, A_albedo_map, B_albedo_enabled, B_albedo_map);
    }
    else
    {
        mediump float distance = getDistance(blend_neighbour);
        if (distance < 0. || distance > blend_distance) discard;

        mediump float w;
        mediump float percent = 1.0;
        mediump vec3 color;
        lowp int enabledB = 0;
        albedo = get_triplaner_color(A_albedo_enabled, A_albedo_map, B_albedo_enabled, B_albedo_map);
        if (blend_top > 0.0)
        {
            distance = getDistance(TOP);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_top > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, top_texA, enabledB, top_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
        if (blend_bottom > 0.0)
        {
            distance = getDistance(BOTTOM);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_bottom > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, bottom_texA, enabledB, bottom_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
        if (blend_head > 0.0)
        {
            distance = getDistance(HEAD);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_head > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, head_texA, enabledB, head_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
        if (blend_rear > 0.0)
        {
            distance = getDistance(REAR);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_rear > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, rear_texA, enabledB, rear_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
        if (blend_left > 0.0)
        {
            distance = getDistance(LEFT);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_left > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, left_texA, enabledB, left_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
        if (blend_right > 0.0)
        {
            distance = getDistance(RIGHT);
            if (0.0 <= distance && distance <= blend_distance)
            {
                enabledB = blend_right > 1.0 ? 1 : 0;
                w = easeInOutCubic(percent * (1.0 - distance / blend_distance));
                color = get_triplaner_color(1, right_texA, enabledB, right_texB);
                albedo = albedo * (1.0 - w) + color * w;
            }
        }
    }

    mediump vec4 result = light_intensity * vec4(albedo, 0.0);

    gl_FragColor = vec4(result.rgb, 1.0);
}

