#version 300 es

uniform mediump vec3 uViewPosition; 
uniform mediump vec3 uLightDirection;
uniform mediump vec3 uLightStrength;

in mediump vec3 ourPosition;           
in mediump vec3 ourTexcoord;                   // xy纹理坐标:  zw:图集上的图层
in mediump vec3 ourNormal;             
in mediump vec4 ourColor;     
in mediump vec4 ourLightSpacePos;         

uniform mediump vec2 uInvTextureSize;            // 1.f / 图集大小   
uniform mediump vec2 uMaterilaLayerScale;        // 一个图集的大小
uniform mediump sampler2DArray uMaterialLayerTexture;    // 图集

uniform mediump float uShadowBias;              
uniform sampler2D uDepthMap;       

mediump vec3 SamplerMaterialLayerTexture(mediump vec3 texcoord) 
{
    mediump vec2 uvs = texcoord.xy;
    return textureGrad(uMaterialLayerTexture, vec3(uvs, int(texcoord.z)), dFdx(uvs), dFdy(uvs)).rgb;
}

const mediump float shadowWeights[9] = float[9](
    0.0947416,  0.118318,   0.0947416,
    0.118318,   0.1477616,  0.118318,
    0.0947416,  0.118318,   0.0947416
);

mediump float getPCFShadow(mediump float NdotL) {
    mediump vec3 lightPosition = ourLightSpacePos.xyz / ourLightSpacePos.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    mediump vec2 invTextureSize = vec2(1.0, 1.0) / vec2(textureSize(uDepthMap, 0));

    // 越界判断
    bool b0 = lightPosition.x < invTextureSize.x;
    bool b1 = lightPosition.x > (1.0 - invTextureSize.x);
    bool b2 = lightPosition.y < invTextureSize.y;
    bool b3 = lightPosition.y > (1.0 - invTextureSize.y);
    if (b0 || b1 || b2 || b3)
        return 1.0;

    mediump float shadow = 0.0;    
    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    for (lowp int y = -1; y <= 1; ++y) {
        for (lowp int x = -1; x <= 1; ++x) {
            mediump vec2 offset = vec2(x, y) * invTextureSize;
            mediump float closestDepth = texture(uDepthMap, lightPosition.xy + offset).r;
            mediump float weight = currentDepth <= closestDepth ? 1.0 : 0.0;
            lowp int index = ((y + 1) * 3) + (x + 1);
            weight *= shadowWeights[index];
            shadow += weight;
        }
    }
    return shadow;
}

mediump float getShadow(mediump float NdotL) {
#ifdef USE_SHADOW_PCF
    return getPCFShadow(NdotL);
#else
    mediump vec3 lightPosition = ourLightSpacePos.xyz / ourLightSpacePos.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    // 越界判断
    if (lightPosition.x < 0.0 || lightPosition.x > 1.0 || lightPosition.y < 0.0 || lightPosition.y > 1.0)
        return 1.0;

    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    mediump float closestDepth = texture(uDepthMap, lightPosition.xy).r;
    return currentDepth <= closestDepth ? 1.0 : 0.0;
#endif
}

out mediump vec4 outFragColor;
const mediump vec3 kAmbientStrength = vec3(0.6, 0.6, 0.6);
void main() {
    mediump vec3 L = uLightDirection;
    mediump vec3 N = normalize(ourNormal);
    mediump vec3 V = normalize(uViewPosition - ourPosition);
    mediump vec3 H = normalize(V + L);
    mediump vec3 albedo = SamplerMaterialLayerTexture(ourTexcoord) * ourColor.rgb;
    
    mediump vec3 ambient = kAmbientStrength * albedo;
	
    mediump float NdotL  = max(dot(N, L), 0.0);
    mediump vec3 diffuse = albedo * NdotL * uLightStrength;
    
    mediump float NdotH   = max(dot(N, H), 0.0);
    mediump vec3 specular = albedo * uLightStrength * pow(NdotH, 32.0);

    mediump float shadow = 1.0;
#ifdef USE_SHADOW 
    shadow = getShadow(NdotL);
#endif
    mediump vec3 result = ambient + ((diffuse + specular) * shadow); 
    outFragColor = vec4(result, ourColor.a);
}
