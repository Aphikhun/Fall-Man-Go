#version 300 es
precision mediump float;
precision mediump sampler2DArray;
uniform sampler2DArray texSampler_texture;
//uniform sampler2D texSampler_texture;
uniform sampler2D texSampler_depthmap;
uniform mediump float useShadow;

//
in mediump vec3 oNormal;
in mediump vec4 claColor;
in mediump vec4 specularColor;
in mediump vec2 texCoord_texture;
in mediump vec4 FragPosLightSpace;
in mediump vec3 mainlightDir;

in mediump float oTexIndex;
//flat in int oTexIndex;
out vec4 fragColor;

#ifndef NEW_FOG
in mediump vec4 oFogColor;
#else
uniform mediump vec4 fogParam[3];

float LinearizeDepth(float depth, float near, float far) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

float ComputeFog(float z, float w, float density, float near, float far, float min, vec4 notUse)
{
	const float LOG2 = 1.442695;
	float fogFactor = exp2(-density * density * (z / w) * (z / w) * LOG2);
	fogFactor = clamp(fogFactor, 0.0, 1.0) + 1.0 - LinearizeDepth(z, near, far) / far;
	return clamp(fogFactor, min, 1.0);
}
#endif

mediump float getShadow()
{ 
  if(useShadow <= 0.0)
  {
    return 0.0;
  }  

  mediump float shadowIntensity = 0.43;
  //计算法线与光线夹角,背面，直接阴影
  if((dot(mainlightDir, oNormal)) < 0.0)
  {
    return 0.0; // has be calculated in c++ funtion "AutoCalculateQuadPbrColor"
  }
  
  // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
  mediump float closestDepth = 0.0; 
  // 取得当前片元在光源视角下的深度
  mediump float currentDepth = 0.0;
  mediump vec3 projCoords;
  mediump vec4 depthColor;

  mediump float bias = useShadow;
  mediump float shadow = 0.0;

  //
  projCoords = FragPosLightSpace.xyz / FragPosLightSpace.w;
  projCoords = projCoords * 0.5 + 0.5;
  //去掉深度图外、深度摄像机外的点的阴影计算
  if(projCoords.x >= 1.0 || projCoords.x <= 0.0 || projCoords.y >= 1.0 || projCoords.y <= 0.0 || projCoords.z > 1.0)
  {
    return 0.0;
  }

  depthColor = texture(texSampler_depthmap, projCoords.xy);
  closestDepth = depthColor.r;
  currentDepth = projCoords.z;
  shadow = (currentDepth - bias) > closestDepth  ? shadowIntensity : 0.0;

  //pcf
  //mediump vec2 texelSize = 1.0 / vec2(1024.0, 1024.0);
  //mediump float pcfDepth = texture(texSampler_depthmap, projCoords.xy + vec2(-1, -1) * texelSize).r; 
  //shadow += currentDepth - bias > pcfDepth ? shadowIntensity : 0.0;
  //shadow /= 2.0;
  
  //
  mediump float d = distance(projCoords.xy, vec2(0.5, 0.5)) - 0.4;
  d = (d <= 0.0) ? 0.0 : d;
  d = (d >= 0.1) ? 0.1 : d;
  shadow = mix(shadow, 0.0, d * 10.0);

  return shadow;
}

void main(void)
{
  mediump vec4 textureColor = texture(texSampler_texture, vec3(texCoord_texture,oTexIndex));

  if(textureColor.w < 0.2 )
  {
    discard;
  }

  mediump float shadow = getShadow();
  mediump vec4 finalColor = textureColor * claColor;
  finalColor.rgb *= 1.0 - step(1.0, textureColor.a) * shadow; 
  finalColor.rgb += step(shadow, 0.0) * specularColor.rgb;

#ifdef NEW_FOG
	vec4 oFogColor =  vec4(fogParam[1].rgb, ComputeFog(gl_FragCoord.z / gl_FragCoord.w, fogParam[0].z, fogParam[0].x, fogParam[0].y, fogParam[0].w, fogParam[2]));
#endif

  fragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a);
}
