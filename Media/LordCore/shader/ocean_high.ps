#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
	precision highp float; 
#else
	precision mediump float; 
#endif

uniform sampler2D waterNormalTex;
uniform sampler2D foamMap;
uniform samplerCube cubeMap;
uniform sampler2D DepthTex;
uniform sampler2D SceneTex;

uniform vec4 u_lightColor;
uniform vec3 u_lightDir;
uniform vec4 u_waveScale;
uniform vec4 u_oceanParam;
uniform vec4 u_WaveParam;

uniform vec2 u_waveMovement;
uniform vec2 u_nearfarclip;
uniform vec3 u_ShoreColor;
uniform vec3 u_SeaColor;

varying vec3 normal;
varying vec4 v_fogColor;
varying highp vec2 texcoord;
varying vec4 toEyeW;
varying vec4 v_ScreenProj;

vec4 ColorToLinear(vec4 color)
{
	vec4 linearColor = vec4(color.r*color.r,color.g*color.g,color.b*color.b,color.a);
	return linearColor;
}

vec4 LinearToTarget(vec4 color)
{
	vec4 c = vec4(sqrt(color.r),sqrt(color.g),sqrt(color.b),color.a);
	return c;
}

void main()
{	
    vec3 normalB = normalize(normal);
    vec2 shift = (normalB.xz * 2.0 - vec2(1.0, 1.0)) * u_WaveParam.w;

	vec4 tex;
	tex.xy = texcoord * u_waveScale.z + u_waveMovement;
	tex.zw = texcoord * u_waveScale.w + u_waveMovement;

    tex += vec4(shift.xy, shift*1.4);
	 // Sample normal map.
    vec3 normalT0 = texture2D(waterNormalTex, tex.xy).rgb;
    vec3 normalT1 = texture2D(waterNormalTex, tex.zw).rgb;
    
	vec3 normalN = (normalT0 + normalT1) - vec3(1.0, 1.0, 1.0);
    normalN = normalize(vec3(normalN.x, 0, normalN.y) * 0.25 + normalB);
	
	vec3 ToEyeW = normalize(toEyeW.xyz);
    vec3 r = reflect(-ToEyeW, normalN );

    float temp = 0.9;
	vec2 noRefractionTC = v_ScreenProj.xy / v_ScreenProj.w;
	noRefractionTC.y = 1.0 - noRefractionTC.y;
	float linearDepth = texture2D(DepthTex, noRefractionTC, 0.0).x * 0.000001 + temp;
	linearDepth = u_nearfarclip.x / (linearDepth * (u_nearfarclip.x - u_nearfarclip.y) + u_nearfarclip.y);
	linearDepth += linearDepth > 0.9 ? 1.0 : 0.0;
	linearDepth *= u_nearfarclip.y;
	float waterDepth = linearDepth - v_ScreenProj.w;
	waterDepth = mix(v_ScreenProj.w, waterDepth, clamp(toEyeW.w, 0.0, 1.0));
	float edgeSoftIntersectFactor = clamp(waterDepth, 0.0, 1.0);

	vec2 refactionTCOffset = normalN.xz * u_WaveParam.w * edgeSoftIntersectFactor * v_ScreenProj.z;
	vec2 refactionTC = noRefractionTC + refactionTCOffset;
	float refracSceneDepth = texture2D(DepthTex, refactionTC, 0.0).x * 0.000001 + temp;
	refracSceneDepth = u_nearfarclip.x / (refracSceneDepth * (u_nearfarclip.x - u_nearfarclip.y) + u_nearfarclip.y);
	refracSceneDepth += refracSceneDepth > 0.9 ? 1.0 : 0.0;
	refracSceneDepth *= u_nearfarclip.y;

	float refactionMask = v_ScreenProj.w <= refracSceneDepth ? 1.0 : 0.0;
	vec3 refractionColor = texture2D(SceneTex, noRefractionTC + refactionTCOffset * refactionMask, 0.0).xyz;
	vec3 reflection = textureCube(cubeMap, r).xyz;

	waterDepth = mix(waterDepth, refracSceneDepth - v_ScreenProj.w, refactionMask);

	// foam
	float cameraSoft = clamp(v_ScreenProj.w - 0.33, 0.0, 1.0);
	float foam = texture2D(foamMap, (tex.xy + normalN.xz) * 0.4).x * cameraSoft;
	foam = foam * clamp(foam - waterDepth, 0.0, 1.0);
	foam = foam * waterDepth * 0.1;

	waterDepth = 1.0 - min(waterDepth / (20.0 * u_WaveParam.z), 1.0);

	float maxValue = 0.5;//0.5;
	float depthfactor = 1.0 - (waterDepth - maxValue) * (1.0 / maxValue);
	depthfactor = depthfactor * depthfactor;
	depthfactor = depthfactor * 0.8;
	depthfactor = min(1.0, depthfactor);
	depthfactor = depthfactor * (1.0 - waterDepth);

	// Calculate colors
	float blendFactor = 1.0 - min(1.0, waterDepth * 1.6);
	float tx = texcoord.x - 0.5;
	float ty = texcoord.y - 0.5;
	float tmp = (tx * tx + ty * ty) / (0.75 * 0.75);
	float blendFactorMul = step(1.0, tmp);
	// Can't be above 1.0, so no clamp needed
	float blendFactor2 = clamp(blendFactor, 0.0, 1.0);
	blendFactor = mix(blendFactor2, blendFactor, blendFactorMul);
	vec4 color = vec4(mix(u_ShoreColor, u_SeaColor, blendFactor), 1.0);
	
	float fresnel = clamp(r.y, 0.0, 1.0);
	fresnel = clamp(pow(fresnel, u_oceanParam.w), 0.0, 1.0);

	vec3 RLightDir = reflect(-u_lightDir, normalN);
	float dotSpec = clamp(dot(RLightDir, ToEyeW) * 0.5 + 0.5, 0.0, 1.0);
	vec3 specular = pow(dotSpec, 512.0) * u_lightColor.rgb * 2.0;  //pow(max(dot(RLightDir, toEyeT), 0.0f), 512);

	color.rgb = mix(refractionColor * fresnel, specular + color.rgb + reflection * (1.0 - fresnel), cameraSoft*depthfactor);

	color.rgb += foam * clamp(dot(vec3(0, 1, 0), u_lightDir.xyz), 0.0, 1.0);
	
    color = ColorToLinear(color);
    color.rgb = mix(v_fogColor.rgb, color.rgb, v_fogColor.a);
    color = LinearToTarget(color);
	
	gl_FragColor = color;
}
