#version 100

precision mediump float;

uniform sampler2D texSampler;
uniform sampler2D texSampler_noise;
uniform float discardAlpha;
uniform vec4 uvParam;
uniform float edgeParam;

varying vec4 color;
varying vec2 texCoord;
varying vec3 normal;
varying vec3 viewDir;

#ifndef NEW_FOG
varying vec4 oFogColor;
#else
uniform vec4 fogParam[3];

float LinearizeDepth(float depth, float near, float far) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

float ComputeFog(float z, float w, float density, float near, float far, float min, vec4 notUse)
{
	const float LOG2 = 1.442695;
	float fogFactor = exp2(-density * density * (z / w) * (z / w) * LOG2);
	fogFactor = clamp(fogFactor, 0.0, 1.0) + 1.0 - LinearizeDepth(z, near, far) / far;
	return clamp(fogFactor, min, 1.0);
}
#endif

void main(void)
{
	float speed1 = 5.0;
	float speed2 = 10.0;
	vec2 uv = gl_FragCoord.xy * uvParam.x + uvParam.zw;
	vec3 textureColor1 = texture2D(texSampler, uv + uvParam.y * speed1).rgb;
	vec3 textureColor2 = texture2D(texSampler, uv + vec2(uvParam.y * speed2, 0.5)).rgb;
	vec4 finalColor = vec4(mix(textureColor1, textureColor2, 0.5), 1.0);

	vec3 lightColor = vec3(1.0, 1.0, 1.0);
	vec4 noiseColor = texture2D(texSampler_noise, texCoord + uvParam.y * 10.0);
	float edge = pow(1.0 - abs(dot(normalize(viewDir), normal)), 4.0) * 2.0 * edgeParam;
	finalColor.rgb = mix(finalColor.rgb, lightColor, edge);
	finalColor.rgb = mix(finalColor.rgb, lightColor, edge * noiseColor.r);

	finalColor = finalColor * color;

#ifdef NEW_FOG
	vec4 oFogColor =  vec4(fogParam[1].rgb, ComputeFog(gl_FragCoord.z, gl_FragCoord.w, fogParam[0].z, fogParam[0].x, fogParam[0].y, fogParam[0].w, fogParam[2]));
#endif

	gl_FragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a);
}
