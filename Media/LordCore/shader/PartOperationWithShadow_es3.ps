#version 300 es

uniform mediump int uMaterialIndex;
uniform mediump float uTexcoordScale;
uniform mediump float uShadowBias;              
uniform mediump vec4 uCustomColor;
uniform mediump vec3 uViewPosition; 
uniform mediump vec3 uLightDirection;
uniform mediump vec3 uLightStrength;
uniform mediump sampler2D uDepthMap;  
uniform mediump sampler2DArray uTextureArray;

#define USE_SHADOW
#define USE_SHADOW_PCF

in mediump vec3 ourPosition;
in mediump vec2 ourTexcoord;
in mediump vec3 ourNormal;
in mediump vec4 ourColor;    
in mediump vec4 ourLightSpacePosition;

const mediump float shadowWeights[9] = float[9](
    0.0947416,  0.118318,   0.0947416,
    0.118318,   0.1477616,  0.118318,
    0.0947416,  0.118318,   0.0947416
);

mediump float getPCFShadow(mediump float NdotL) {
    mediump vec3 lightPosition = ourLightSpacePosition.xyz / ourLightSpacePosition.w;
    lightPosition = lightPosition * 0.5 + 0.5;
    mediump vec2 invTextureSize = vec2(1.0, 1.0) / vec2(textureSize(uDepthMap, 0));

    // 越界判断
    lowp int flag = int(lightPosition.x < invTextureSize.x);
    flag += int(lightPosition.x > (1.0 - invTextureSize.x));
    flag += int(lightPosition.y < invTextureSize.y);
    flag += int(lightPosition.y > (1.0 - invTextureSize.y));
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;

    mediump float shadow = 0.0;    
    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    for (lowp int y = -1; y <= 1; ++y)  {
        for (lowp int x = -1; x <= 1; ++x) {
            mediump vec2 offset = vec2(x, y) * invTextureSize;
            mediump float closestDepth = texture(uDepthMap, lightPosition.xy + offset).r;
            mediump float weight = currentDepth <= closestDepth ? 1.0 : 0.0;
            lowp int index = ((y + 1) * 3) + (x + 1);
            weight *= shadowWeights[index];
            shadow += weight;
        }
    }
    return shadow;
}

mediump float getShadow(mediump float NdotL) {
#ifdef USE_SHADOW_PCF
    return getPCFShadow(NdotL);
#else
    mediump vec3 lightPosition = ourLightSpacePosition.xyz / ourLightSpacePosition.w;
    lightPosition = lightPosition * 0.5 + 0.5;

    // 越界判断
    lowp int flag = int(lightPosition.x < 0.0);
    flag += int(lightPosition.x > 1.0);
    flag += int(lightPosition.y < 0.0);
    flag += int(lightPosition.y > 1.0);
    flag += int(lightPosition.z > 1.0);
    if (flag > 0)
        return 1.0;

    mediump float bias = mix(0.02, uShadowBias, NdotL);
    mediump float currentDepth = lightPosition.z - bias;
    mediump float closestDepth = texture(uDepthMap, lightPosition.xy).r;
    return currentDepth <= closestDepth ? 1.0 : 0.0;
#endif
}

mediump vec4 getAlbedo() {
    mediump vec2 texcoord = ourTexcoord * uTexcoordScale;
    return texture(uTextureArray, vec3(texcoord, uMaterialIndex));
}

out mediump vec4 outFragColor;
const mediump vec3 kAmbientStrength = vec3(0.6, 0.6, 0.6);
void main() {
    mediump vec3 L = uLightDirection;
    mediump vec3 N = normalize(ourNormal);
    mediump vec3 V = normalize(uViewPosition - ourPosition);
    mediump vec3 H = normalize(V + L);

    // ambient
    mediump vec4 albedo = getAlbedo() * ourColor * uCustomColor;
    mediump vec3 ambient = vec3(albedo) * kAmbientStrength;
    
    // diffuse
    mediump float NdotL = max(dot(N, L), 0.0);
    mediump vec3 diffuse = vec3(albedo) * NdotL * uLightStrength;

    // specular
    mediump float NdotH = max(dot(N, H), 0.0);
    mediump float specFactor = pow(NdotH, 32.0);
    mediump vec3 specular = vec3(albedo) * specFactor * uLightStrength;

    mediump float shadow = 1.0;
#ifdef USE_SHADOW 
    shadow = getShadow(NdotL);
#endif
    mediump vec3 result = ambient + (diffuse + specular) * shadow;
    outFragColor = vec4(result, albedo.a);
}