#version 100

precision mediump float;

uniform sampler2D texSampler;
//uniform mediump vec4 multiCalColor;
uniform vec4 customColor;
uniform float discardAlpha;

varying vec2 texCoord;
varying vec2 texCoordBatch1;
varying vec2 texCoordBatch2;
//varying float useOverlayColorReplaceMode;

#ifndef NEW_FOG
varying vec4 oFogColor;
#else
uniform vec4 fogParam[3];

float LinearizeDepth(float depth, float near, float far) 
{
    float z = depth * 2.0 - 1.0; // back to NDC 
    return (2.0 * near * far) / (far + near - z * (far - near));    
}

float ComputeFog(float z, float w, float density, float near, float far, float min, vec4 notUse)
{
	const float LOG2 = 1.442695;
	float fogFactor = exp2(-density * density * (z / w) * (z / w) * LOG2);
	fogFactor = clamp(fogFactor, 0.0, 1.0) + 1.0 - LinearizeDepth(z, near, far) / far;
	return clamp(fogFactor, min, 1.0);
}
#endif

void main(void)
{
	float u = mod(texCoord.x, 1.0);
	float v = mod(texCoord.y, 1.0);
	u = mix(texCoordBatch1.x, texCoordBatch2.x, u);
	v = mix(texCoordBatch1.y, texCoordBatch2.y, v);
	vec4 textureColor = texture2D(texSampler, vec2(u, v));

	if(textureColor.a < discardAlpha)
	{
		discard;
	}
	
	//if(textureColor.a < 0.3)
	//{
	//	textureColor = textureColor * (1.0 - customColor.w) + customColor * customColor.w;
	//	textureColor.w = 1.0;
	//}

	//float temp = step(0.3, textureColor.a);
  	//textureColor.a = temp * textureColor.a + (1.0 - temp) * 1.0;
	
	//textureColor.rgb = textureColor.rgb * 0.7 + vec3(0.0, 0.0, 1.0) * 0.3;

	vec4 finalColor;
	finalColor.a = textureColor.a;
	//finalColor.rgb = (1.0 - useOverlayColorReplaceMode) * textureColor.rgb * multiCalColor.rgb + useOverlayColorReplaceMode * multiCalColor.rgb;
	finalColor.rgb = textureColor.rgb;

#ifdef NEW_FOG
	vec4 oFogColor =  vec4(fogParam[1].rgb, ComputeFog(gl_FragCoord.z, gl_FragCoord.w, fogParam[0].z, fogParam[0].x, fogParam[0].y, fogParam[0].w, fogParam[2]));
#endif	
	gl_FragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a);
}
