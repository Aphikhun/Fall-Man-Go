#version 100

uniform sampler2D texSampler;
uniform sampler2D texSampler_depthmap;

uniform mediump vec4 naturalColor;
uniform mediump vec4 customColor;
uniform mediump float useShadow;
uniform mediump float discardAlpha;

uniform mediump int useReflect;
uniform mediump float reflectScale;
uniform sampler2D texSampler_reflect;
uniform mediump int useReflectMaskTexture;
uniform sampler2D texSampler_reflect_mask;

uniform mediump int useOriginalcolor;

uniform mediump int isUiActor;

uniform mediump int useEdge;
uniform mediump vec4 edgeColor;
uniform mediump vec3 uvParam;
uniform mediump int useMultiSamplerSize;
uniform sampler2D testSampler;
uniform sampler2D texSampler_02;
uniform sampler2D texSampler_03;
uniform mediump float alpha;

varying mediump vec4 oFogColor;
varying mediump vec4 color;
varying mediump vec2 texCoord;
varying mediump vec3 normal;
varying mediump vec3 viewDir;
varying mediump vec4 FragPosLightSpace;
varying mediump vec3 vMainLightDir;
varying mediump vec4 vMainLightColor;
varying mediump vec4 vSpecularColor;
varying mediump vec4 uSpecularColor;
varying mediump float useOverlayColorReplaceMode;
varying mediump vec4 vertexPos;

mediump vec2 dirToUV(in mediump vec3 dir) 
{
	//return clamp(vec2(0.5*(1.0 + atan(dir.x,dir.z) / 3.1415926), acos(-dir.y) / 3.1415926), 0.0, 1.0);
	return clamp(vec2(0.5*(1.0 + atan(dir.x,dir.y) / 3.1415926), acos(dir.z) / 3.1415926), 0.0, 1.0);
}

mediump float LQZ();

mediump float getShadow()
{  
  // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
  mediump float closestDepth = 0.0; 
  // 取得当前片元在光源视角下的深度
  mediump float currentDepth = 0.0;
  mediump vec3 projCoords;
  mediump vec4 depthColor;

  mediump float bias = useShadow;
  mediump float shadow = 0.0;
  mediump float shadowIntensity = 0.43;

  //
  projCoords = FragPosLightSpace.xyz / FragPosLightSpace.w;
  projCoords = projCoords * 0.5 + 0.5;
  //去掉深度图外、深度摄像机外的点的阴影计算
//   if(projCoords.x >= 1.0 || projCoords.x <= 0.0 || projCoords.y >= 1.0 || projCoords.y <= 0.0 || projCoords.z > 1.0)
//   {
//     return 0.0;
//   }

  mediump float tmp = 1.0 - max(sign(1.0 - projCoords.x), 0.0) 
  					+ 1.0 - max(sign(projCoords.x - 0.0), 0.0) 
					+ 1.0 - max(sign(1.0 - projCoords.y), 0.0) 
					+ 1.0 - max(sign(projCoords.y - 0.0), 0.0)
					+ max(sign(projCoords.z - 1.0), 0.0);
  
//   return min(tmp, 0.0);
  return min(0.0, tmp);



  depthColor = texture2D(texSampler_depthmap, projCoords.xy);
  closestDepth = depthColor.r;
  currentDepth = projCoords.z;
  shadow = (currentDepth - bias) > closestDepth  ? shadowIntensity : 0.0;
    
  //
  mediump float d = distance(projCoords.xy, vec2(0.5, 0.5)) - 0.4;
  d = (d <= 0.0) ? 0.0 : d;
  d = (d >= 0.1) ? 0.1 : d;
  shadow = mix(shadow, 0.0, d * 10.0);

  return shadow;
}

mediump vec4 multiSamplerColor(in mediump vec4 mainSampler, in mediump sampler2D subSampler, in mediump vec2 subSamplerCoord) 
{
	mediump vec4 subSamplerColor = texture2D(subSampler, subSamplerCoord);
	// return mainSampler + subSamplerColor;
	return mix(mainSampler, subSamplerColor, subSamplerColor.r);
}

void main(void)
{
	mediump vec2 coord = texCoord * uvParam.xy;
	mediump vec4 textureColor = texture2D(texSampler, coord);
	mediump vec4 blendTextureColor;
	if(useMultiSamplerSize > 0 && useMultiSamplerSize <= 1)
	{
		// blendTextureColor = multiSamplerColor(textureColor, testSampler, coord);
		if(dot(normalize(vec3(vertexPos.x, vertexPos.y, vertexPos.z)), vec3(1.0, 0.0, 0.0)) > 0.0)
		{
			blendTextureColor = multiSamplerColor(textureColor, testSampler, coord);
		}
	}
	else if(useMultiSamplerSize > 1 && useMultiSamplerSize < 2)
	{
		blendTextureColor *= multiSamplerColor(textureColor, texSampler_02, coord);
	}
	else if(useMultiSamplerSize > 2 && useMultiSamplerSize < 3)
	{
		blendTextureColor *= multiSamplerColor(textureColor, texSampler_03, coord);
	}
	
	if(useMultiSamplerSize > 0)
	{
		// textureColor = blendTextureColor;
	}
	

	if(textureColor.a < discardAlpha)
	{
		discard;
	}
	
	mediump vec4 finalColor;
	if(useOriginalcolor>0)
	{
		finalColor = (1.0 - useOverlayColorReplaceMode) * textureColor * color + useOverlayColorReplaceMode * color;
	}
	else
	{
		if(textureColor.a < 0.3)
		{
			textureColor = textureColor * (1.0 - customColor.w) + customColor * customColor.w;
			textureColor.w = 1.0;
		}

		finalColor = (1.0 - useOverlayColorReplaceMode) * textureColor * color + useOverlayColorReplaceMode * color;
		if(naturalColor.x < 1.0 || naturalColor.y < 1.0 || naturalColor.z < 1.0)
		{
			textureColor.w = finalColor.r * 0.299 + finalColor.g * 0.587 + finalColor.b * 0.114;
			finalColor = naturalColor * textureColor.w;
		}
	}
	
	mediump float shadow = 0.0;
	if(useShadow > 0.0)
	{
	 shadow = getShadow();
	 finalColor.rgb *= clamp((1.0-shadow), 0.0, 1.0);
	}


	mediump float reflectMask = 1.0;
	if(useReflectMaskTexture>0)
	{
		reflectMask *= texture2D(texSampler_reflect_mask, texCoord).r;
	}

	finalColor.rgb += (shadow > 0.0 ? vSpecularColor.rgb*0.00001 : vSpecularColor.rgb) * reflectMask;
	
	if(useReflect>0)
	{
		mediump vec3 reflectDir = reflect(-vMainLightDir, normal);
		mediump vec4 reflectTexColor = texture2D(texSampler_reflect, dirToUV(-reflectDir));
		finalColor.rgb = mix(finalColor.rgb, reflectTexColor.rgb * uSpecularColor.rgb, useReflectMaskTexture>0?reflectMask * reflectScale : reflectScale);
	}
	
	if(useEdge>0)
	{
		//make the special pos for ui actor
		mediump vec3 viewDirForCalc = isUiActor > 0 ? vec3(0.0, 0.0, 1.0) : normalize(viewDir);
		mediump float edge = pow(1.0 - abs(dot(viewDirForCalc, normal)), 3.0); 
		finalColor.rgb = mix(finalColor.rgb, edgeColor.rgb, edge);
	}

	finalColor.a *= alpha;

	// if(dot(normalize(vec3(vertexPos.x, vertexPos.y, vertexPos.z)), vec3(0.0, -1.0, 0.0)) > 0.0)
	// {
	// 	gl_FragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a) + vec4(1.0, 0.0, 0.0, 0.0);
	// }
	// else 
	// {
	// 	gl_FragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a);
	// }
	 gl_FragColor = vec4(mix(oFogColor.rgb, finalColor.rgb, oFogColor.a), finalColor.a);
	
}
