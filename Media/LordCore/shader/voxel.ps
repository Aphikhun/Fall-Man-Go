#version 100

uniform mediump float 		AB_mix_offset;  // : hint_range(-11., 2.5) = -6.187;
uniform mediump float 		AB_mix_normal;  // : hint_range(0., 20.) = 8.253;
uniform mediump float 		AB_mix_blend;  // : hint_range(0., 10.) = 2.;

uniform mediump vec4 		A_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);
uniform mediump vec4 		B_albedo_tint;  // : hint_color = vec4(1., 1., 1., 1.);

// 光照、阴影相关
uniform mediump float       useShadow;
uniform mediump float       imageSize;

uniform mediump vec3        lightDir;
uniform mediump vec3        viewPos;
uniform mediump vec4        lightColor;

uniform sampler2D			voxelTex;
uniform sampler2D			depthMap;
uniform mediump vec4        textureId0;
uniform mediump vec4        textureId1;
uniform mediump float       voxelTexSize;
uniform mediump float       border;
uniform mediump float       cellPerRow;
uniform mediump float       KB;

uniform mediump float       materialCount;  // 0: Grass, 1: Single material, 2: Multi materials
uniform sampler2D           grassTexA;
uniform sampler2D           grassTexB;

uniform lowp int            materialTexA0;
uniform lowp int            materialTexA1;
uniform lowp int            materialTexA2;
uniform lowp int            materialTexA3;
uniform lowp int            materialTexA4;
uniform lowp int            materialTexA5;
uniform lowp int            materialTexA6;
uniform lowp int            materialTexB0;
uniform lowp int            materialTexB1;
uniform lowp int            materialTexB2;
uniform lowp int            materialTexB3;
uniform lowp int            materialTexB4;
uniform lowp int            materialTexB5;
uniform lowp int            materialTexB6;

varying mediump vec3 		A_uv_triplanar_pos;
varying mediump vec3 		A_uv_power_normal;
varying mediump vec3 		B_uv_triplanar_pos;
varying mediump vec3 		B_uv_power_normal;
varying mediump vec3 		vertex_normal;
varying mediump vec3        fragNormal;
varying mediump vec4		blend_weights;
varying mediump vec4		blend_weights2;
varying mediump vec4        FragPosLightSpace;

#define USE_SHADOW_PCF

mediump float getShadow()
{
    // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)
    mediump float closestDepth = 0.0;
    // 取得当前片元在光源视角下的深度
    mediump float currentDepth = 0.0;
    mediump vec3 projCoords;
    mediump vec4 depthColor;

	mediump float bias = 0.2 * useShadow;
    mediump float shadow = 0.0;
    mediump float shadowIntensity = 0.43;

    //
    projCoords = FragPosLightSpace.xyz / FragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    //去掉深度图外、深度摄像机外的点的阴影计算
    mediump float tmp = 1.0 - max(sign(1.0 - projCoords.x), 0.0) 
            + 1.0 - max(sign(projCoords.x - 0.0), 0.0) 
            + 1.0 - max(sign(1.0 - projCoords.y), 0.0) 
            + 1.0 - max(sign(projCoords.y - 0.0), 0.0)
            + max(sign(projCoords.z - 1.0), 0.0)
            + 1.0 - sign(useShadow);
  
	if(tmp > 0.0) return 0.0;

	currentDepth = projCoords.z;
#ifdef USE_SHADOW_PCF
	// PCF
	mediump vec2 pixelSize = vec2(1.0 / imageSize);
    mediump float shadowWeights[9];
    shadowWeights[0] = shadowWeights[2] = shadowWeights[6] = shadowWeights[8] = 0.0947416;
    shadowWeights[1] = shadowWeights[3] = shadowWeights[5] = shadowWeights[7] = 0.118318;
    shadowWeights[4] = 0.1477616;
    lowp int wi = 0;
	for (lowp int i = -1; i <= 1; ++i)
	{
		for (lowp int j = -1; j <= 1; ++j)
		{
			depthColor = texture2D(depthMap, projCoords.xy + pixelSize * vec2(i, j));
			closestDepth = depthColor.r;
			mediump float s = (1.0 - step(currentDepth - bias, closestDepth)) * shadowIntensity;
            for (lowp int k = 0; k < 9; ++k)
            {
                if (k == wi) shadow += s * shadowWeights[k];
            }
            wi = wi + 1;
		}
	}
#else
	depthColor = texture2D(depthMap, projCoords.xy);
	closestDepth = depthColor.r;
	shadow = (1.0 - step(currentDepth - bias, closestDepth)) * shadowIntensity;
#endif

    //
    mediump float d = distance(projCoords.xy, vec2(0.5, 0.5)) - 0.4;
    d = clamp(d, 0.0, 0.1);
    shadow = mix(shadow, 0.0, d * 10.0);

    return shadow;
}

mediump vec2 signV(mediump vec2 val)
{
    return step(-0.00001, val) * 2.0 - 1.0;
}

mediump vec4 triplanar_texture(mediump float texId, mediump vec3 p_weights, mediump vec3 p_triplanar_pos) 
{
    mediump float one2b = 1.0 + 2.0 * border;
    mediump float j = floor(texId / cellPerRow);
    mediump float i = texId - j * cellPerRow;
    mediump vec2 iPos = vec2(i, j);
    mediump vec3 flip = 2.0 * step(vec3(0.0), vertex_normal) - 1.0;
    mediump vec2 posX = fract(p_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posY = fract(p_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posZ = fract(p_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec2 uvX = (iPos * one2b + border + posX) / KB;
    mediump vec2 uvY = (iPos * one2b + border + posY) / KB;
    mediump vec2 uvZ = (iPos * one2b + border + posZ) / KB;
    // mediump float fix = 1.0 / voxelTexSize;
    // mediump vec2 minUV = (iPos * one2b + border) / KB + vec2(fix, fix);
    // mediump vec2 maxUV = (iPos * one2b + border + vec2(1.0, 1.0)) / KB - vec2(fix, fix);
    // uvX = clamp(uvX, minUV, maxUV);
    // uvY = clamp(uvY, minUV, maxUV);
    // uvZ = clamp(uvZ, minUV, maxUV);
    mediump vec4 samp = texture2D(voxelTex, uvX) * p_weights.x;
    samp       = samp + texture2D(voxelTex, uvY) * p_weights.y;
    samp       = samp + texture2D(voxelTex, uvZ) * p_weights.z;
    return samp;
}

mediump int    material_tex_ids[16];
mediump float  indices2TexIds[8];

void init_arrays()
{
    material_tex_ids[0] = materialTexA0;
    material_tex_ids[1] = materialTexA1;
    material_tex_ids[2] = materialTexA2;
    material_tex_ids[3] = materialTexA3;
    material_tex_ids[4] = materialTexA4;
    material_tex_ids[5] = materialTexA5;
    material_tex_ids[6] = materialTexA6;
    material_tex_ids[7] = materialTexB0;
    material_tex_ids[8] = materialTexB1;
    material_tex_ids[9] = materialTexB2;
    material_tex_ids[10] = materialTexB3;
    material_tex_ids[11] = materialTexB4;
    material_tex_ids[12] = materialTexB5;
    material_tex_ids[13] = materialTexB6;

    indices2TexIds[0] = textureId0[0];
    indices2TexIds[1] = textureId0[1];
    indices2TexIds[2] = textureId0[2];
    indices2TexIds[3] = textureId0[3];
    indices2TexIds[4] = textureId1[0];
    indices2TexIds[5] = textureId1[1];
    indices2TexIds[6] = textureId1[2];
    indices2TexIds[7] = textureId1[3];
}

mediump vec4 getMaterialColor(mediump int idxA, mediump int idxB)
{
    mediump float texIdA = 0.0;
    mediump float texIdB = 0.0;
    for (lowp int i = 0; i < 8; ++i)
    {
        if (i == idxA) texIdA = indices2TexIds[i];
        if (i == idxB) texIdB = indices2TexIds[i];
    }
    mediump vec4 color = A_albedo_tint * triplanar_texture(texIdA, A_uv_power_normal, A_uv_triplanar_pos);
    mediump float enabledB = step(float(idxB), 6.5);
    mediump vec4 colorB = B_albedo_tint * triplanar_texture(texIdB, B_uv_power_normal, B_uv_triplanar_pos);
    mediump float mix_factor = clamp(AB_mix_normal * vertex_normal.y + AB_mix_offset + AB_mix_blend * color.g, 0., 1.);
    mix_factor = 1.0 - enabledB + enabledB * mix_factor;
    color = mix(colorB, color, mix_factor);
    return color;
}

mediump vec4 getMultiMaterialColor()
{
    mediump vec4 albedo = vec4(0.);
    mediump vec4 weight0 = blend_weights;
    mediump vec4 weight1 = blend_weights2;
    // mediump vec4 weight0 = blend_weights * blend_weights * blend_weights;
    // mediump vec4 weight1 = blend_weights2 * blend_weights2 * blend_weights2;
    // weight0 *= weight0;
    // weight1 *= weight1;
    // mediump float total = dot(vec4(1.0), weight0) + dot(vec4(1.0), weight1);
    // weight0 /= total;
    // weight1 /= total;

    for (lowp int i = 0; i < 4; ++i)
    {
        if (weight0[i] > 0.0) albedo = albedo + weight0[i] * getMaterialColor(material_tex_ids[i], material_tex_ids[i + 7]);    
        if (weight1[i] > 0.0) albedo = albedo + weight1[i] * getMaterialColor(material_tex_ids[i + 4], material_tex_ids[i + 11]);
    }

    return albedo;
}

mediump vec4 getSingleMaterialColor()
{
    mediump vec3 flip = 2.0 * step(vec3(0.0), vertex_normal) - 1.0;
    mediump vec2 posAX = fract(A_uv_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posAY = fract(A_uv_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posAZ = fract(A_uv_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec4 sampA = texture2D(grassTexA, posAX) * A_uv_power_normal.x;
    sampA      = sampA + texture2D(grassTexA, posAY) * A_uv_power_normal.y;
    sampA      = sampA + texture2D(grassTexA, posAZ) * A_uv_power_normal.z;
    mediump vec2 posBX = fract(B_uv_triplanar_pos.zy * vec2(-flip.x, 1.0));
    mediump vec2 posBY = fract(B_uv_triplanar_pos.xz * vec2(-flip.y, 1.0));
    mediump vec2 posBZ = fract(B_uv_triplanar_pos.xy * vec2(flip.z, 1.0));
    mediump vec4 sampB = texture2D(grassTexB, posBX) * B_uv_power_normal.x;
    sampB      = sampB + texture2D(grassTexB, posBY) * B_uv_power_normal.y;
    sampB      = sampB + texture2D(grassTexB, posBZ) * B_uv_power_normal.z;
    mediump float mix_factor = clamp(AB_mix_normal * dot(vec3(0., 1., 0.), vertex_normal) + AB_mix_offset + AB_mix_blend * sampA.g, 0., 1.);
    mediump float B_weight = step(materialCount, 0.5);
    mix_factor = B_weight * mix_factor + (1.0 - B_weight);
    return mix(sampB, sampA, mix_factor);
}

void main() 
{
    init_arrays();
    // Calculate Albedo 
    mediump vec4 albedo;
    // if (materialCount > 1.0)
    // {
        albedo = getMultiMaterialColor();
    // }
    // else
    // {
    //     albedo = getSingleMaterialColor();
    // }

    // Ambient
    mediump float ambientStrength = 0.3;
    mediump vec4 ambient = ambientStrength * lightColor;
    // Diffuse
    mediump vec3 s = normalize(lightDir);
    mediump vec3 n = normalize(fragNormal);
    mediump float diff = max(dot(s, n), 0.0);
    mediump vec4 diffuse = 0.7 * diff * lightColor;

    mediump float shadow = getShadow();
    mediump vec4 result = (ambient + (1.0 - shadow) * diffuse) * albedo;
    gl_FragColor = vec4(result.rgb, 1.0);
}
